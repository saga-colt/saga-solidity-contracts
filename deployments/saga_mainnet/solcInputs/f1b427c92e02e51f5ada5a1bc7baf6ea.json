{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ContextUpgradeable} from \"../../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * NOTE: When this extension is used along with the {ERC20Capped} or {ERC20Votes} extensions,\n * {maxFlashLoan} will not correctly reflect the maximum that can be flash minted. We recommend\n * overriding {maxFlashLoan} so that it correctly reflects the supply cap.\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLender {\n    bytes32 private constant RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev The loan token is not valid.\n     */\n    error ERC3156UnsupportedToken(address token);\n\n    /**\n     * @dev The requested loan exceeds the max loan value for `token`.\n     */\n    error ERC3156ExceededMaxLoan(uint256 maxLoan);\n\n    /**\n     * @dev The receiver of a flashloan is not a valid {IERC3156FlashBorrower-onFlashLoan} implementer.\n     */\n    error ERC3156InvalidReceiver(address receiver);\n\n    function __ERC20FlashMint_init() internal onlyInitializing {\n    }\n\n    function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     *\n     * NOTE: This function does not consider any form of supply cap, so in case\n     * it's used in a token with a cap like {ERC20Capped}, make sure to override this\n     * function to integrate the cap instead of `type(uint256).max`.\n     */\n    function maxFlashLoan(address token) public view virtual returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. This function calls\n     * the {_flashFee} function which returns the fee applied when doing flash\n     * loans.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 value) public view virtual returns (uint256) {\n        if (token != address(this)) {\n            revert ERC3156UnsupportedToken(token);\n        }\n        return _flashFee(token, value);\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function _flashFee(address token, uint256 value) internal view virtual returns (uint256) {\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n        value;\n        return 0;\n    }\n\n    /**\n     * @dev Returns the receiver address of the flash fee. By default this\n     * implementation returns the address(0) which means the fee amount will be burnt.\n     * This function can be overloaded to change the fee receiver.\n     * @return The address for which the flash fee will be sent to.\n     */\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * value + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower-onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param value The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) public virtual returns (bool) {\n        uint256 maxLoan = maxFlashLoan(token);\n        if (value > maxLoan) {\n            revert ERC3156ExceededMaxLoan(maxLoan);\n        }\n        uint256 fee = flashFee(token, value);\n        _mint(address(receiver), value);\n        if (receiver.onFlashLoan(_msgSender(), token, value, fee, data) != RETURN_VALUE) {\n            revert ERC3156InvalidReceiver(address(receiver));\n        }\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), value + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), value + fee);\n        } else {\n            _burn(address(receiver), value);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"../../../utils/PausableUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626 {\n    using Math for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC4626\n    struct ERC4626Storage {\n        IERC20 _asset;\n        uint8 _underlyingDecimals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC4626\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC4626StorageLocation = 0x0773e532dfede91f04b12a73d3d2acd361424f41f76b4fb79f090161e36b4e00;\n\n    function _getERC4626Storage() private pure returns (ERC4626Storage storage $) {\n        assembly {\n            $.slot := ERC4626StorageLocation\n        }\n    }\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    function __ERC4626_init(IERC20 asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20 asset_) internal onlyInitializing {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        $._underlyingDecimals = success ? assetDecimals : 18;\n        $._asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return $._underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return address($._asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator\n * each time {_domainSeparatorV4} is called. That is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function __Pausable_init() internal onlyInitializing {\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC-3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC3156FlashLender.sol)\n\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC-3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5267.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20FlashMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"../../../interfaces/IERC3156FlashLender.sol\";\nimport {ERC20} from \"../ERC20.sol\";\n\n/**\n * @dev Implementation of the ERC-3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * NOTE: When this extension is used along with the {ERC20Capped} or {ERC20Votes} extensions,\n * {maxFlashLoan} will not correctly reflect the maximum that can be flash minted. We recommend\n * overriding {maxFlashLoan} so that it correctly reflects the supply cap.\n */\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev The loan token is not valid.\n     */\n    error ERC3156UnsupportedToken(address token);\n\n    /**\n     * @dev The requested loan exceeds the max loan value for `token`.\n     */\n    error ERC3156ExceededMaxLoan(uint256 maxLoan);\n\n    /**\n     * @dev The receiver of a flashloan is not a valid {IERC3156FlashBorrower-onFlashLoan} implementer.\n     */\n    error ERC3156InvalidReceiver(address receiver);\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     *\n     * NOTE: This function does not consider any form of supply cap, so in case\n     * it's used in a token with a cap like {ERC20Capped}, make sure to override this\n     * function to integrate the cap instead of `type(uint256).max`.\n     */\n    function maxFlashLoan(address token) public view virtual returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. This function calls\n     * the {_flashFee} function which returns the fee applied when doing flash\n     * loans.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 value) public view virtual returns (uint256) {\n        if (token != address(this)) {\n            revert ERC3156UnsupportedToken(token);\n        }\n        return _flashFee(token, value);\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function _flashFee(address token, uint256 value) internal view virtual returns (uint256) {\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n        value;\n        return 0;\n    }\n\n    /**\n     * @dev Returns the receiver address of the flash fee. By default this\n     * implementation returns the address(0) which means the fee amount will be burnt.\n     * This function can be overloaded to change the fee receiver.\n     * @return The address for which the flash fee will be sent to.\n     */\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * value + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower-onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param value The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) public virtual returns (bool) {\n        uint256 maxLoan = maxFlashLoan(token);\n        if (value > maxLoan) {\n            revert ERC3156ExceededMaxLoan(maxLoan);\n        }\n        uint256 fee = flashFee(token, value);\n        _mint(address(receiver), value);\n        if (receiver.onFlashLoan(_msgSender(), token, value, fee, data) != RETURN_VALUE) {\n            revert ERC3156InvalidReceiver(address(receiver));\n        }\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), value + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), value + fee);\n        } else {\n            _burn(address(receiver), value);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n * - Map can be cleared (all entries removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n * - `uint256 -> bytes32` (`UintToBytes32Map`) since v5.1.0\n * - `address -> address` (`AddressToAddressMap`) since v5.1.0\n * - `address -> bytes32` (`AddressToBytes32Map`) since v5.1.0\n * - `bytes32 -> address` (`Bytes32ToAddressMap`) since v5.1.0\n * - `bytes -> bytes` (`BytesToBytesMap`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for *;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32ToBytes32Map storage map) internal {\n        uint256 len = length(map);\n        for (uint256 i = 0; i < len; ++i) {\n            delete map._values[map._keys.at(i)];\n        }\n        map._keys.clear();\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32 key, bytes32 value) {\n        bytes32 atKey = map._keys.at(index);\n        return (atKey, map._values[atKey]);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool exists, bytes32 value) {\n        bytes32 val = map._values[key];\n        if (val == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, val);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        Bytes32ToBytes32Map storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes32[] memory) {\n        return map._keys.values(start, end);\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToBytes32Map\n\n    struct UintToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToBytes32Map storage map, uint256 key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToBytes32Map storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToBytes32Map storage map, uint256 index) internal view returns (uint256 key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), val);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToBytes32Map storage map, uint256 key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToBytes32Map storage map, uint256 key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToAddressMap\n\n    struct AddressToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToAddressMap storage map, uint256 index) internal view returns (address key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(uint256(uint160(key)))))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        AddressToAddressMap storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToBytes32Map\n\n    struct AddressToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToBytes32Map storage map, address key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToBytes32Map storage map, uint256 index) internal view returns (address key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), val);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToBytes32Map storage map, address key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToBytes32Map storage map, address key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        AddressToBytes32Map storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(Bytes32ToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToAddressMap\n\n    struct Bytes32ToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToAddressMap storage map, bytes32 key, address value) internal returns (bool) {\n        return set(map._inner, key, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(Bytes32ToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, key))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        Bytes32ToAddressMap storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentBytesKey(bytes key);\n\n    struct BytesToBytesMap {\n        // Storage of keys\n        EnumerableSet.BytesSet _keys;\n        mapping(bytes key => bytes) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(BytesToBytesMap storage map, bytes memory key, bytes memory value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(BytesToBytesMap storage map, bytes memory key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesToBytesMap storage map) internal {\n        uint256 len = length(map);\n        for (uint256 i = 0; i < len; ++i) {\n            delete map._values[map._keys.at(i)];\n        }\n        map._keys.clear();\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(BytesToBytesMap storage map, bytes memory key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(BytesToBytesMap storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        BytesToBytesMap storage map,\n        uint256 index\n    ) internal view returns (bytes memory key, bytes memory value) {\n        key = map._keys.at(index);\n        value = map._values[key];\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(\n        BytesToBytesMap storage map,\n        bytes memory key\n    ) internal view returns (bool exists, bytes memory value) {\n        value = map._values[key];\n        exists = bytes(value).length != 0 || contains(map, key);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(BytesToBytesMap storage map, bytes memory key) internal view returns (bytes memory value) {\n        bool exists;\n        (exists, value) = tryGet(map, key);\n        if (!exists) {\n            revert EnumerableMapNonexistentBytesKey(key);\n        }\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(BytesToBytesMap storage map) internal view returns (bytes[] memory) {\n        return map._keys.values();\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(BytesToBytesMap storage map, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        return map._keys.values(start, end);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * The following types are supported:\n *\n * - `bytes32` (`Bytes32Set`) since v3.3.0\n * - `address` (`AddressSet`) since v3.3.0\n * - `uint256` (`UintSet`) since v3.3.0\n * - `string` (`StringSet`) since v5.4.0\n * - `bytes` (`BytesSet`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with set size. Developers should keep in mind that\n     * using it may render the function uncallable if the set grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, uint256 start, uint256 end) private view returns (bytes32[] memory) {\n        unchecked {\n            end = Math.min(end, _length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes32[] memory result = new bytes32[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    struct StringSet {\n        // Storage of set values\n        string[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(string value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(StringSet storage set, string memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(StringSet storage set, string memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                string memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(StringSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(StringSet storage set, string memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(StringSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(StringSet storage set, uint256 index) internal view returns (string memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set) internal view returns (string[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set, uint256 start, uint256 end) internal view returns (string[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            string[] memory result = new string[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    struct BytesSet {\n        // Storage of set values\n        bytes[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(BytesSet storage set, bytes memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(BytesSet storage set, bytes memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(BytesSet storage set, bytes memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(BytesSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(BytesSet storage set, uint256 index) internal view returns (bytes memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set) internal view returns (bytes[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes[] memory result = new bytes[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n}\n"
    },
    "contracts/common/BasisPointConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nlibrary BasisPointConstants {\n    // Shared definitions of how we represent percentages and basis points\n    uint16 public constant ONE_BPS = 100; // 1 basis point with 2 decimals\n    uint32 public constant ONE_PERCENT_BPS = ONE_BPS * 100;\n    uint32 public constant ONE_HUNDRED_PERCENT_BPS = ONE_PERCENT_BPS * 100;\n}\n"
    },
    "contracts/common/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/common/IMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableERC20 is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/common/SupportsWithdrawalFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nerror InitialFeeExceedsMaxFee(uint256 feeBps, uint256 maxFeeBps);\nerror InvalidFeeBps(uint256 feeBps, uint256 maxFeeBps);\n\n// Note: FeeManagerCannotBeZeroAddress error can be handled by the consuming contract's AccessControl checks.\n\nabstract contract SupportsWithdrawalFee {\n    uint256 internal withdrawalFeeBps_;\n\n    event WithdrawalFee(address indexed owner, address indexed receiver, uint256 feeAmount);\n    event WithdrawalFeeSet(uint256 newFeeBps);\n\n    /**\n     * @notice Must be implemented by the inheriting contract to define its specific maximum withdrawal fee in BPS.\n     * @return The maximum withdrawal fee in basis points.\n     */\n    function _maxWithdrawalFeeBps() internal view virtual returns (uint256);\n\n    /**\n     * @notice Initialize the withdrawal fee during contract construction/initialization.\n     * @param initialFeeBps The initial withdrawal fee in basis points.\n     */\n    function _initializeWithdrawalFee(uint256 initialFeeBps) internal {\n        uint256 maxFee = _maxWithdrawalFeeBps();\n        if (initialFeeBps > maxFee) {\n            revert InitialFeeExceedsMaxFee(initialFeeBps, maxFee);\n        }\n        withdrawalFeeBps_ = initialFeeBps;\n        emit WithdrawalFeeSet(initialFeeBps);\n    }\n\n    /**\n     * @notice Set the withdrawal fee. Internal function to be called by the inheriting contract.\n     * @param newFeeBps The new withdrawal fee in basis points.\n     */\n    function _setWithdrawalFee(uint256 newFeeBps) internal {\n        uint256 maxFee = _maxWithdrawalFeeBps();\n        if (newFeeBps > maxFee) {\n            revert InvalidFeeBps(newFeeBps, maxFee);\n        }\n        withdrawalFeeBps_ = newFeeBps;\n        emit WithdrawalFeeSet(newFeeBps);\n    }\n\n    /**\n     * @notice Calculate the withdrawal fee for a given asset amount.\n     * @dev Uses precise division since fees stay in the vault (no external transfer).\n     * @param assetAmount The amount of assets being withdrawn.\n     * @return The fee amount in asset terms.\n     */\n    function _calculateWithdrawalFee(uint256 assetAmount) internal view returns (uint256) {\n        return Math.mulDiv(assetAmount, withdrawalFeeBps_, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n    }\n\n    /**\n     * @notice Calculate the net amount after deducting withdrawal fees.\n     * Used for previewRedeem to show what the user will actually receive.\n     * @param grossAmount The gross amount before fees.\n     * @return The net amount after deducting fees.\n     */\n    function _getNetAmountAfterFee(uint256 grossAmount) internal view returns (uint256) {\n        uint256 fee = _calculateWithdrawalFee(grossAmount);\n        return grossAmount - fee;\n    }\n\n    /**\n     * @notice Calculate the gross amount required to achieve a desired net amount.\n     * Used for previewWithdraw to show how many shares are needed for a desired net withdrawal.\n     * @dev Uses precise division since fees stay in the vault.\n     * @param netAmount The desired net amount after fees.\n     * @return The gross amount required before fees.\n     */\n    function _getGrossAmountRequiredForNet(uint256 netAmount) internal view returns (uint256) {\n        if (withdrawalFeeBps_ == 0) {\n            return netAmount;\n        }\n        // grossAmount = netAmount / (1 - feeBps/ONE_HUNDRED_PERCENT_BPS)\n        // grossAmount = netAmount * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS - feeBps)\n        return\n            Math.mulDiv(\n                netAmount,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - withdrawalFeeBps_\n            );\n    }\n\n    /**\n     * @notice Get the current withdrawal fee in basis points.\n     * @return The withdrawal fee in basis points.\n     */\n    function getWithdrawalFeeBps() public view returns (uint256) {\n        return withdrawalFeeBps_;\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// Chainlink Contracts v0.8\npragma solidity ^0.8.20;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../openzeppelin/contracts/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary GPv2SafeERC20 {\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        bytes4 selector_ = token.transfer.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"GPv2: failed transfer\");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        bytes4 selector_ = token.transferFrom.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"GPv2: failed transferFrom\");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTransferResult(IERC20 token) private view returns (bool success) {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(\"Error(string)\")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, \"\\x08\\xc3\\x79\\xa0\")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n            // Non-standard ERC20 transfer without return.\n            case 0 {\n                // NOTE: When the return data size is 0, verify that there\n                // is code at the address. This is done in order to maintain\n                // compatibility with Solidity calling conventions.\n                // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n                if iszero(extcodesize(token)) {\n                    revertWithMessage(20, \"GPv2: not a contract\")\n                }\n\n                success := 1\n            }\n            // Standard ERC20 transfer returning boolean success value.\n            case 32 {\n                returndatacopy(0, 0, returndatasize())\n\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\n                // as `true` for a boolean. In order to stay compatible with\n                // OpenZeppelin's `SafeERC20` library which is known to work\n                // with the existing ERC20 implementation we care about,\n                // make sure we return success for any non-zero return value\n                // from the `transfer*` call.\n                success := iszero(iszero(mload(0)))\n            }\n            default {\n                revertWithMessage(31, \"GPv2: malformed transfer result\")\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./IAccessControl.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory tokenName, string memory tokenSymbol) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"./IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary SafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            require((z = x + y) >= x);\n        }\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            require((z = x - y) <= x);\n        }\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @param message The error msg\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y, string memory message) internal pure returns (uint256 z) {\n        unchecked {\n            require((z = x - y) <= x, message);\n        }\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            require(x == 0 || (z = x * y) / x == y);\n        }\n    }\n\n    /// @notice Returns x / y, reverts if overflows - no specific check, solidity reverts on division by 0\n    /// @param x The numerator\n    /// @param y The denominator\n    /// @return z The product of x and y\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n    /**\n     * Contract constructor.\n     * @param _logic address of the initial implementation.\n     * @param _admin Address of the proxy administrator.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(address _logic, address _admin, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n        BaseAdminUpgradeabilityProxy._willFallback();\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier to check whether the `msg.sender` is the admin.\n     * If it is, it will run the function. Otherwise, it will delegate the call\n     * to the implementation.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @return The address of the proxy admin.\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @return adm The admin slot.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the proxy admin.\n     * @param newAdmin Address of the new proxy admin.\n     */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal virtual override {\n        require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./Proxy.sol\";\nimport \"../contracts/Address.sol\";\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view override returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        //solium-disable-next-line\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\nimport \"./InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n    /**\n     * Contract initializer.\n     * @param logic address of the initial implementation.\n     * @param admin Address of the proxy administrator.\n     * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    function initialize(address logic, address admin, bytes memory data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(logic, data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin);\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n        BaseAdminUpgradeabilityProxy._willFallback();\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Contract initializer.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n    /**\n     * @dev Fallback function.\n     * Will run if no other function in the contract matches the call data.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @return The Address of the implementation.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param implementation Address to delegate.\n     */\n    function _delegate(address implementation) internal {\n        //solium-disable-next-line\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal virtual {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Contract constructor.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/deployments/ReservesSetupHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport {PoolConfigurator} from \"../protocol/pool/PoolConfigurator.sol\";\nimport {Ownable} from \"../dependencies/openzeppelin/contracts/Ownable.sol\";\n\n/**\n * @title ReservesSetupHelper\n * @author Aave\n * @notice Deployment helper to setup the assets risk parameters at PoolConfigurator in batch.\n * @dev The ReservesSetupHelper is an Ownable contract, so only the deployer or future owners can call this contract.\n */\ncontract ReservesSetupHelper is Ownable {\n    struct ConfigureReserveInput {\n        address asset;\n        uint256 baseLTV;\n        uint256 liquidationThreshold;\n        uint256 liquidationBonus;\n        uint256 reserveFactor;\n        uint256 borrowCap;\n        uint256 supplyCap;\n        bool stableBorrowingEnabled;\n        bool borrowingEnabled;\n        bool flashLoanEnabled;\n    }\n\n    /**\n     * @notice External function called by the owner account to setup the assets risk parameters in batch.\n     * @dev The Pool or Risk admin must transfer the ownership to ReservesSetupHelper before calling this function\n     * @param configurator The address of PoolConfigurator contract\n     * @param inputParams An array of ConfigureReserveInput struct that contains the assets and their risk parameters\n     */\n    function configureReserves(\n        PoolConfigurator configurator,\n        ConfigureReserveInput[] calldata inputParams\n    ) external onlyOwner {\n        for (uint256 i = 0; i < inputParams.length; i++) {\n            configurator.configureReserveAsCollateral(\n                inputParams[i].asset,\n                inputParams[i].baseLTV,\n                inputParams[i].liquidationThreshold,\n                inputParams[i].liquidationBonus\n            );\n\n            if (inputParams[i].borrowingEnabled) {\n                configurator.setReserveBorrowing(inputParams[i].asset, true);\n\n                configurator.setBorrowCap(\n                    inputParams[i].asset,\n                    inputParams[i].borrowCap\n                );\n                configurator.setReserveStableRateBorrowing(\n                    inputParams[i].asset,\n                    inputParams[i].stableBorrowingEnabled\n                );\n            }\n            configurator.setReserveFlashLoaning(\n                inputParams[i].asset,\n                inputParams[i].flashLoanEnabled\n            );\n            configurator.setSupplyCap(\n                inputParams[i].asset,\n                inputParams[i].supplyCap\n            );\n            configurator.setReserveFactor(\n                inputParams[i].asset,\n                inputParams[i].reserveFactor\n            );\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IFlashLoanReceiver } from \"../interfaces/IFlashLoanReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\n\n/**\n * @title FlashLoanReceiverBase\n * @author Aave\n * @notice Base contract to develop a flashloan-receiver contract.\n */\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n    IPool public immutable override POOL;\n\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n        POOL = IPool(provider.getPool());\n    }\n}\n"
    },
    "contracts/dlend/core/flashloan/base/FlashLoanSimpleReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IFlashLoanSimpleReceiver } from \"../interfaces/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\n\n/**\n * @title FlashLoanSimpleReceiverBase\n * @author Aave\n * @notice Base contract to develop a flashloan-receiver contract.\n */\nabstract contract FlashLoanSimpleReceiverBase is IFlashLoanSimpleReceiver {\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n    IPool public immutable override POOL;\n\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n        POOL = IPool(provider.getPool());\n    }\n}\n"
    },
    "contracts/dlend/core/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\n\n/**\n * @title IFlashLoanReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed assets\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\n     *      enough funds to repay and has approved the Pool to pull the total amount\n     * @param assets The addresses of the flash-borrowed assets\n     * @param amounts The amounts of the flash-borrowed assets\n     * @param premiums The fee of each flash-borrowed asset\n     * @param initiator The address of the flashloan initiator\n     * @param params The byte-encoded params passed when initiating the flashloan\n     * @return True if the execution of the operation succeeds, false otherwise\n     */\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    function POOL() external view returns (IPool);\n}\n"
    },
    "contracts/dlend/core/flashloan/interfaces/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\n\n/**\n * @title IFlashLoanSimpleReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanSimpleReceiver {\n    /**\n     * @notice Executes an operation after receiving the flash-borrowed asset\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\n     *      enough funds to repay and has approved the Pool to pull the total amount\n     * @param asset The address of the flash-borrowed asset\n     * @param amount The amount of the flash-borrowed asset\n     * @param premium The fee of the flash-borrowed asset\n     * @param initiator The address of the flashloan initiator\n     * @param params The byte-encoded params passed when initiating the flashloan\n     * @return True if the execution of the operation succeeds, false otherwise\n     */\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    function POOL() external view returns (IPool);\n}\n"
    },
    "contracts/dlend/core/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n    /**\n     * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n     * @dev The units of `totalSupply` and `userBalance` should be the same.\n     * @param user The address of the user whose asset balance has changed\n     * @param totalSupply The total supply of the asset prior to user balance change\n     * @param userBalance The previous user balance prior to balance change\n     */\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPriceOracleGetter } from \"./IPriceOracleGetter.sol\";\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n    /**\n     * @dev Emitted after the base currency is set\n     * @param baseCurrency The base currency of used for price quotes\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n    /**\n     * @dev Emitted after the price source of an asset is updated\n     * @param asset The address of the asset\n     * @param source The price source of the asset\n     */\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n\n    /**\n     * @dev Emitted after the address of fallback oracle is updated\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    /**\n     * @notice Returns the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Sets or replaces price sources of assets\n     * @param assets The addresses of the assets\n     * @param sources The addresses of the price sources\n     */\n    function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n    /**\n     * @notice Sets the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function setFallbackOracle(address fallbackOracle) external;\n\n    /**\n     * @notice Returns a list of prices from a list of assets addresses\n     * @param assets The list of assets addresses\n     * @return The prices of the given assets\n     */\n    function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns the address of the source for an asset address\n     * @param asset The address of the asset\n     * @return The address of the source\n     */\n    function getSourceOfAsset(address asset) external view returns (address);\n\n    /**\n     * @notice Returns the address of the fallback oracle\n     * @return The address of the fallback oracle\n     */\n    function getFallbackOracle() external view returns (address);\n}\n"
    },
    "contracts/dlend/core/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IACLManager\n * @author Aave\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager {\n    /**\n     * @notice Returns the contract address of the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Returns the identifier of the PoolAdmin role\n     * @return The id of the PoolAdmin role\n     */\n    function POOL_ADMIN_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the EmergencyAdmin role\n     * @return The id of the EmergencyAdmin role\n     */\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the RiskAdmin role\n     * @return The id of the RiskAdmin role\n     */\n    function RISK_ADMIN_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the FlashBorrower role\n     * @return The id of the FlashBorrower role\n     */\n    function FLASH_BORROWER_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the Bridge role\n     * @return The id of the Bridge role\n     */\n    function BRIDGE_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the AssetListingAdmin role\n     * @return The id of the AssetListingAdmin role\n     */\n    function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Set the role as admin of a specific role.\n     * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n     * @param role The role to be managed by the admin role\n     * @param adminRole The admin role\n     */\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n    /**\n     * @notice Adds a new admin as PoolAdmin\n     * @param admin The address of the new admin\n     */\n    function addPoolAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as PoolAdmin\n     * @param admin The address of the admin to remove\n     */\n    function removePoolAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is PoolAdmin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is PoolAdmin, false otherwise\n     */\n    function isPoolAdmin(address admin) external view returns (bool);\n\n    /**\n     * @notice Adds a new admin as EmergencyAdmin\n     * @param admin The address of the new admin\n     */\n    function addEmergencyAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as EmergencyAdmin\n     * @param admin The address of the admin to remove\n     */\n    function removeEmergencyAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is EmergencyAdmin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is EmergencyAdmin, false otherwise\n     */\n    function isEmergencyAdmin(address admin) external view returns (bool);\n\n    /**\n     * @notice Adds a new admin as RiskAdmin\n     * @param admin The address of the new admin\n     */\n    function addRiskAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as RiskAdmin\n     * @param admin The address of the admin to remove\n     */\n    function removeRiskAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is RiskAdmin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is RiskAdmin, false otherwise\n     */\n    function isRiskAdmin(address admin) external view returns (bool);\n\n    /**\n     * @notice Adds a new address as FlashBorrower\n     * @param borrower The address of the new FlashBorrower\n     */\n    function addFlashBorrower(address borrower) external;\n\n    /**\n     * @notice Removes an address as FlashBorrower\n     * @param borrower The address of the FlashBorrower to remove\n     */\n    function removeFlashBorrower(address borrower) external;\n\n    /**\n     * @notice Returns true if the address is FlashBorrower, false otherwise\n     * @param borrower The address to check\n     * @return True if the given address is FlashBorrower, false otherwise\n     */\n    function isFlashBorrower(address borrower) external view returns (bool);\n\n    /**\n     * @notice Adds a new address as Bridge\n     * @param bridge The address of the new Bridge\n     */\n    function addBridge(address bridge) external;\n\n    /**\n     * @notice Removes an address as Bridge\n     * @param bridge The address of the bridge to remove\n     */\n    function removeBridge(address bridge) external;\n\n    /**\n     * @notice Returns true if the address is Bridge, false otherwise\n     * @param bridge The address to check\n     * @return True if the given address is Bridge, false otherwise\n     */\n    function isBridge(address bridge) external view returns (bool);\n\n    /**\n     * @notice Adds a new admin as AssetListingAdmin\n     * @param admin The address of the new admin\n     */\n    function addAssetListingAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as AssetListingAdmin\n     * @param admin The address of the admin to remove\n     */\n    function removeAssetListingAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is AssetListingAdmin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is AssetListingAdmin, false otherwise\n     */\n    function isAssetListingAdmin(address admin) external view returns (bool);\n}\n"
    },
    "contracts/dlend/core/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IScaledBalanceToken } from \"./IScaledBalanceToken.sol\";\nimport { IInitializableAToken } from \"./IInitializableAToken.sol\";\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n    /**\n     * @dev Emitted during the transfer action\n     * @param from The user whose tokens are being transferred\n     * @param to The recipient\n     * @param value The scaled amount being transferred\n     * @param index The next liquidity index of the reserve\n     */\n    event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n    /**\n     * @notice Mints `amount` aTokens to `user`\n     * @param caller The address performing the mint\n     * @param onBehalfOf The address of the user that will receive the minted aTokens\n     * @param amount The amount of tokens getting minted\n     * @param index The next liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(address caller, address onBehalfOf, uint256 amount, uint256 index) external returns (bool);\n\n    /**\n     * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @dev In some instances, the mint event could be emitted from a burn transaction\n     * if the amount to burn is less than the interest that the user accrued\n     * @param from The address from which the aTokens will be burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The next liquidity index of the reserve\n     */\n    function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n    /**\n     * @notice Mints aTokens to the reserve treasury\n     * @param amount The amount of tokens getting minted\n     * @param index The next liquidity index of the reserve\n     */\n    function mintToTreasury(uint256 amount, uint256 index) external;\n\n    /**\n     * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n     * @param from The address getting liquidated, current owner of the aTokens\n     * @param to The recipient\n     * @param value The amount of tokens getting transferred\n     */\n    function transferOnLiquidation(address from, address to, uint256 value) external;\n\n    /**\n     * @notice Transfers the underlying asset to `target`.\n     * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n     * @param target The recipient of the underlying\n     * @param amount The amount getting transferred\n     */\n    function transferUnderlyingTo(address target, uint256 amount) external;\n\n    /**\n     * @notice Handles the underlying received by the aToken after the transfer has been completed.\n     * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n     * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n     * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n     * @param user The user executing the repayment\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed\n     * @param amount The amount getting repaid\n     */\n    function handleRepayment(address user, address onBehalfOf, uint256 amount) external;\n\n    /**\n     * @notice Allow passing a signed message to approve spending\n     * @dev implements the permit function as for\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner The owner of the funds\n     * @param spender The spender\n     * @param value The amount\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v Signature param\n     * @param s Signature param\n     * @param r Signature param\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @return The address of the underlying asset\n     */\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n    /**\n     * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n     * @return Address of the Aave treasury\n     */\n    function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n    /**\n     * @notice Get the domain separator for the token\n     * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n     * @return The domain separator of the token at current chain\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /**\n     * @notice Returns the nonce for owner.\n     * @param owner The address of the owner\n     * @return The nonce of the owner\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title ICreditDelegationToken\n * @author Aave\n * @notice Defines the basic interface for a token supporting credit delegation.\n */\ninterface ICreditDelegationToken {\n    /**\n     * @dev Emitted on `approveDelegation` and `borrowAllowance\n     * @param fromUser The address of the delegator\n     * @param toUser The address of the delegatee\n     * @param asset The address of the delegated asset\n     * @param amount The amount being delegated\n     */\n    event BorrowAllowanceDelegated(\n        address indexed fromUser,\n        address indexed toUser,\n        address indexed asset,\n        uint256 amount\n    );\n\n    /**\n     * @notice Delegates borrowing power to a user on the specific debt token.\n     * Delegation will still respect the liquidation constraints (even if delegated, a\n     * delegatee cannot force a delegator HF to go below 1)\n     * @param delegatee The address receiving the delegated borrowing power\n     * @param amount The maximum amount being delegated.\n     */\n    function approveDelegation(address delegatee, uint256 amount) external;\n\n    /**\n     * @notice Returns the borrow allowance of the user\n     * @param fromUser The user to giving allowance\n     * @param toUser The user to give allowance to\n     * @return The current allowance of `toUser`\n     */\n    function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n\n    /**\n     * @notice Delegates borrowing power to a user on the specific debt token via ERC712 signature\n     * @param delegator The delegator of the credit\n     * @param delegatee The delegatee that can use the credit\n     * @param value The amount to be delegated\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v The V signature param\n     * @param s The S signature param\n     * @param r The R signature param\n     */\n    function delegationWithSig(\n        address delegator,\n        address delegatee,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IDefaultInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IReserveInterestRateStrategy } from \"./IReserveInterestRateStrategy.sol\";\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IDefaultInterestRateStrategy\n * @author Aave\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\n */\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\n    /**\n     * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\n     * @return The optimal usage ratio, expressed in ray.\n     */\n    function OPTIMAL_USAGE_RATIO() external view returns (uint256);\n\n    /**\n     * @notice Returns the optimal stable to total debt ratio of the reserve.\n     * @return The optimal stable to total debt ratio, expressed in ray.\n     */\n    function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n    /**\n     * @notice Returns the excess usage ratio above the optimal.\n     * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\n     * @return The max excess usage ratio, expressed in ray.\n     */\n    function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\n\n    /**\n     * @notice Returns the excess stable debt ratio above the optimal.\n     * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\n     * @return The max excess stable to total debt ratio, expressed in ray.\n     */\n    function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n    /**\n     * @notice Returns the address of the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Returns the variable rate slope below optimal usage ratio\n     * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n     * @return The variable rate slope, expressed in ray\n     */\n    function getVariableRateSlope1() external view returns (uint256);\n\n    /**\n     * @notice Returns the variable rate slope above optimal usage ratio\n     * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n     * @return The variable rate slope, expressed in ray\n     */\n    function getVariableRateSlope2() external view returns (uint256);\n\n    /**\n     * @notice Returns the stable rate slope below optimal usage ratio\n     * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n     * @return The stable rate slope, expressed in ray\n     */\n    function getStableRateSlope1() external view returns (uint256);\n\n    /**\n     * @notice Returns the stable rate slope above optimal usage ratio\n     * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n     * @return The stable rate slope, expressed in ray\n     */\n    function getStableRateSlope2() external view returns (uint256);\n\n    /**\n     * @notice Returns the stable rate excess offset\n     * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\n     * @return The stable rate excess offset, expressed in ray\n     */\n    function getStableRateExcessOffset() external view returns (uint256);\n\n    /**\n     * @notice Returns the base stable borrow rate\n     * @return The base stable borrow rate, expressed in ray\n     */\n    function getBaseStableBorrowRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the base variable borrow rate\n     * @return The base variable borrow rate, expressed in ray\n     */\n    function getBaseVariableBorrowRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum variable borrow rate\n     * @return The maximum variable borrow rate, expressed in ray\n     */\n    function getMaxVariableBorrowRate() external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IDelegationToken\n * @author Aave\n * @notice Implements an interface for tokens with delegation COMP/UNI compatible\n */\ninterface IDelegationToken {\n    /**\n     * @notice Delegate voting power to a delegatee\n     * @param delegatee The address of the delegatee\n     */\n    function delegate(address delegatee) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title IERC20WithPermit\n * @author Aave\n * @notice Interface for the permit function (EIP-2612)\n */\ninterface IERC20WithPermit is IERC20 {\n    /**\n     * @notice Allow passing a signed message to approve spending\n     * @dev implements the permit function as for\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner The owner of the funds\n     * @param spender The spender\n     * @param value The amount\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v Signature param\n     * @param s Signature param\n     * @param r Signature param\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\nimport { IPool } from \"./IPool.sol\";\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n    /**\n     * @dev Emitted when an aToken is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param pool The address of the associated pool\n     * @param treasury The address of the treasury\n     * @param incentivesController The address of the incentives controller for this aToken\n     * @param aTokenDecimals The decimals of the underlying\n     * @param aTokenName The name of the aToken\n     * @param aTokenSymbol The symbol of the aToken\n     * @param params A set of encoded parameters for additional initialization\n     */\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed pool,\n        address treasury,\n        address incentivesController,\n        uint8 aTokenDecimals,\n        string aTokenName,\n        string aTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @notice Initializes the aToken\n     * @param pool The pool contract that is initializing this contract\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @param incentivesController The smart contract managing potential incentives distribution\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n     * @param aTokenName The name of the aToken\n     * @param aTokenSymbol The symbol of the aToken\n     * @param params A set of encoded parameters for additional initialization\n     */\n    function initialize(\n        IPool pool,\n        address treasury,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 aTokenDecimals,\n        string calldata aTokenName,\n        string calldata aTokenSymbol,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\nimport { IPool } from \"./IPool.sol\";\n\n/**\n * @title IInitializableDebtToken\n * @author Aave\n * @notice Interface for the initialize function common between debt tokens\n */\ninterface IInitializableDebtToken {\n    /**\n     * @dev Emitted when a debt token is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param pool The address of the associated pool\n     * @param incentivesController The address of the incentives controller for this aToken\n     * @param debtTokenDecimals The decimals of the debt token\n     * @param debtTokenName The name of the debt token\n     * @param debtTokenSymbol The symbol of the debt token\n     * @param params A set of encoded parameters for additional initialization\n     */\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed pool,\n        address incentivesController,\n        uint8 debtTokenDecimals,\n        string debtTokenName,\n        string debtTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @notice Initializes the debt token.\n     * @param pool The pool contract that is initializing this contract\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @param incentivesController The smart contract managing potential incentives distribution\n     * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n     * @param debtTokenName The name of the token\n     * @param debtTokenSymbol The symbol of the token\n     * @param params A set of encoded parameters for additional initialization\n     */\n    function initialize(\n        IPool pool,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 debtTokenDecimals,\n        string memory debtTokenName,\n        string memory debtTokenSymbol,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IL2Pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IL2Pool\n * @author Aave\n * @notice Defines the basic extension interface for an L2 Aave Pool.\n */\ninterface IL2Pool {\n    /**\n     * @notice Calldata efficient wrapper of the supply function on behalf of the caller\n     * @param args Arguments for the supply function packed in one bytes32\n     *    96 bits       16 bits         128 bits      16 bits\n     * | 0-padding | referralCode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     */\n    function supply(bytes32 args) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the supplyWithPermit function on behalf of the caller\n     * @param args Arguments for the supply function packed in one bytes32\n     *    56 bits    8 bits         32 bits           16 bits         128 bits      16 bits\n     * | 0-padding | permitV | shortenedDeadline | referralCode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     * @param r The R parameter of ERC712 permit sig\n     * @param s The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(bytes32 args, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the withdraw function, withdrawing to the caller\n     * @param args Arguments for the withdraw function packed in one bytes32\n     *    112 bits       128 bits      16 bits\n     * | 0-padding | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     * @return The final amount withdrawn\n     */\n    function withdraw(bytes32 args) external returns (uint256);\n\n    /**\n     * @notice Calldata efficient wrapper of the borrow function, borrowing on behalf of the caller\n     * @param args Arguments for the borrow function packed in one bytes32\n     *    88 bits       16 bits             8 bits                 128 bits       16 bits\n     * | 0-padding | referralCode | shortenedInterestRateMode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     */\n    function borrow(bytes32 args) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the repay function, repaying on behalf of the caller\n     * @param args Arguments for the repay function packed in one bytes32\n     *    104 bits             8 bits               128 bits       16 bits\n     * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     * @return The final amount repaid\n     */\n    function repay(bytes32 args) external returns (uint256);\n\n    /**\n     * @notice Calldata efficient wrapper of the repayWithPermit function, repaying on behalf of the caller\n     * @param args Arguments for the repayWithPermit function packed in one bytes32\n     *    64 bits    8 bits        32 bits                   8 bits               128 bits       16 bits\n     * | 0-padding | permitV | shortenedDeadline | shortenedInterestRateMode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     * @param r The R parameter of ERC712 permit sig\n     * @param s The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(bytes32 args, bytes32 r, bytes32 s) external returns (uint256);\n\n    /**\n     * @notice Calldata efficient wrapper of the repayWithATokens function\n     * @param args Arguments for the repayWithATokens function packed in one bytes32\n     *    104 bits             8 bits               128 bits       16 bits\n     * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n     * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n     * type(uint256).max\n     * @dev assetId is the index of the asset in the reservesList.\n     * @return The final amount repaid\n     */\n    function repayWithATokens(bytes32 args) external returns (uint256);\n\n    /**\n     * @notice Calldata efficient wrapper of the swapBorrowRateMode function\n     * @param args Arguments for the swapBorrowRateMode function packed in one bytes32\n     *    232 bits            8 bits             16 bits\n     * | 0-padding | shortenedInterestRateMode | assetId |\n     * @dev assetId is the index of the asset in the reservesList.\n     */\n    function swapBorrowRateMode(bytes32 args) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the rebalanceStableBorrowRate function\n     * @param args Arguments for the rebalanceStableBorrowRate function packed in one bytes32\n     *    80 bits      160 bits     16 bits\n     * | 0-padding | user address | assetId |\n     * @dev assetId is the index of the asset in the reservesList.\n     */\n    function rebalanceStableBorrowRate(bytes32 args) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the setUserUseReserveAsCollateral function\n     * @param args Arguments for the setUserUseReserveAsCollateral function packed in one bytes32\n     *    239 bits         1 bit       16 bits\n     * | 0-padding | useAsCollateral | assetId |\n     * @dev assetId is the index of the asset in the reservesList.\n     */\n    function setUserUseReserveAsCollateral(bytes32 args) external;\n\n    /**\n     * @notice Calldata efficient wrapper of the liquidationCall function\n     * @param args1 part of the arguments for the liquidationCall function packed in one bytes32\n     *    64 bits      160 bits       16 bits         16 bits\n     * | 0-padding | user address | debtAssetId | collateralAssetId |\n     * @param args2 part of the arguments for the liquidationCall function packed in one bytes32\n     *    127 bits       1 bit             128 bits\n     * | 0-padding | receiveAToken | shortenedDebtToCover |\n     * @dev the shortenedDebtToCover is cast to 256 bits at decode time,\n     * if type(uint128).max the value will be expanded to type(uint256).max\n     */\n    function liquidationCall(bytes32 args1, bytes32 args2) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\nimport { DataTypes } from \"../protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n    /**\n     * @dev Emitted on mintUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n     * @param amount The amount of supplied assets\n     * @param referralCode The referral code used\n     */\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param backer The address paying for the backing\n     * @param amount The amount added as backing\n     * @param fee The amount paid in fees\n     */\n    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n    /**\n     * @dev Emitted on supply()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n     * @param amount The amount supplied\n     * @param referralCode The referral code used\n     */\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlying asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to The address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n     * @param referralCode The referral code used\n     */\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n     */\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    event SwapBorrowRateMode(\n        address indexed reserve,\n        address indexed user,\n        DataTypes.InterestRateMode interestRateMode\n    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n     * @param asset The address of the underlying asset of the reserve\n     * @param totalDebt The total isolation mode debt for the reserve\n     */\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n     * @param user The address of the user\n     * @param categoryId The category id\n     */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     */\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     */\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The next liquidity rate\n     * @param stableBorrowRate The next stable borrow rate\n     * @param variableBorrowRate The next variable borrow rate\n     * @param liquidityIndex The next liquidity index\n     * @param variableBorrowIndex The next variable borrow index\n     */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n     * @param reserve The address of the reserve\n     * @param amountMinted The amount minted to the treasury\n     */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n     * @param asset The address of the underlying asset to mint\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n     * @param asset The address of the underlying asset to back\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @return The backed amount\n     */\n    function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to The address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     */\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     */\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     */\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n     * equivalent debt tokens\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n     * balance is not enough to cover the whole debt\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return The final amount repaid\n     */\n    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n     * @param asset The address of the underlying asset supplied\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     */\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts of the assets being flash-borrowed\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n     * @param asset The address of the asset being flash-borrowed\n     * @param amount The amount of the asset being flash-borrowed\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n     * interest rate strategy\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param rateStrategyAddress The address of the interest rate strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param configuration The new configuration bitmap\n     */\n    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     */\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     */\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n     * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\n     * combination with variable debt supply/balances.\n     * If using this function externally, consider that is possible to have an increasing normalized\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\n     * (e.g. only updates with non-zero variable debt supply)\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state and configuration data of the reserve\n     */\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n     * @dev Only callable by the overlying aToken of the `asset`\n     * @param asset The address of the underlying asset of the aToken\n     * @param from The user from which the aTokens are transferred\n     * @param to The user receiving the aTokens\n     * @param amount The amount being transferred/withdrawn\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\n     */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n     * @dev It does not include dropped reserves\n     * @return The addresses of the underlying assets of the initialized reserves\n     */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n     * @return The address of the reserve associated with id\n     */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Returns the PoolAddressesProvider connected to this contract\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n     */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra, one time accumulated interest\n     * - A part is collected by the protocol treasury\n     * @dev The total premium is calculated on the total borrowed amount\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n     * @dev Only callable by the PoolConfigurator contract\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n     */\n    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n     * The category 0 is reserved as it's the default for volatile assets\n     * @param id The id of the category\n     * @param config The configuration of the category\n     */\n    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n     * @param id The id of the category\n     * @return The configuration data of the category\n     */\n    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n     * @param categoryId The id of the category\n     */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n     * @param user The address of the user\n     * @return The eMode id\n     */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n     * @return The percentage of available liquidity to borrow, expressed in bps\n     */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n     * @return The total fee on flashloans\n     */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n     * @return The bridge fee sent to the protocol treasury\n     */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n     * @return The flashloan fee sent to the protocol treasury\n     */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n     * @return The maximum number of reserves supported\n     */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @dev Deprecated: Use the `supply` function instead\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddressFromID(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPoolAddressesProviderRegistry\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool Addresses Provider Registry.\n */\ninterface IPoolAddressesProviderRegistry {\n    /**\n     * @dev Emitted when a new AddressesProvider is registered.\n     * @param addressesProvider The address of the registered PoolAddressesProvider\n     * @param id The id of the registered PoolAddressesProvider\n     */\n    event AddressesProviderRegistered(address indexed addressesProvider, uint256 indexed id);\n\n    /**\n     * @dev Emitted when an AddressesProvider is unregistered.\n     * @param addressesProvider The address of the unregistered PoolAddressesProvider\n     * @param id The id of the unregistered PoolAddressesProvider\n     */\n    event AddressesProviderUnregistered(address indexed addressesProvider, uint256 indexed id);\n\n    /**\n     * @notice Returns the list of registered addresses providers\n     * @return The list of addresses providers\n     */\n    function getAddressesProvidersList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the id of a registered PoolAddressesProvider\n     * @param addressesProvider The address of the PoolAddressesProvider\n     * @return The id of the PoolAddressesProvider or 0 if is not registered\n     */\n    function getAddressesProviderIdByAddress(address addressesProvider) external view returns (uint256);\n\n    /**\n     * @notice Returns the address of a registered PoolAddressesProvider\n     * @param id The id of the market\n     * @return The address of the PoolAddressesProvider with the given id or zero address if it is not registered\n     */\n    function getAddressesProviderAddressById(uint256 id) external view returns (address);\n\n    /**\n     * @notice Registers an addresses provider\n     * @dev The PoolAddressesProvider must not already be registered in the registry\n     * @dev The id must not be used by an already registered PoolAddressesProvider\n     * @param provider The address of the new PoolAddressesProvider\n     * @param id The id for the new PoolAddressesProvider, referring to the market it belongs to\n     */\n    function registerAddressesProvider(address provider, uint256 id) external;\n\n    /**\n     * @notice Removes an addresses provider from the list of registered addresses providers\n     * @param provider The PoolAddressesProvider address\n     */\n    function unregisterAddressesProvider(address provider) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { ConfiguratorInputTypes } from \"../protocol/libraries/types/ConfiguratorInputTypes.sol\";\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n */\ninterface IPoolConfigurator {\n    /**\n     * @dev Emitted when a reserve is initialized.\n     * @param asset The address of the underlying asset of the reserve\n     * @param aToken The address of the associated aToken contract\n     * @param stableDebtToken The address of the associated stable rate debt token\n     * @param variableDebtToken The address of the associated variable rate debt token\n     * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n     */\n    event ReserveInitialized(\n        address indexed asset,\n        address indexed aToken,\n        address stableDebtToken,\n        address variableDebtToken,\n        address interestRateStrategyAddress\n    );\n\n    /**\n     * @dev Emitted when borrowing is enabled or disabled on a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if borrowing is enabled, false otherwise\n     */\n    event ReserveBorrowing(address indexed asset, bool enabled);\n\n    /**\n     * @dev Emitted when flashloans are enabled or disabled on a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if flashloans are enabled, false otherwise\n     */\n    event ReserveFlashLoaning(address indexed asset, bool enabled);\n\n    /**\n     * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param ltv The loan to value of the asset when used as collateral\n     * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n     * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n     */\n    event CollateralConfigurationChanged(\n        address indexed asset,\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus\n    );\n\n    /**\n     * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if stable rate borrowing is enabled, false otherwise\n     */\n    event ReserveStableRateBorrowing(address indexed asset, bool enabled);\n\n    /**\n     * @dev Emitted when a reserve is activated or deactivated\n     * @param asset The address of the underlying asset of the reserve\n     * @param active True if reserve is active, false otherwise\n     */\n    event ReserveActive(address indexed asset, bool active);\n\n    /**\n     * @dev Emitted when a reserve is frozen or unfrozen\n     * @param asset The address of the underlying asset of the reserve\n     * @param frozen True if reserve is frozen, false otherwise\n     */\n    event ReserveFrozen(address indexed asset, bool frozen);\n\n    /**\n     * @dev Emitted when a reserve is paused or unpaused\n     * @param asset The address of the underlying asset of the reserve\n     * @param paused True if reserve is paused, false otherwise\n     */\n    event ReservePaused(address indexed asset, bool paused);\n\n    /**\n     * @dev Emitted when a reserve is dropped.\n     * @param asset The address of the underlying asset of the reserve\n     */\n    event ReserveDropped(address indexed asset);\n\n    /**\n     * @dev Emitted when a reserve factor is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldReserveFactor The old reserve factor, expressed in bps\n     * @param newReserveFactor The new reserve factor, expressed in bps\n     */\n    event ReserveFactorChanged(address indexed asset, uint256 oldReserveFactor, uint256 newReserveFactor);\n\n    /**\n     * @dev Emitted when the borrow cap of a reserve is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldBorrowCap The old borrow cap\n     * @param newBorrowCap The new borrow cap\n     */\n    event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n    /**\n     * @dev Emitted when the supply cap of a reserve is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldSupplyCap The old supply cap\n     * @param newSupplyCap The new supply cap\n     */\n    event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n    /**\n     * @dev Emitted when the liquidation protocol fee of a reserve is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldFee The old liquidation protocol fee, expressed in bps\n     * @param newFee The new liquidation protocol fee, expressed in bps\n     */\n    event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\n\n    /**\n     * @dev Emitted when the unbacked mint cap of a reserve is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldUnbackedMintCap The old unbacked mint cap\n     * @param newUnbackedMintCap The new unbacked mint cap\n     */\n    event UnbackedMintCapChanged(address indexed asset, uint256 oldUnbackedMintCap, uint256 newUnbackedMintCap);\n\n    /**\n     * @dev Emitted when the category of an asset in eMode is changed.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldCategoryId The old eMode asset category\n     * @param newCategoryId The new eMode asset category\n     */\n    event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\n\n    /**\n     * @dev Emitted when a new eMode category is added.\n     * @param categoryId The new eMode category id\n     * @param ltv The ltv for the asset category in eMode\n     * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\n     * @param liquidationBonus The liquidationBonus for the asset category in eMode\n     * @param oracle The optional address of the price oracle specific for this category\n     * @param label A human readable identifier for the category\n     */\n    event EModeCategoryAdded(\n        uint8 indexed categoryId,\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus,\n        address oracle,\n        string label\n    );\n\n    /**\n     * @dev Emitted when a reserve interest strategy contract is updated.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldStrategy The address of the old interest strategy contract\n     * @param newStrategy The address of the new interest strategy contract\n     */\n    event ReserveInterestRateStrategyChanged(address indexed asset, address oldStrategy, address newStrategy);\n\n    /**\n     * @dev Emitted when an aToken implementation is upgraded.\n     * @param asset The address of the underlying asset of the reserve\n     * @param proxy The aToken proxy address\n     * @param implementation The new aToken implementation\n     */\n    event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n    /**\n     * @dev Emitted when the implementation of a stable debt token is upgraded.\n     * @param asset The address of the underlying asset of the reserve\n     * @param proxy The stable debt token proxy address\n     * @param implementation The new aToken implementation\n     */\n    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n    /**\n     * @dev Emitted when the implementation of a variable debt token is upgraded.\n     * @param asset The address of the underlying asset of the reserve\n     * @param proxy The variable debt token proxy address\n     * @param implementation The new aToken implementation\n     */\n    event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n    /**\n     * @dev Emitted when the debt ceiling of an asset is set.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldDebtCeiling The old debt ceiling\n     * @param newDebtCeiling The new debt ceiling\n     */\n    event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n    /**\n     * @dev Emitted when the the siloed borrowing state for an asset is changed.\n     * @param asset The address of the underlying asset of the reserve\n     * @param oldState The old siloed borrowing state\n     * @param newState The new siloed borrowing state\n     */\n    event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\n\n    /**\n     * @dev Emitted when the bridge protocol fee is updated.\n     * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\n     * @param newBridgeProtocolFee The new protocol fee, expressed in bps\n     */\n    event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\n\n    /**\n     * @dev Emitted when the total premium on flashloans is updated.\n     * @param oldFlashloanPremiumTotal The old premium, expressed in bps\n     * @param newFlashloanPremiumTotal The new premium, expressed in bps\n     */\n    event FlashloanPremiumTotalUpdated(uint128 oldFlashloanPremiumTotal, uint128 newFlashloanPremiumTotal);\n\n    /**\n     * @dev Emitted when the part of the premium that goes to protocol is updated.\n     * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\n     * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\n     */\n    event FlashloanPremiumToProtocolUpdated(\n        uint128 oldFlashloanPremiumToProtocol,\n        uint128 newFlashloanPremiumToProtocol\n    );\n\n    /**\n     * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\n     * @param asset The address of the underlying asset of the reserve\n     * @param borrowable True if the reserve is borrowable in isolation, false otherwise\n     */\n    event BorrowableInIsolationChanged(address asset, bool borrowable);\n\n    /**\n     * @notice Initializes multiple reserves.\n     * @param input The array of initialization parameters\n     */\n    function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\n\n    /**\n     * @dev Updates the aToken implementation for the reserve.\n     * @param input The aToken update parameters\n     */\n    function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\n\n    /**\n     * @notice Updates the stable debt token implementation for the reserve.\n     * @param input The stableDebtToken update parameters\n     */\n    function updateStableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external;\n\n    /**\n     * @notice Updates the variable debt token implementation for the asset.\n     * @param input The variableDebtToken update parameters\n     */\n    function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external;\n\n    /**\n     * @notice Configures borrowing on a reserve.\n     * @dev Can only be disabled (set to false) if stable borrowing is disabled\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if borrowing needs to be enabled, false otherwise\n     */\n    function setReserveBorrowing(address asset, bool enabled) external;\n\n    /**\n     * @notice Configures the reserve collateralization parameters.\n     * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\n     * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\n     * @param asset The address of the underlying asset of the reserve\n     * @param ltv The loan to value of the asset when used as collateral\n     * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n     * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n     */\n    function configureReserveAsCollateral(\n        address asset,\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus\n    ) external;\n\n    /**\n     * @notice Enable or disable stable rate borrowing on a reserve.\n     * @dev Can only be enabled (set to true) if borrowing is enabled\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\n     */\n    function setReserveStableRateBorrowing(address asset, bool enabled) external;\n\n    /**\n     * @notice Enable or disable flashloans on a reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @param enabled True if flashloans need to be enabled, false otherwise\n     */\n    function setReserveFlashLoaning(address asset, bool enabled) external;\n\n    /**\n     * @notice Activate or deactivate a reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @param active True if the reserve needs to be active, false otherwise\n     */\n    function setReserveActive(address asset, bool active) external;\n\n    /**\n     * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\n     * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\n     * @param asset The address of the underlying asset of the reserve\n     * @param freeze True if the reserve needs to be frozen, false otherwise\n     */\n    function setReserveFreeze(address asset, bool freeze) external;\n\n    /**\n     * @notice Sets the borrowable in isolation flag for the reserve.\n     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\n     * borrowed amount will be accumulated in the isolated collateral's total debt exposure\n     * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations\n     * @param asset The address of the underlying asset of the reserve\n     * @param borrowable True if the asset should be borrowable in isolation, false otherwise\n     */\n    function setBorrowableInIsolation(address asset, bool borrowable) external;\n\n    /**\n     * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n     * swap interest rate, liquidate, atoken transfers).\n     * @param asset The address of the underlying asset of the reserve\n     * @param paused True if pausing the reserve, false if unpausing\n     */\n    function setReservePause(address asset, bool paused) external;\n\n    /**\n     * @notice Updates the reserve factor of a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newReserveFactor The new reserve factor of the reserve\n     */\n    function setReserveFactor(address asset, uint256 newReserveFactor) external;\n\n    /**\n     * @notice Sets the interest rate strategy of a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newRateStrategyAddress The address of the new interest strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(address asset, address newRateStrategyAddress) external;\n\n    /**\n     * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n     * are suspended.\n     * @param paused True if protocol needs to be paused, false otherwise\n     */\n    function setPoolPause(bool paused) external;\n\n    /**\n     * @notice Updates the borrow cap of a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newBorrowCap The new borrow cap of the reserve\n     */\n    function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n    /**\n     * @notice Updates the supply cap of a reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newSupplyCap The new supply cap of the reserve\n     */\n    function setSupplyCap(address asset, uint256 newSupplyCap) external;\n\n    /**\n     * @notice Updates the liquidation protocol fee of reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\n     */\n    function setLiquidationProtocolFee(address asset, uint256 newFee) external;\n\n    /**\n     * @notice Updates the unbacked mint cap of reserve.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newUnbackedMintCap The new unbacked mint cap of the reserve\n     */\n    function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\n\n    /**\n     * @notice Assign an efficiency mode (eMode) category to asset.\n     * @param asset The address of the underlying asset of the reserve\n     * @param newCategoryId The new category id of the asset\n     */\n    function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\n\n    /**\n     * @notice Adds a new efficiency mode (eMode) category.\n     * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\n     * overcollateralization of the users using this category.\n     * @dev The new ltv and liquidation threshold must be greater than the base\n     * ltvs and liquidation thresholds of all assets within the eMode category\n     * @param categoryId The id of the category to be configured\n     * @param ltv The ltv associated with the category\n     * @param liquidationThreshold The liquidation threshold associated with the category\n     * @param liquidationBonus The liquidation bonus associated with the category\n     * @param oracle The oracle associated with the category\n     * @param label A label identifying the category\n     */\n    function setEModeCategory(\n        uint8 categoryId,\n        uint16 ltv,\n        uint16 liquidationThreshold,\n        uint16 liquidationBonus,\n        address oracle,\n        string calldata label\n    ) external;\n\n    /**\n     * @notice Drops a reserve entirely.\n     * @param asset The address of the reserve to drop\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the bridge fee collected by the protocol reserves.\n     * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\n     */\n    function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\n\n    /**\n     * @notice Updates the total flash loan premium.\n     * Total flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra balance\n     * - A part is collected by the protocol reserves\n     * @dev Expressed in bps\n     * @dev The premium is calculated on the total amount borrowed\n     * @param newFlashloanPremiumTotal The total flashloan premium\n     */\n    function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\n\n    /**\n     * @notice Updates the flash loan premium collected by protocol reserves\n     * @dev Expressed in bps\n     * @dev The premium to protocol is calculated on the total flashloan premium\n     * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\n     */\n    function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\n\n    /**\n     * @notice Sets the debt ceiling for an asset.\n     * @param newDebtCeiling The new debt ceiling\n     */\n    function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\n\n    /**\n     * @notice Sets siloed borrowing for an asset\n     * @param siloed The new siloed borrowing state\n     */\n    function setSiloedBorrowing(address asset, bool siloed) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IPoolDataProvider\n * @author Aave\n * @notice Defines the basic interface of a PoolDataProvider\n */\ninterface IPoolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    /**\n     * @notice Returns the address for the PoolAddressesProvider contract.\n     * @return The address for the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Returns the list of the existing reserves in the pool.\n     * @dev Handling MKR and ETH in a different way since they do not have standard `symbol` functions.\n     * @return The list of reserves, pairs of symbols and addresses\n     */\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    /**\n     * @notice Returns the list of the existing ATokens in the pool.\n     * @return The list of ATokens, pairs of symbols and addresses\n     */\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    /**\n     * @notice Returns the configuration data of the reserve\n     * @dev Not returning borrow and supply caps for compatibility, nor pause flag\n     * @param asset The address of the underlying asset of the reserve\n     * @return decimals The number of decimals of the reserve\n     * @return ltv The ltv of the reserve\n     * @return liquidationThreshold The liquidationThreshold of the reserve\n     * @return liquidationBonus The liquidationBonus of the reserve\n     * @return reserveFactor The reserveFactor of the reserve\n     * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise\n     * @return borrowingEnabled True if borrowing is enabled, false otherwise\n     * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise\n     * @return isActive True if it is active, false otherwise\n     * @return isFrozen True if it is frozen, false otherwise\n     */\n    function getReserveConfigurationData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    /**\n     * @notice Returns the efficiency mode category of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The eMode id of the reserve\n     */\n    function getReserveEModeCategory(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the caps parameters of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return borrowCap The borrow cap of the reserve\n     * @return supplyCap The supply cap of the reserve\n     */\n    function getReserveCaps(address asset) external view returns (uint256 borrowCap, uint256 supplyCap);\n\n    /**\n     * @notice Returns if the pool is paused\n     * @param asset The address of the underlying asset of the reserve\n     * @return isPaused True if the pool is paused, false otherwise\n     */\n    function getPaused(address asset) external view returns (bool isPaused);\n\n    /**\n     * @notice Returns the siloed borrowing flag\n     * @param asset The address of the underlying asset of the reserve\n     * @return True if the asset is siloed for borrowing\n     */\n    function getSiloedBorrowing(address asset) external view returns (bool);\n\n    /**\n     * @notice Returns the protocol fee on the liquidation bonus\n     * @param asset The address of the underlying asset of the reserve\n     * @return The protocol fee on liquidation\n     */\n    function getLiquidationProtocolFee(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the unbacked mint cap of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The unbacked mint cap of the reserve\n     */\n    function getUnbackedMintCap(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the debt ceiling of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The debt ceiling of the reserve\n     */\n    function getDebtCeiling(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the debt ceiling decimals\n     * @return The debt ceiling decimals\n     */\n    function getDebtCeilingDecimals() external pure returns (uint256);\n\n    /**\n     * @notice Returns the reserve data\n     * @param asset The address of the underlying asset of the reserve\n     * @return unbacked The amount of unbacked tokens\n     * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted\n     * @return totalAToken The total supply of the aToken\n     * @return totalStableDebt The total stable debt of the reserve\n     * @return totalVariableDebt The total variable debt of the reserve\n     * @return liquidityRate The liquidity rate of the reserve\n     * @return variableBorrowRate The variable borrow rate of the reserve\n     * @return stableBorrowRate The stable borrow rate of the reserve\n     * @return averageStableBorrowRate The average stable borrow rate of the reserve\n     * @return liquidityIndex The liquidity index of the reserve\n     * @return variableBorrowIndex The variable borrow index of the reserve\n     * @return lastUpdateTimestamp The timestamp of the last update of the reserve\n     */\n    function getReserveData(\n        address asset\n    )\n        external\n        view\n        returns (\n            uint256 unbacked,\n            uint256 accruedToTreasuryScaled,\n            uint256 totalAToken,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    /**\n     * @notice Returns the total supply of aTokens for a given asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The total supply of the aToken\n     */\n    function getATokenTotalSupply(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the total debt for a given asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The total debt for asset\n     */\n    function getTotalDebt(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the user data in a reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @param user The address of the user\n     * @return currentATokenBalance The current AToken balance of the user\n     * @return currentStableDebt The current stable debt of the user\n     * @return currentVariableDebt The current variable debt of the user\n     * @return principalStableDebt The principal stable debt of the user\n     * @return scaledVariableDebt The scaled variable debt of the user\n     * @return stableBorrowRate The stable borrow rate of the user\n     * @return liquidityRate The liquidity rate of the reserve\n     * @return stableRateLastUpdated The timestamp of the last update of the user stable rate\n     * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false\n     *         otherwise\n     */\n    function getUserReserveData(\n        address asset,\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    /**\n     * @notice Returns the token addresses of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return aTokenAddress The AToken address of the reserve\n     * @return stableDebtTokenAddress The StableDebtToken address of the reserve\n     * @return variableDebtTokenAddress The VariableDebtToken address of the reserve\n     */\n    function getReserveTokensAddresses(\n        address asset\n    ) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n\n    /**\n     * @notice Returns the address of the Interest Rate strategy\n     * @param asset The address of the underlying asset of the reserve\n     * @return irStrategyAddress The address of the Interest Rate strategy\n     */\n    function getInterestRateStrategyAddress(address asset) external view returns (address irStrategyAddress);\n\n    /**\n     * @notice Returns whether the reserve has FlashLoans enabled or disabled\n     * @param asset The address of the underlying asset of the reserve\n     * @return True if FlashLoans are enabled, false otherwise\n     */\n    function getFlashLoanEnabled(address asset) external view returns (bool);\n}\n"
    },
    "contracts/dlend/core/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IPriceOracleSentinel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IPriceOracleSentinel\n * @author Aave\n * @notice Defines the basic interface for the PriceOracleSentinel\n */\ninterface IPriceOracleSentinel {\n    /**\n     * @dev Emitted after the sequencer oracle is updated\n     * @param newSequencerOracle The new sequencer oracle\n     */\n    event SequencerOracleUpdated(address newSequencerOracle);\n\n    /**\n     * @dev Emitted after the grace period is updated\n     * @param newGracePeriod The new grace period value\n     */\n    event GracePeriodUpdated(uint256 newGracePeriod);\n\n    /**\n     * @notice Returns the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Returns true if the `borrow` operation is allowed.\n     * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n     * @return True if the `borrow` operation is allowed, false otherwise.\n     */\n    function isBorrowAllowed() external view returns (bool);\n\n    /**\n     * @notice Returns true if the `liquidation` operation is allowed.\n     * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n     * @return True if the `liquidation` operation is allowed, false otherwise.\n     */\n    function isLiquidationAllowed() external view returns (bool);\n\n    /**\n     * @notice Updates the address of the sequencer oracle\n     * @param newSequencerOracle The address of the new Sequencer Oracle to use\n     */\n    function setSequencerOracle(address newSequencerOracle) external;\n\n    /**\n     * @notice Updates the duration of the grace period\n     * @param newGracePeriod The value of the new grace period duration\n     */\n    function setGracePeriod(uint256 newGracePeriod) external;\n\n    /**\n     * @notice Returns the SequencerOracle\n     * @return The address of the sequencer oracle contract\n     */\n    function getSequencerOracle() external view returns (address);\n\n    /**\n     * @notice Returns the grace period\n     * @return The duration of the grace period\n     */\n    function getGracePeriod() external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { DataTypes } from \"../protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title IReserveInterestRateStrategy\n * @author Aave\n * @notice Interface for the calculation of the interest rates\n */\ninterface IReserveInterestRateStrategy {\n    /**\n     * @notice Calculates the interest rates depending on the reserve's state and configurations\n     * @param params The parameters needed to calculate interest rates\n     * @return liquidityRate The liquidity rate expressed in rays\n     * @return stableBorrowRate The stable borrow rate expressed in rays\n     * @return variableBorrowRate The variable borrow rate expressed in rays\n     */\n    function calculateInterestRates(\n        DataTypes.CalculateInterestRatesParams memory params\n    ) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param caller The address performing the mint\n     * @param onBehalfOf The address of the user that will receive the minted tokens\n     * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n     * @param index The next liquidity index of the reserve\n     */\n    event Mint(\n        address indexed caller,\n        address indexed onBehalfOf,\n        uint256 value,\n        uint256 balanceIncrease,\n        uint256 index\n    );\n\n    /**\n     * @dev Emitted after the burn action\n     * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n     * @param from The address from which the tokens will be burned\n     * @param target The address that will receive the underlying, if any\n     * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n     * @param index The next liquidity index of the reserve\n     */\n    event Burn(address indexed from, address indexed target, uint256 value, uint256 balanceIncrease, uint256 index);\n\n    /**\n     * @notice Returns the scaled balance of the user.\n     * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n     * at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     */\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled total supply\n     */\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n    /**\n     * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n     * @return The scaled total supply\n     */\n    function scaledTotalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns last index interest was accrued to the user's balance\n     * @param user The address of the user\n     * @return The last index interest was accrued to the user's balance, expressed in ray\n     */\n    function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/ISequencerOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title ISequencerOracle\n * @author Aave\n * @notice Defines the basic interface for a Sequencer oracle.\n */\ninterface ISequencerOracle {\n    /**\n     * @notice Returns the health status of the sequencer.\n     * @return roundId The round ID from the aggregator for which the data was retrieved combined with a phase to ensure\n     * that round IDs get larger as time moves forward.\n     * @return answer The answer for the latest round: 0 if the sequencer is up, 1 if it is down.\n     * @return startedAt The timestamp when the round was started.\n     * @return updatedAt The timestamp of the block in which the answer was updated on L1.\n     * @return answeredInRound The round ID of the round in which the answer was computed.\n     */\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/dlend/core/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IInitializableDebtToken } from \"./IInitializableDebtToken.sol\";\n\n/**\n * @title IStableDebtToken\n * @author Aave\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n */\ninterface IStableDebtToken is IInitializableDebtToken {\n    /**\n     * @dev Emitted when new stable debt is minted\n     * @param user The address of the user who triggered the minting\n     * @param onBehalfOf The recipient of stable debt tokens\n     * @param amount The amount minted (user entered amount + balance increase from interest)\n     * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n     * @param balanceIncrease The increase in balance since the last action of the user 'onBehalfOf'\n     * @param newRate The rate of the debt after the minting\n     * @param avgStableRate The next average stable rate after the minting\n     * @param newTotalSupply The next total supply of the stable debt token after the action\n     */\n    event Mint(\n        address indexed user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 currentBalance,\n        uint256 balanceIncrease,\n        uint256 newRate,\n        uint256 avgStableRate,\n        uint256 newTotalSupply\n    );\n\n    /**\n     * @dev Emitted when new stable debt is burned\n     * @param from The address from which the debt will be burned\n     * @param amount The amount being burned (user entered amount - balance increase from interest)\n     * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n     * @param balanceIncrease The increase in balance since the last action of 'from'\n     * @param avgStableRate The next average stable rate after the burning\n     * @param newTotalSupply The next total supply of the stable debt token after the action\n     */\n    event Burn(\n        address indexed from,\n        uint256 amount,\n        uint256 currentBalance,\n        uint256 balanceIncrease,\n        uint256 avgStableRate,\n        uint256 newTotalSupply\n    );\n\n    /**\n     * @notice Mints debt token to the `onBehalfOf` address.\n     * @dev The resulting rate is the weighted average between the rate of the new debt\n     * and the rate of the previous debt\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\n     * of credit delegate, or same as `onBehalfOf` otherwise\n     * @param onBehalfOf The address receiving the debt tokens\n     * @param amount The amount of debt tokens to mint\n     * @param rate The rate of the debt being minted\n     * @return True if it is the first borrow, false otherwise\n     * @return The total stable debt\n     * @return The average stable borrow rate\n     */\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 rate\n    ) external returns (bool, uint256, uint256);\n\n    /**\n     * @notice Burns debt of `user`\n     * @dev The resulting rate is the weighted average between the rate of the new debt\n     * and the rate of the previous debt\n     * @dev In some instances, a burn transaction will emit a mint event\n     * if the amount to burn is less than the interest the user earned\n     * @param from The address from which the debt will be burned\n     * @param amount The amount of debt tokens getting burned\n     * @return The total stable debt\n     * @return The average stable borrow rate\n     */\n    function burn(address from, uint256 amount) external returns (uint256, uint256);\n\n    /**\n     * @notice Returns the average rate of all the stable rate loans.\n     * @return The average stable rate\n     */\n    function getAverageStableRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the stable rate of the user debt\n     * @param user The address of the user\n     * @return The stable rate of the user\n     */\n    function getUserStableRate(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp of the last update of the user\n     * @param user The address of the user\n     * @return The timestamp\n     */\n    function getUserLastUpdated(address user) external view returns (uint40);\n\n    /**\n     * @notice Returns the principal, the total supply, the average stable rate and the timestamp for the last update\n     * @return The principal\n     * @return The total supply\n     * @return The average stable rate\n     * @return The timestamp of the last update\n     */\n    function getSupplyData() external view returns (uint256, uint256, uint256, uint40);\n\n    /**\n     * @notice Returns the timestamp of the last update of the total supply\n     * @return The timestamp\n     */\n    function getTotalSupplyLastUpdated() external view returns (uint40);\n\n    /**\n     * @notice Returns the total supply and the average stable rate\n     * @return The total supply\n     * @return The average rate\n     */\n    function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n    /**\n     * @notice Returns the principal debt balance of the user\n     * @return The debt balance of the user since the last burn/mint action\n     */\n    function principalBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the address of the underlying asset of this stableDebtToken (E.g. WETH for stableDebtWETH)\n     * @return The address of the underlying asset\n     */\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/dlend/core/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IScaledBalanceToken } from \"./IScaledBalanceToken.sol\";\nimport { IInitializableDebtToken } from \"./IInitializableDebtToken.sol\";\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n */\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n    /**\n     * @notice Mints debt token to the `onBehalfOf` address\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\n     * of credit delegate, or same as `onBehalfOf` otherwise\n     * @param onBehalfOf The address receiving the debt tokens\n     * @param amount The amount of debt being minted\n     * @param index The variable debt index of the reserve\n     * @return True if the previous balance of the user is 0, false otherwise\n     * @return The scaled total debt of the reserve\n     */\n    function mint(address user, address onBehalfOf, uint256 amount, uint256 index) external returns (bool, uint256);\n\n    /**\n     * @notice Burns user variable debt\n     * @dev In some instances, a burn transaction will emit a mint event\n     * if the amount to burn is less than the interest that the user accrued\n     * @param from The address from which the debt will be burned\n     * @param amount The amount getting burned\n     * @param index The variable debt index of the reserve\n     * @return The scaled total debt of the reserve\n     */\n    function burn(address from, uint256 amount, uint256 index) external returns (uint256);\n\n    /**\n     * @notice Returns the address of the underlying asset of this debtToken (E.g. WETH for variableDebtWETH)\n     * @return The address of the underlying asset\n     */\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/dlend/core/misc/AaveOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Errors } from \"../protocol/libraries/helpers/Errors.sol\";\nimport { IACLManager } from \"../interfaces/IACLManager.sol\";\nimport { IPoolAddressesProvider } from \"../interfaces/IPoolAddressesProvider.sol\";\nimport { IPriceOracleGetter } from \"../interfaces/IPriceOracleGetter.sol\";\nimport { IAaveOracle } from \"../interfaces/IAaveOracle.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title AaveOracle\n * @author Aave (modified by dTrinity)\n * @notice Contract to get asset prices from OracleAggregator while maintaining Aave interface compatibility\n * @dev This version acts as a proxy to OracleAggregator, removing the original Chainlink integration\n */\ncontract AaveOracle is IAaveOracle {\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    IPriceOracleGetter private immutable _oracleAggregator;\n    address public immutable override BASE_CURRENCY;\n    uint256 public immutable override BASE_CURRENCY_UNIT;\n\n    // Scaling factor to convert between oracle decimals and target decimals (8)\n    uint256 private immutable SCALING_FACTOR;\n\n    /**\n     * @dev Only asset listing or pool admin can call functions marked by this modifier.\n     */\n    modifier onlyAssetListingOrPoolAdmins() {\n        _onlyAssetListingOrPoolAdmins();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param provider The address of the new PoolAddressesProvider\n     * @param oracleAggregator The address of the OracleAggregator to use\n     */\n    constructor(IPoolAddressesProvider provider, address oracleAggregator) {\n        ADDRESSES_PROVIDER = provider;\n        _oracleAggregator = IPriceOracleGetter(oracleAggregator);\n\n        // Use the base currency from OracleAggregator but standardize to 8 decimals\n        BASE_CURRENCY = _oracleAggregator.BASE_CURRENCY();\n        BASE_CURRENCY_UNIT = 1e8;\n\n        // Calculate scaling factor as ratio between oracle unit and our target unit\n        uint256 oracleUnit = _oracleAggregator.BASE_CURRENCY_UNIT();\n        require(oracleUnit >= BASE_CURRENCY_UNIT, \"AaveOracle: oracle decimals too low\");\n        SCALING_FACTOR = oracleUnit / BASE_CURRENCY_UNIT;\n\n        emit BaseCurrencySet(BASE_CURRENCY, BASE_CURRENCY_UNIT);\n    }\n\n    /// @inheritdoc IAaveOracle\n    function setAssetSources(address[] calldata, address[] calldata) external override onlyAssetListingOrPoolAdmins {\n        // No-op as we don't manage sources directly anymore\n    }\n\n    /// @inheritdoc IAaveOracle\n    function setFallbackOracle(address) external override onlyAssetListingOrPoolAdmins {\n        // No-op as we don't use fallback oracle anymore\n    }\n\n    /// @inheritdoc IPriceOracleGetter\n    function getAssetPrice(address asset) public view override returns (uint256) {\n        uint256 price = _oracleAggregator.getAssetPrice(asset);\n        // Convert from oracle decimals to 8 decimals\n        return price / SCALING_FACTOR;\n    }\n\n    /// @inheritdoc IAaveOracle\n    function getAssetsPrices(address[] calldata assets) external view override returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            prices[i] = getAssetPrice(assets[i]);\n        }\n        return prices;\n    }\n\n    /// @inheritdoc IAaveOracle\n    function getSourceOfAsset(address) external view override returns (address) {\n        return address(_oracleAggregator);\n    }\n\n    /// @inheritdoc IAaveOracle\n    function getFallbackOracle() external view returns (address) {\n        return address(_oracleAggregator);\n    }\n\n    function _onlyAssetListingOrPoolAdmins() internal view {\n        IACLManager aclManager = IACLManager(ADDRESSES_PROVIDER.getACLManager());\n        require(\n            aclManager.isAssetListingAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/misc/AaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20Detailed } from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { ReserveConfiguration } from \"../protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"../protocol/libraries/configuration/UserConfiguration.sol\";\nimport { DataTypes } from \"../protocol/libraries/types/DataTypes.sol\";\nimport { WadRayMath } from \"../protocol/libraries/math/WadRayMath.sol\";\nimport { IPoolAddressesProvider } from \"../interfaces/IPoolAddressesProvider.sol\";\nimport { IStableDebtToken } from \"../interfaces/IStableDebtToken.sol\";\nimport { IVariableDebtToken } from \"../interfaces/IVariableDebtToken.sol\";\nimport { IPool } from \"../interfaces/IPool.sol\";\nimport { IPoolDataProvider } from \"../interfaces/IPoolDataProvider.sol\";\n\n/**\n * @title AaveProtocolDataProvider\n * @author Aave\n * @notice Peripheral contract to collect and pre-process information from the Pool.\n */\ncontract AaveProtocolDataProvider is IPoolDataProvider {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using WadRayMath for uint256;\n\n    address constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @inheritdoc IPoolDataProvider\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    /**\n     * @notice Constructor\n     * @param addressesProvider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider addressesProvider) {\n        ADDRESSES_PROVIDER = addressesProvider;\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getAllReservesTokens() external view override returns (TokenData[] memory) {\n        IPool pool = IPool(ADDRESSES_PROVIDER.getPool());\n        address[] memory reserves = pool.getReservesList();\n        TokenData[] memory reservesTokens = new TokenData[](reserves.length);\n        for (uint256 i = 0; i < reserves.length; i++) {\n            if (reserves[i] == MKR) {\n                reservesTokens[i] = TokenData({ symbol: \"MKR\", tokenAddress: reserves[i] });\n                continue;\n            }\n            if (reserves[i] == ETH) {\n                reservesTokens[i] = TokenData({ symbol: \"ETH\", tokenAddress: reserves[i] });\n                continue;\n            }\n            reservesTokens[i] = TokenData({ symbol: IERC20Detailed(reserves[i]).symbol(), tokenAddress: reserves[i] });\n        }\n        return reservesTokens;\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getAllATokens() external view override returns (TokenData[] memory) {\n        IPool pool = IPool(ADDRESSES_PROVIDER.getPool());\n        address[] memory reserves = pool.getReservesList();\n        TokenData[] memory aTokens = new TokenData[](reserves.length);\n        for (uint256 i = 0; i < reserves.length; i++) {\n            DataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]);\n            aTokens[i] = TokenData({\n                symbol: IERC20Detailed(reserveData.aTokenAddress).symbol(),\n                tokenAddress: reserveData.aTokenAddress\n            });\n        }\n        return aTokens;\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getReserveConfigurationData(\n        address asset\n    )\n        external\n        view\n        override\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        )\n    {\n        DataTypes.ReserveConfigurationMap memory configuration = IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(\n            asset\n        );\n\n        (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor, ) = configuration.getParams();\n\n        (isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled, ) = configuration.getFlags();\n\n        usageAsCollateralEnabled = liquidationThreshold != 0;\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getReserveEModeCategory(address asset) external view override returns (uint256) {\n        DataTypes.ReserveConfigurationMap memory configuration = IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(\n            asset\n        );\n        return configuration.getEModeCategory();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getReserveCaps(address asset) external view override returns (uint256 borrowCap, uint256 supplyCap) {\n        (borrowCap, supplyCap) = IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getCaps();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getPaused(address asset) external view override returns (bool isPaused) {\n        (, , , , isPaused) = IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getFlags();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getSiloedBorrowing(address asset) external view override returns (bool) {\n        return IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getSiloedBorrowing();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getLiquidationProtocolFee(address asset) external view override returns (uint256) {\n        return IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getLiquidationProtocolFee();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getUnbackedMintCap(address asset) external view override returns (uint256) {\n        return IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getUnbackedMintCap();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getDebtCeiling(address asset) external view override returns (uint256) {\n        return IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(asset).getDebtCeiling();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getDebtCeilingDecimals() external pure override returns (uint256) {\n        return ReserveConfiguration.DEBT_CEILING_DECIMALS;\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getReserveData(\n        address asset\n    )\n        external\n        view\n        override\n        returns (\n            uint256 unbacked,\n            uint256 accruedToTreasuryScaled,\n            uint256 totalAToken,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n\n        return (\n            reserve.unbacked,\n            reserve.accruedToTreasury,\n            IERC20Detailed(reserve.aTokenAddress).totalSupply(),\n            IERC20Detailed(reserve.stableDebtTokenAddress).totalSupply(),\n            IERC20Detailed(reserve.variableDebtTokenAddress).totalSupply(),\n            reserve.currentLiquidityRate,\n            reserve.currentVariableBorrowRate,\n            reserve.currentStableBorrowRate,\n            IStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\n            reserve.liquidityIndex,\n            reserve.variableBorrowIndex,\n            reserve.lastUpdateTimestamp\n        );\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getATokenTotalSupply(address asset) external view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n        return IERC20Detailed(reserve.aTokenAddress).totalSupply();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getTotalDebt(address asset) external view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n        return\n            IERC20Detailed(reserve.stableDebtTokenAddress).totalSupply() +\n            IERC20Detailed(reserve.variableDebtTokenAddress).totalSupply();\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getUserReserveData(\n        address asset,\n        address user\n    )\n        external\n        view\n        override\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        )\n    {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n\n        DataTypes.UserConfigurationMap memory userConfig = IPool(ADDRESSES_PROVIDER.getPool()).getUserConfiguration(\n            user\n        );\n\n        currentATokenBalance = IERC20Detailed(reserve.aTokenAddress).balanceOf(user);\n        currentVariableDebt = IERC20Detailed(reserve.variableDebtTokenAddress).balanceOf(user);\n        currentStableDebt = IERC20Detailed(reserve.stableDebtTokenAddress).balanceOf(user);\n        principalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\n        scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n        liquidityRate = reserve.currentLiquidityRate;\n        stableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\n        stableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(user);\n        usageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id);\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getReserveTokensAddresses(\n        address asset\n    )\n        external\n        view\n        override\n        returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress)\n    {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n\n        return (reserve.aTokenAddress, reserve.stableDebtTokenAddress, reserve.variableDebtTokenAddress);\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getInterestRateStrategyAddress(address asset) external view override returns (address irStrategyAddress) {\n        DataTypes.ReserveData memory reserve = IPool(ADDRESSES_PROVIDER.getPool()).getReserveData(asset);\n\n        return (reserve.interestRateStrategyAddress);\n    }\n\n    /// @inheritdoc IPoolDataProvider\n    function getFlashLoanEnabled(address asset) external view override returns (bool) {\n        DataTypes.ReserveConfigurationMap memory configuration = IPool(ADDRESSES_PROVIDER.getPool()).getConfiguration(\n            asset\n        );\n\n        return configuration.getFlashLoanEnabled();\n    }\n}\n"
    },
    "contracts/dlend/core/misc/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/dlend/core/misc/L2Encoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IPool } from \"../interfaces/IPool.sol\";\nimport { DataTypes } from \"../protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title L2Encoder\n * @author Aave\n * @notice Helper contract to encode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\n * only indented to help generate calldata for uses/frontends.\n */\ncontract L2Encoder {\n    using SafeCast for uint256;\n    IPool public immutable POOL;\n\n    /**\n     * @dev Constructor.\n     * @param pool The address of the Pool contract\n     */\n    constructor(IPool pool) {\n        POOL = pool;\n    }\n\n    /**\n     * @notice Encodes supply parameters from standard input to compact representation of 1 bytes32\n     * @dev Without an onBehalfOf parameter as the compact calls to L2Pool will use msg.sender as onBehalfOf\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param referralCode referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @return compact representation of supply parameters\n     */\n    function encodeSupplyParams(address asset, uint256 amount, uint16 referralCode) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount.toUint128();\n        bytes32 res;\n\n        assembly {\n            res := add(assetId, add(shl(16, shortenedAmount), shl(144, referralCode)))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes supplyWithPermit parameters from standard input to compact representation of 3 bytes32\n     * @dev Without an onBehalfOf parameter as the compact calls to L2Pool will use msg.sender as onBehalfOf\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param referralCode referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return compact representation of supplyWithPermit parameters\n     * @return The R parameter of ERC712 permit sig\n     * @return The S parameter of ERC712 permit sig\n     */\n    function encodeSupplyWithPermitParams(\n        address asset,\n        uint256 amount,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external view returns (bytes32, bytes32, bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount.toUint128();\n        uint32 shortenedDeadline = deadline.toUint32();\n\n        bytes32 res;\n        assembly {\n            res := add(\n                assetId,\n                add(\n                    shl(16, shortenedAmount),\n                    add(shl(144, referralCode), add(shl(160, shortenedDeadline), shl(192, permitV)))\n                )\n            )\n        }\n\n        return (res, permitR, permitS);\n    }\n\n    /**\n     * @notice Encodes withdraw parameters from standard input to compact representation of 1 bytes32\n     * @dev Without a to parameter as the compact calls to L2Pool will use msg.sender as to\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     * @return compact representation of withdraw parameters\n     */\n    function encodeWithdrawParams(address asset, uint256 amount) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount == type(uint256).max ? type(uint128).max : amount.toUint128();\n\n        bytes32 res;\n        assembly {\n            res := add(assetId, shl(16, shortenedAmount))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes borrow parameters from standard input to compact representation of 1 bytes32\n     * @dev Without an onBehalfOf parameter as the compact calls to L2Pool will use msg.sender as onBehalfOf\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @return compact representation of withdraw parameters\n     */\n    function encodeBorrowParams(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode\n    ) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount.toUint128();\n        uint8 shortenedInterestRateMode = interestRateMode.toUint8();\n        bytes32 res;\n        assembly {\n            res := add(\n                assetId,\n                add(shl(16, shortenedAmount), add(shl(144, shortenedInterestRateMode), shl(152, referralCode)))\n            )\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes repay parameters from standard input to compact representation of 1 bytes32\n     * @dev Without an onBehalfOf parameter as the compact calls to L2Pool will use msg.sender as onBehalfOf\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `interestRateMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return compact representation of repay parameters\n     */\n    function encodeRepayParams(address asset, uint256 amount, uint256 interestRateMode) public view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount == type(uint256).max ? type(uint128).max : amount.toUint128();\n        uint8 shortenedInterestRateMode = interestRateMode.toUint8();\n\n        bytes32 res;\n        assembly {\n            res := add(assetId, add(shl(16, shortenedAmount), shl(144, shortenedInterestRateMode)))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes repayWithPermit parameters from standard input to compact representation of 3 bytes32\n     * @dev Without an onBehalfOf parameter as the compact calls to L2Pool will use msg.sender as onBehalfOf\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return compact representation of repayWithPermit parameters\n     * @return The R parameter of ERC712 permit sig\n     * @return The S parameter of ERC712 permit sig\n     */\n    function encodeRepayWithPermitParams(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external view returns (bytes32, bytes32, bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n\n        uint16 assetId = data.id;\n        uint128 shortenedAmount = amount == type(uint256).max ? type(uint128).max : amount.toUint128();\n        uint8 shortenedInterestRateMode = interestRateMode.toUint8();\n        uint32 shortenedDeadline = deadline.toUint32();\n\n        bytes32 res;\n        assembly {\n            res := add(\n                assetId,\n                add(\n                    shl(16, shortenedAmount),\n                    add(shl(144, shortenedInterestRateMode), add(shl(152, shortenedDeadline), shl(184, permitV)))\n                )\n            )\n        }\n        return (res, permitR, permitS);\n    }\n\n    /**\n     * @notice Encodes repay with aToken parameters from standard input to compact representation of 1 bytes32\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return compact representation of repay with aToken parameters\n     */\n    function encodeRepayWithATokensParams(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) external view returns (bytes32) {\n        return encodeRepayParams(asset, amount, interestRateMode);\n    }\n\n    /**\n     * @notice Encodes swap borrow rate mode parameters from standard input to compact representation of 1 bytes32\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     * @return compact representation of swap borrow rate mode parameters\n     */\n    function encodeSwapBorrowRateMode(address asset, uint256 interestRateMode) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n        uint16 assetId = data.id;\n        uint8 shortenedInterestRateMode = interestRateMode.toUint8();\n        bytes32 res;\n        assembly {\n            res := add(assetId, shl(16, shortenedInterestRateMode))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes rebalance stable borrow rate parameters from standard input to compact representation of 1 bytes32\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     * @return compact representation of rebalance stable borrow rate parameters\n     */\n    function encodeRebalanceStableBorrowRate(address asset, address user) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n        uint16 assetId = data.id;\n\n        bytes32 res;\n        assembly {\n            res := add(assetId, shl(16, user))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes set user use reserve as collateral parameters from standard input to compact representation of 1 bytes32\n     * @param asset The address of the underlying asset borrowed\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     * @return compact representation of set user use reserve as collateral parameters\n     */\n    function encodeSetUserUseReserveAsCollateral(address asset, bool useAsCollateral) external view returns (bytes32) {\n        DataTypes.ReserveData memory data = POOL.getReserveData(asset);\n        uint16 assetId = data.id;\n        bytes32 res;\n        assembly {\n            res := add(assetId, shl(16, useAsCollateral))\n        }\n        return res;\n    }\n\n    /**\n     * @notice Encodes liquidation call parameters from standard input to compact representation of 2 bytes32\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     * @return First half ot compact representation of liquidation call parameters\n     * @return Second half ot compact representation of liquidation call parameters\n     */\n    function encodeLiquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external view returns (bytes32, bytes32) {\n        DataTypes.ReserveData memory collateralData = POOL.getReserveData(collateralAsset);\n        uint16 collateralAssetId = collateralData.id;\n\n        DataTypes.ReserveData memory debtData = POOL.getReserveData(debtAsset);\n        uint16 debtAssetId = debtData.id;\n\n        uint128 shortenedDebtToCover = debtToCover == type(uint256).max ? type(uint128).max : debtToCover.toUint128();\n\n        bytes32 res1;\n        bytes32 res2;\n\n        assembly {\n            res1 := add(add(collateralAssetId, shl(16, debtAssetId)), shl(32, user))\n            res2 := add(shortenedDebtToCover, shl(128, receiveAToken))\n        }\n        return (res1, res2);\n    }\n}\n"
    },
    "contracts/dlend/core/misc/ZeroReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { DataTypes } from \"../protocol/libraries/types/DataTypes.sol\";\nimport { IDefaultInterestRateStrategy } from \"../interfaces/IDefaultInterestRateStrategy.sol\";\nimport { IReserveInterestRateStrategy } from \"../interfaces/IReserveInterestRateStrategy.sol\";\nimport { IPoolAddressesProvider } from \"../interfaces/IPoolAddressesProvider.sol\";\n\n/**\n * @title ZeroReserveInterestRateStrategy contract\n * @author Aave\n * @notice Interest Rate Strategy contract, with all parameters zeroed.\n * @dev It returns zero liquidity and borrow rate.\n */\ncontract ZeroReserveInterestRateStrategy is IDefaultInterestRateStrategy {\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public constant OPTIMAL_USAGE_RATIO = 0;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public constant OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 0;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public constant MAX_EXCESS_USAGE_RATIO = 0;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public constant MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = 0;\n\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    // Base variable borrow rate when usage rate = 0. Expressed in ray\n    uint256 internal constant _baseVariableBorrowRate = 0;\n\n    // Slope of the variable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal constant _variableRateSlope1 = 0;\n\n    // Slope of the variable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal constant _variableRateSlope2 = 0;\n\n    // Slope of the stable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal constant _stableRateSlope1 = 0;\n\n    // Slope of the stable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal constant _stableRateSlope2 = 0;\n\n    // Premium on top of `_variableRateSlope1` for base stable borrowing rate\n    uint256 internal constant _baseStableRateOffset = 0;\n\n    // Additional premium applied to stable rate when stable debt surpass `OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO`\n    uint256 internal constant _stableRateExcessOffset = 0;\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getVariableRateSlope1() external pure returns (uint256) {\n        return _variableRateSlope1;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getVariableRateSlope2() external pure returns (uint256) {\n        return _variableRateSlope2;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateSlope1() external pure returns (uint256) {\n        return _stableRateSlope1;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateSlope2() external pure returns (uint256) {\n        return _stableRateSlope2;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateExcessOffset() external pure returns (uint256) {\n        return _stableRateExcessOffset;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getBaseStableBorrowRate() public pure returns (uint256) {\n        return _variableRateSlope1 + _baseStableRateOffset;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getBaseVariableBorrowRate() external pure override returns (uint256) {\n        return _baseVariableBorrowRate;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getMaxVariableBorrowRate() external pure override returns (uint256) {\n        return _baseVariableBorrowRate + _variableRateSlope1 + _variableRateSlope2;\n    }\n\n    /// @inheritdoc IReserveInterestRateStrategy\n    function calculateInterestRates(\n        DataTypes.CalculateInterestRatesParams memory\n    ) public pure override returns (uint256, uint256, uint256) {\n        return (0, 0, 0);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/configuration/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { AccessControl } from \"../../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\n\n/**\n * @title ACLManager\n * @author Aave\n * @notice Access Control List Manager. Main registry of system roles and permissions.\n */\ncontract ACLManager is AccessControl, IACLManager {\n    bytes32 public constant override POOL_ADMIN_ROLE = keccak256(\"POOL_ADMIN\");\n    bytes32 public constant override EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN\");\n    bytes32 public constant override RISK_ADMIN_ROLE = keccak256(\"RISK_ADMIN\");\n    bytes32 public constant override FLASH_BORROWER_ROLE = keccak256(\"FLASH_BORROWER\");\n    bytes32 public constant override BRIDGE_ROLE = keccak256(\"BRIDGE\");\n    bytes32 public constant override ASSET_LISTING_ADMIN_ROLE = keccak256(\"ASSET_LISTING_ADMIN\");\n\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    /**\n     * @dev Constructor\n     * @dev The ACL admin should be initialized at the addressesProvider beforehand\n     * @param provider The address of the PoolAddressesProvider\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n        address aclAdmin = provider.getACLAdmin();\n        require(aclAdmin != address(0), Errors.ACL_ADMIN_CANNOT_BE_ZERO);\n        _setupRole(DEFAULT_ADMIN_ROLE, aclAdmin);\n    }\n\n    /// @inheritdoc IACLManager\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /// @inheritdoc IACLManager\n    function addPoolAdmin(address admin) external override {\n        grantRole(POOL_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function removePoolAdmin(address admin) external override {\n        revokeRole(POOL_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function isPoolAdmin(address admin) external view override returns (bool) {\n        return hasRole(POOL_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function addEmergencyAdmin(address admin) external override {\n        grantRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function removeEmergencyAdmin(address admin) external override {\n        revokeRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function isEmergencyAdmin(address admin) external view override returns (bool) {\n        return hasRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function addRiskAdmin(address admin) external override {\n        grantRole(RISK_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function removeRiskAdmin(address admin) external override {\n        revokeRole(RISK_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function isRiskAdmin(address admin) external view override returns (bool) {\n        return hasRole(RISK_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function addFlashBorrower(address borrower) external override {\n        grantRole(FLASH_BORROWER_ROLE, borrower);\n    }\n\n    /// @inheritdoc IACLManager\n    function removeFlashBorrower(address borrower) external override {\n        revokeRole(FLASH_BORROWER_ROLE, borrower);\n    }\n\n    /// @inheritdoc IACLManager\n    function isFlashBorrower(address borrower) external view override returns (bool) {\n        return hasRole(FLASH_BORROWER_ROLE, borrower);\n    }\n\n    /// @inheritdoc IACLManager\n    function addBridge(address bridge) external override {\n        grantRole(BRIDGE_ROLE, bridge);\n    }\n\n    /// @inheritdoc IACLManager\n    function removeBridge(address bridge) external override {\n        revokeRole(BRIDGE_ROLE, bridge);\n    }\n\n    /// @inheritdoc IACLManager\n    function isBridge(address bridge) external view override returns (bool) {\n        return hasRole(BRIDGE_ROLE, bridge);\n    }\n\n    /// @inheritdoc IACLManager\n    function addAssetListingAdmin(address admin) external override {\n        grantRole(ASSET_LISTING_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function removeAssetListingAdmin(address admin) external override {\n        revokeRole(ASSET_LISTING_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IACLManager\n    function isAssetListingAdmin(address admin) external view override returns (bool) {\n        return hasRole(ASSET_LISTING_ADMIN_ROLE, admin);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/configuration/PoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"../../dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { InitializableImmutableAdminUpgradeabilityProxy } from \"../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title PoolAddressesProvider\n * @author Aave\n * @notice Main registry of addresses part of or connected to the protocol, including permissioned roles\n * @dev Acts as factory of proxies and admin of those, so with right to change its implementations\n * @dev Owned by the Aave Governance\n */\ncontract PoolAddressesProvider is Ownable, IPoolAddressesProvider {\n    // Identifier of the Aave Market\n    string private _marketId;\n\n    // Map of registered addresses (identifier => registeredAddress)\n    mapping(bytes32 => address) private _addresses;\n\n    // Main identifiers\n    bytes32 private constant POOL = \"POOL\";\n    bytes32 private constant POOL_CONFIGURATOR = \"POOL_CONFIGURATOR\";\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\n    bytes32 private constant ACL_MANAGER = \"ACL_MANAGER\";\n    bytes32 private constant ACL_ADMIN = \"ACL_ADMIN\";\n    bytes32 private constant PRICE_ORACLE_SENTINEL = \"PRICE_ORACLE_SENTINEL\";\n    bytes32 private constant DATA_PROVIDER = \"DATA_PROVIDER\";\n\n    /**\n     * @dev Constructor.\n     * @param marketId The identifier of the market.\n     * @param owner The owner address of this contract.\n     */\n    constructor(string memory marketId, address owner) {\n        _setMarketId(marketId);\n        transferOwnership(owner);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getMarketId() external view override returns (string memory) {\n        return _marketId;\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setMarketId(string memory newMarketId) external override onlyOwner {\n        _setMarketId(newMarketId);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getAddressFromID(bytes32 id) public view override returns (address) {\n        return _addresses[id];\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setAddress(bytes32 id, address newAddress) external override onlyOwner {\n        address oldAddress = _addresses[id];\n        _addresses[id] = newAddress;\n        emit AddressSet(id, oldAddress, newAddress);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external override onlyOwner {\n        address proxyAddress = _addresses[id];\n        address oldImplementationAddress = _getProxyImplementation(id);\n        _updateImpl(id, newImplementationAddress);\n        emit AddressSetAsProxy(id, proxyAddress, oldImplementationAddress, newImplementationAddress);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getPool() external view override returns (address) {\n        return getAddressFromID(POOL);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setPoolImpl(address newPoolImpl) external override onlyOwner {\n        address oldPoolImpl = _getProxyImplementation(POOL);\n        _updateImpl(POOL, newPoolImpl);\n        emit PoolUpdated(oldPoolImpl, newPoolImpl);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getPoolConfigurator() external view override returns (address) {\n        return getAddressFromID(POOL_CONFIGURATOR);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external override onlyOwner {\n        address oldPoolConfiguratorImpl = _getProxyImplementation(POOL_CONFIGURATOR);\n        _updateImpl(POOL_CONFIGURATOR, newPoolConfiguratorImpl);\n        emit PoolConfiguratorUpdated(oldPoolConfiguratorImpl, newPoolConfiguratorImpl);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getPriceOracle() external view override returns (address) {\n        return getAddressFromID(PRICE_ORACLE);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setPriceOracle(address newPriceOracle) external override onlyOwner {\n        address oldPriceOracle = _addresses[PRICE_ORACLE];\n        _addresses[PRICE_ORACLE] = newPriceOracle;\n        emit PriceOracleUpdated(oldPriceOracle, newPriceOracle);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getACLManager() external view override returns (address) {\n        return getAddressFromID(ACL_MANAGER);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setACLManager(address newAclManager) external override onlyOwner {\n        address oldAclManager = _addresses[ACL_MANAGER];\n        _addresses[ACL_MANAGER] = newAclManager;\n        emit ACLManagerUpdated(oldAclManager, newAclManager);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getACLAdmin() external view override returns (address) {\n        return getAddressFromID(ACL_ADMIN);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setACLAdmin(address newAclAdmin) external override onlyOwner {\n        address oldAclAdmin = _addresses[ACL_ADMIN];\n        _addresses[ACL_ADMIN] = newAclAdmin;\n        emit ACLAdminUpdated(oldAclAdmin, newAclAdmin);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getPriceOracleSentinel() external view override returns (address) {\n        return getAddressFromID(PRICE_ORACLE_SENTINEL);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external override onlyOwner {\n        address oldPriceOracleSentinel = _addresses[PRICE_ORACLE_SENTINEL];\n        _addresses[PRICE_ORACLE_SENTINEL] = newPriceOracleSentinel;\n        emit PriceOracleSentinelUpdated(oldPriceOracleSentinel, newPriceOracleSentinel);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function getPoolDataProvider() external view override returns (address) {\n        return getAddressFromID(DATA_PROVIDER);\n    }\n\n    /// @inheritdoc IPoolAddressesProvider\n    function setPoolDataProvider(address newDataProvider) external override onlyOwner {\n        address oldDataProvider = _addresses[DATA_PROVIDER];\n        _addresses[DATA_PROVIDER] = newDataProvider;\n        emit PoolDataProviderUpdated(oldDataProvider, newDataProvider);\n    }\n\n    /**\n     * @notice Internal function to update the implementation of a specific proxied component of the protocol.\n     * @dev If there is no proxy registered with the given identifier, it creates the proxy setting `newAddress`\n     *   as implementation and calls the initialize() function on the proxy\n     * @dev If there is already a proxy registered, it just updates the implementation to `newAddress` and\n     *   calls the initialize() function via upgradeToAndCall() in the proxy\n     * @param id The id of the proxy to be updated\n     * @param newAddress The address of the new implementation\n     */\n    function _updateImpl(bytes32 id, address newAddress) internal {\n        address proxyAddress = _addresses[id];\n        InitializableImmutableAdminUpgradeabilityProxy proxy;\n        bytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\n\n        if (proxyAddress == address(0)) {\n            proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\n            _addresses[id] = proxyAddress = address(proxy);\n            proxy.initialize(newAddress, params);\n            emit ProxyCreated(id, proxyAddress, newAddress);\n        } else {\n            proxy = InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress));\n            proxy.upgradeToAndCall(newAddress, params);\n        }\n    }\n\n    /**\n     * @notice Updates the identifier of the Aave market.\n     * @param newMarketId The new id of the market\n     */\n    function _setMarketId(string memory newMarketId) internal {\n        string memory oldMarketId = _marketId;\n        _marketId = newMarketId;\n        emit MarketIdSet(oldMarketId, newMarketId);\n    }\n\n    /**\n     * @notice Returns the the implementation contract of the proxy contract by its identifier.\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @dev It reverts if the registered address with the given id is not `InitializableImmutableAdminUpgradeabilityProxy`\n     * @param id The id\n     * @return The address of the implementation contract\n     */\n    function _getProxyImplementation(bytes32 id) internal returns (address) {\n        address proxyAddress = _addresses[id];\n        if (proxyAddress == address(0)) {\n            return address(0);\n        } else {\n            address payable payableProxyAddress = payable(proxyAddress);\n            return InitializableImmutableAdminUpgradeabilityProxy(payableProxyAddress).implementation();\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/configuration/PoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"../../dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { IPoolAddressesProviderRegistry } from \"../../interfaces/IPoolAddressesProviderRegistry.sol\";\n\n/**\n * @title PoolAddressesProviderRegistry\n * @author Aave\n * @notice Main registry of PoolAddressesProvider of Aave markets.\n * @dev Used for indexing purposes of Aave protocol's markets. The id assigned to a PoolAddressesProvider refers to the\n * market it is connected with, for example with `1` for the Aave main market and `2` for the next created.\n */\ncontract PoolAddressesProviderRegistry is Ownable, IPoolAddressesProviderRegistry {\n    // Map of address provider ids (addressesProvider => id)\n    mapping(address => uint256) private _addressesProviderToId;\n    // Map of id to address provider (id => addressesProvider)\n    mapping(uint256 => address) private _idToAddressesProvider;\n    // List of addresses providers\n    address[] private _addressesProvidersList;\n    // Map of address provider list indexes (addressesProvider => indexInList)\n    mapping(address => uint256) private _addressesProvidersIndexes;\n\n    /**\n     * @dev Constructor.\n     * @param owner The owner address of this contract.\n     */\n    constructor(address owner) {\n        transferOwnership(owner);\n    }\n\n    /// @inheritdoc IPoolAddressesProviderRegistry\n    function getAddressesProvidersList() external view override returns (address[] memory) {\n        return _addressesProvidersList;\n    }\n\n    /// @inheritdoc IPoolAddressesProviderRegistry\n    function registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\n        require(id != 0, Errors.INVALID_ADDRESSES_PROVIDER_ID);\n        require(_idToAddressesProvider[id] == address(0), Errors.INVALID_ADDRESSES_PROVIDER_ID);\n        require(_addressesProviderToId[provider] == 0, Errors.ADDRESSES_PROVIDER_ALREADY_ADDED);\n\n        _addressesProviderToId[provider] = id;\n        _idToAddressesProvider[id] = provider;\n\n        _addToAddressesProvidersList(provider);\n        emit AddressesProviderRegistered(provider, id);\n    }\n\n    /// @inheritdoc IPoolAddressesProviderRegistry\n    function unregisterAddressesProvider(address provider) external override onlyOwner {\n        require(_addressesProviderToId[provider] != 0, Errors.ADDRESSES_PROVIDER_NOT_REGISTERED);\n        uint256 oldId = _addressesProviderToId[provider];\n        _idToAddressesProvider[oldId] = address(0);\n        _addressesProviderToId[provider] = 0;\n\n        _removeFromAddressesProvidersList(provider);\n\n        emit AddressesProviderUnregistered(provider, oldId);\n    }\n\n    /// @inheritdoc IPoolAddressesProviderRegistry\n    function getAddressesProviderIdByAddress(address addressesProvider) external view override returns (uint256) {\n        return _addressesProviderToId[addressesProvider];\n    }\n\n    /// @inheritdoc IPoolAddressesProviderRegistry\n    function getAddressesProviderAddressById(uint256 id) external view override returns (address) {\n        return _idToAddressesProvider[id];\n    }\n\n    /**\n     * @notice Adds the addresses provider address to the list.\n     * @param provider The address of the PoolAddressesProvider\n     */\n    function _addToAddressesProvidersList(address provider) internal {\n        _addressesProvidersIndexes[provider] = _addressesProvidersList.length;\n        _addressesProvidersList.push(provider);\n    }\n\n    /**\n     * @notice Removes the addresses provider address from the list.\n     * @param provider The address of the PoolAddressesProvider\n     */\n    function _removeFromAddressesProvidersList(address provider) internal {\n        uint256 index = _addressesProvidersIndexes[provider];\n\n        _addressesProvidersIndexes[provider] = 0;\n\n        // Swap the index of the last addresses provider in the list with the index of the provider to remove\n        uint256 lastIndex = _addressesProvidersList.length - 1;\n        if (index < lastIndex) {\n            address lastProvider = _addressesProvidersList[lastIndex];\n            _addressesProvidersList[index] = lastProvider;\n            _addressesProvidersIndexes[lastProvider] = index;\n        }\n        _addressesProvidersList.pop();\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/configuration/PriceOracleSentinel.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPriceOracleSentinel } from \"../../interfaces/IPriceOracleSentinel.sol\";\nimport { ISequencerOracle } from \"../../interfaces/ISequencerOracle.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\n\n/**\n * @title PriceOracleSentinel\n * @author Aave\n * @notice It validates if operations are allowed depending on the PriceOracle health.\n * @dev Once the PriceOracle gets up after an outage/downtime, users can make their positions healthy during a grace\n *  period. So the PriceOracle is considered completely up once its up and the grace period passed.\n */\ncontract PriceOracleSentinel is IPriceOracleSentinel {\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     */\n    modifier onlyPoolAdmin() {\n        IACLManager aclManager = IACLManager(ADDRESSES_PROVIDER.getACLManager());\n        require(aclManager.isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);\n        _;\n    }\n\n    /**\n     * @dev Only risk or pool admin can call functions marked by this modifier.\n     */\n    modifier onlyRiskOrPoolAdmins() {\n        IACLManager aclManager = IACLManager(ADDRESSES_PROVIDER.getACLManager());\n        require(\n            aclManager.isRiskAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_RISK_OR_POOL_ADMIN\n        );\n        _;\n    }\n\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n\n    ISequencerOracle internal _sequencerOracle;\n\n    uint256 internal _gracePeriod;\n\n    /**\n     * @dev Constructor\n     * @param provider The address of the PoolAddressesProvider\n     * @param oracle The address of the SequencerOracle\n     * @param gracePeriod The duration of the grace period in seconds\n     */\n    constructor(IPoolAddressesProvider provider, ISequencerOracle oracle, uint256 gracePeriod) {\n        ADDRESSES_PROVIDER = provider;\n        _sequencerOracle = oracle;\n        _gracePeriod = gracePeriod;\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function isBorrowAllowed() public view override returns (bool) {\n        return _isUpAndGracePeriodPassed();\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function isLiquidationAllowed() public view override returns (bool) {\n        return _isUpAndGracePeriodPassed();\n    }\n\n    /**\n     * @notice Checks the sequencer oracle is healthy: is up and grace period passed.\n     * @return True if the SequencerOracle is up and the grace period passed, false otherwise\n     */\n    function _isUpAndGracePeriodPassed() internal view returns (bool) {\n        (, int256 answer, , uint256 lastUpdateTimestamp, ) = _sequencerOracle.latestRoundData();\n        return answer == 0 && block.timestamp - lastUpdateTimestamp > _gracePeriod;\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function setSequencerOracle(address newSequencerOracle) public onlyPoolAdmin {\n        _sequencerOracle = ISequencerOracle(newSequencerOracle);\n        emit SequencerOracleUpdated(newSequencerOracle);\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function setGracePeriod(uint256 newGracePeriod) public onlyRiskOrPoolAdmins {\n        _gracePeriod = newGracePeriod;\n        emit GracePeriodUpdated(newGracePeriod);\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function getSequencerOracle() public view returns (address) {\n        return address(_sequencerOracle);\n    }\n\n    /// @inheritdoc IPriceOracleSentinel\n    function getGracePeriod() public view returns (uint256) {\n        return _gracePeriod;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { BaseUpgradeabilityProxy } from \"../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @notice This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * @dev The admin role is stored in an immutable, which helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    address internal immutable _admin;\n\n    /**\n     * @dev Constructor.\n     * @param adminAddress The address of the admin\n     */\n    constructor(address adminAddress) {\n        _admin = adminAddress;\n    }\n\n    modifier ifAdmin() {\n        if (msg.sender == _admin) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @notice Return the admin address\n     * @return The address of the proxy admin.\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @notice Return the implementation address\n     * @return The address of the implementation.\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @notice Upgrade the backing implementation of the proxy.\n     * @dev Only the admin can call this function.\n     * @param newImplementation The address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @notice Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * @dev This is useful to initialize the proxied contract.\n     * @param newImplementation The address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @notice Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal virtual override {\n        require(msg.sender != _admin, \"Cannot call fallback function from the proxy admin\");\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { InitializableUpgradeabilityProxy } from \"../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\";\nimport { Proxy } from \"../../../dependencies/openzeppelin/upgradeability/Proxy.sol\";\nimport { BaseImmutableAdminUpgradeabilityProxy } from \"./BaseImmutableAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @author Aave\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n    BaseImmutableAdminUpgradeabilityProxy,\n    InitializableUpgradeabilityProxy\n{\n    /**\n     * @dev Constructor.\n     * @param admin The address of the admin\n     */\n    constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc BaseImmutableAdminUpgradeabilityProxy\n    function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n        BaseImmutableAdminUpgradeabilityProxy._willFallback();\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title VersionedInitializable\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n * @notice Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * @dev WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\nabstract contract VersionedInitializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(\n            initializing || isConstructor() || revision > lastInitializedRevision,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /**\n     * @notice Returns the revision number of the contract\n     * @dev Needs to be defined in the inherited class as a constant.\n     * @return The revision number\n     */\n    function getRevision() internal pure virtual returns (uint256);\n\n    /**\n     * @notice Returns true if and only if the function is running in the constructor\n     * @return True if the function is running in the constructor\n     */\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n    uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n    uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n    uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n    uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n    uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n    uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n    uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n    uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n    uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n    uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n    uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n    uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n    uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n    uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n    uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n    uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n    uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n    uint256 internal constant MAX_VALID_LTV = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n    uint256 internal constant MAX_VALID_DECIMALS = 255;\n    uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n    uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n    uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n    uint256 public constant DEBT_CEILING_DECIMALS = 2;\n    uint16 public constant MAX_RESERVES_COUNT = 128;\n\n    /**\n     * @notice Sets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @param ltv The new ltv\n     */\n    function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n        require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n        self.data = (self.data & LTV_MASK) | ltv;\n    }\n\n    /**\n     * @notice Gets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @return The loan to value\n     */\n    function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return self.data & ~LTV_MASK;\n    }\n\n    /**\n     * @notice Sets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @param threshold The new liquidation threshold\n     */\n    function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\n        require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);\n\n        self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation threshold\n     */\n    function getLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @param bonus The new liquidation bonus\n     */\n    function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\n        require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n        self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation bonus\n     */\n    function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @param decimals The decimals\n     */\n    function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\n        require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n        self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @return The decimals of the asset\n     */\n    function getDecimals(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the active state of the reserve\n     * @param self The reserve configuration\n     * @param active The active state\n     */\n    function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n        self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the active state of the reserve\n     * @param self The reserve configuration\n     * @return The active state\n     */\n    function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~ACTIVE_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @param frozen The frozen state\n     */\n    function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n        self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @return The frozen state\n     */\n    function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~FROZEN_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the paused state of the reserve\n     * @param self The reserve configuration\n     * @param paused The paused state\n     */\n    function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {\n        self.data = (self.data & PAUSED_MASK) | (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the paused state of the reserve\n     * @param self The reserve configuration\n     * @return The paused state\n     */\n    function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~PAUSED_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the borrowable in isolation flag for the reserve.\n     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n     * amount will be accumulated in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @param borrowable True if the asset is borrowable\n     */\n    function setBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self, bool borrowable) internal pure {\n        self.data =\n            (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n            (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowable in isolation flag for the reserve.\n     * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n     * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @return The borrowable in isolation flag\n     */\n    function getBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @param siloed True if the asset is siloed\n     */\n    function setSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self, bool siloed) internal pure {\n        self.data =\n            (self.data & SILOED_BORROWING_MASK) |\n            (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @return The siloed borrowing flag\n     */\n    function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~SILOED_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the borrowing needs to be enabled, false otherwise\n     */\n    function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n        self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The borrowing state\n     */\n    function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables stable rate borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n     */\n    function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n        self.data =\n            (self.data & STABLE_BORROWING_MASK) |\n            (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the stable rate borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The stable rate borrowing state\n     */\n    function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @param reserveFactor The reserve factor\n     */\n    function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\n        require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n        self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @return The reserve factor\n     */\n    function getReserveFactor(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @param borrowCap The borrow cap\n     */\n    function setBorrowCap(DataTypes.ReserveConfigurationMap memory self, uint256 borrowCap) internal pure {\n        require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n        self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @return The borrow cap\n     */\n    function getBorrowCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @param supplyCap The supply cap\n     */\n    function setSupplyCap(DataTypes.ReserveConfigurationMap memory self, uint256 supplyCap) internal pure {\n        require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n        self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @return The supply cap\n     */\n    function getSupplyCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the debt ceiling in isolation mode for the asset\n     * @param self The reserve configuration\n     * @param ceiling The maximum debt ceiling for the asset\n     */\n    function setDebtCeiling(DataTypes.ReserveConfigurationMap memory self, uint256 ceiling) internal pure {\n        require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n        self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n     * @param self The reserve configuration\n     * @return The debt ceiling (0 = isolation mode disabled)\n     */\n    function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation protocol fee of the reserve\n     * @param self The reserve configuration\n     * @param liquidationProtocolFee The liquidation protocol fee\n     */\n    function setLiquidationProtocolFee(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 liquidationProtocolFee\n    ) internal pure {\n        require(liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);\n\n        self.data =\n            (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n            (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the liquidation protocol fee\n     * @param self The reserve configuration\n     * @return The liquidation protocol fee\n     */\n    function getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @param unbackedMintCap The unbacked mint cap\n     */\n    function setUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self, uint256 unbackedMintCap) internal pure {\n        require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);\n\n        self.data = (self.data & UNBACKED_MINT_CAP_MASK) | (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @return The unbacked mint cap\n     */\n    function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the eMode asset category\n     * @param self The reserve configuration\n     * @param category The asset category when the user selects the eMode\n     */\n    function setEModeCategory(DataTypes.ReserveConfigurationMap memory self, uint256 category) internal pure {\n        require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);\n\n        self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the eMode asset category\n     * @param self The reserve configuration\n     * @return The eMode category for the asset\n     */\n    function getEModeCategory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n     */\n    function setFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self, bool flashLoanEnabled) internal pure {\n        self.data =\n            (self.data & FLASHLOAN_ENABLED_MASK) |\n            (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @return The flashloanable flag\n     */\n    function getFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n    }\n\n    /**\n     * @notice Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flag representing active\n     * @return The state flag representing frozen\n     * @return The state flag representing borrowing enabled\n     * @return The state flag representing stableRateBorrowing enabled\n     * @return The state flag representing paused\n     */\n    function getFlags(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool, bool, bool, bool, bool) {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~ACTIVE_MASK) != 0,\n            (dataLocal & ~FROZEN_MASK) != 0,\n            (dataLocal & ~BORROWING_MASK) != 0,\n            (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n            (dataLocal & ~PAUSED_MASK) != 0\n        );\n    }\n\n    /**\n     * @notice Gets the configuration parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing ltv\n     * @return The state param representing liquidation threshold\n     * @return The state param representing liquidation bonus\n     * @return The state param representing reserve decimals\n     * @return The state param representing reserve factor\n     * @return The state param representing eMode category\n     */\n    function getParams(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        uint256 dataLocal = self.data;\n\n        return (\n            dataLocal & ~LTV_MASK,\n            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n            (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n            (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n            (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n        );\n    }\n\n    /**\n     * @notice Gets the caps parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing borrow cap\n     * @return The state param representing supply cap.\n     */\n    function getCaps(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256, uint256) {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n            (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/configuration/UserConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ReserveConfiguration } from \"./ReserveConfiguration.sol\";\n\n/**\n * @title UserConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the user configuration\n */\nlibrary UserConfiguration {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    uint256 internal constant BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555;\n    uint256 internal constant COLLATERAL_MASK = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n\n    /**\n     * @notice Sets if the user is borrowing the reserve identified by reserveIndex\n     * @param self The configuration object\n     * @param reserveIndex The index of the reserve in the bitmap\n     * @param borrowing True if the user is borrowing the reserve, false otherwise\n     */\n    function setBorrowing(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex, bool borrowing) internal {\n        unchecked {\n            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n            uint256 bit = 1 << (reserveIndex << 1);\n            if (borrowing) {\n                self.data |= bit;\n            } else {\n                self.data &= ~bit;\n            }\n        }\n    }\n\n    /**\n     * @notice Sets if the user is using as collateral the reserve identified by reserveIndex\n     * @param self The configuration object\n     * @param reserveIndex The index of the reserve in the bitmap\n     * @param usingAsCollateral True if the user is using the reserve as collateral, false otherwise\n     */\n    function setUsingAsCollateral(\n        DataTypes.UserConfigurationMap storage self,\n        uint256 reserveIndex,\n        bool usingAsCollateral\n    ) internal {\n        unchecked {\n            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n            uint256 bit = 1 << ((reserveIndex << 1) + 1);\n            if (usingAsCollateral) {\n                self.data |= bit;\n            } else {\n                self.data &= ~bit;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns if a user has been using the reserve for borrowing or as collateral\n     * @param self The configuration object\n     * @param reserveIndex The index of the reserve in the bitmap\n     * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\n     */\n    function isUsingAsCollateralOrBorrowing(\n        DataTypes.UserConfigurationMap memory self,\n        uint256 reserveIndex\n    ) internal pure returns (bool) {\n        unchecked {\n            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n            return (self.data >> (reserveIndex << 1)) & 3 != 0;\n        }\n    }\n\n    /**\n     * @notice Validate a user has been using the reserve for borrowing\n     * @param self The configuration object\n     * @param reserveIndex The index of the reserve in the bitmap\n     * @return True if the user has been using a reserve for borrowing, false otherwise\n     */\n    function isBorrowing(\n        DataTypes.UserConfigurationMap memory self,\n        uint256 reserveIndex\n    ) internal pure returns (bool) {\n        unchecked {\n            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n            return (self.data >> (reserveIndex << 1)) & 1 != 0;\n        }\n    }\n\n    /**\n     * @notice Validate a user has been using the reserve as collateral\n     * @param self The configuration object\n     * @param reserveIndex The index of the reserve in the bitmap\n     * @return True if the user has been using a reserve as collateral, false otherwise\n     */\n    function isUsingAsCollateral(\n        DataTypes.UserConfigurationMap memory self,\n        uint256 reserveIndex\n    ) internal pure returns (bool) {\n        unchecked {\n            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n            return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;\n        }\n    }\n\n    /**\n     * @notice Checks if a user has been supplying only one reserve as collateral\n     * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0\n     * @param self The configuration object\n     * @return True if the user has been supplying as collateral one reserve, false otherwise\n     */\n    function isUsingAsCollateralOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n        uint256 collateralData = self.data & COLLATERAL_MASK;\n        return collateralData != 0 && (collateralData & (collateralData - 1) == 0);\n    }\n\n    /**\n     * @notice Checks if a user has been supplying any reserve as collateral\n     * @param self The configuration object\n     * @return True if the user has been supplying as collateral any reserve, false otherwise\n     */\n    function isUsingAsCollateralAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n        return self.data & COLLATERAL_MASK != 0;\n    }\n\n    /**\n     * @notice Checks if a user has been borrowing only one asset\n     * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0\n     * @param self The configuration object\n     * @return True if the user has been supplying as collateral one reserve, false otherwise\n     */\n    function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n        uint256 borrowingData = self.data & BORROWING_MASK;\n        return borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0);\n    }\n\n    /**\n     * @notice Checks if a user has been borrowing from any reserve\n     * @param self The configuration object\n     * @return True if the user has been borrowing any reserve, false otherwise\n     */\n    function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n        return self.data & BORROWING_MASK != 0;\n    }\n\n    /**\n     * @notice Checks if a user has not been using any reserve for borrowing or supply\n     * @param self The configuration object\n     * @return True if the user has not been borrowing or supplying any reserve, false otherwise\n     */\n    function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n        return self.data == 0;\n    }\n\n    /**\n     * @notice Returns the Isolation Mode state of the user\n     * @param self The configuration object\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @return True if the user is in isolation mode, false otherwise\n     * @return The address of the only asset used as collateral\n     * @return The debt ceiling of the reserve\n     */\n    function getIsolationModeState(\n        DataTypes.UserConfigurationMap memory self,\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList\n    ) internal view returns (bool, address, uint256) {\n        if (isUsingAsCollateralOne(self)) {\n            uint256 assetId = _getFirstAssetIdByMask(self, COLLATERAL_MASK);\n\n            address assetAddress = reservesList[assetId];\n            uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();\n            if (ceiling != 0) {\n                return (true, assetAddress, ceiling);\n            }\n        }\n        return (false, address(0), 0);\n    }\n\n    /**\n     * @notice Returns the siloed borrowing state for the user\n     * @param self The configuration object\n     * @param reservesData The data of all the reserves\n     * @param reservesList The reserve list\n     * @return True if the user has borrowed a siloed asset, false otherwise\n     * @return The address of the only borrowed asset\n     */\n    function getSiloedBorrowingState(\n        DataTypes.UserConfigurationMap memory self,\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList\n    ) internal view returns (bool, address) {\n        if (isBorrowingOne(self)) {\n            uint256 assetId = _getFirstAssetIdByMask(self, BORROWING_MASK);\n            address assetAddress = reservesList[assetId];\n            if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {\n                return (true, assetAddress);\n            }\n        }\n\n        return (false, address(0));\n    }\n\n    /**\n     * @notice Returns the address of the first asset flagged in the bitmap given the corresponding bitmask\n     * @param self The configuration object\n     * @return The index of the first asset flagged in the bitmap once the corresponding mask is applied\n     */\n    function _getFirstAssetIdByMask(\n        DataTypes.UserConfigurationMap memory self,\n        uint256 mask\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 bitmapData = self.data & mask;\n            uint256 firstAssetPosition = bitmapData & ~(bitmapData - 1);\n            uint256 id;\n\n            while ((firstAssetPosition >>= 2) != 0) {\n                id += 1;\n            }\n            return id;\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n    string public constant CALLER_NOT_POOL_ADMIN = \"1\"; // 'The caller of the function is not a pool admin'\n    string public constant CALLER_NOT_EMERGENCY_ADMIN = \"2\"; // 'The caller of the function is not an emergency admin'\n    string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \"3\"; // 'The caller of the function is not a pool or emergency admin'\n    string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \"4\"; // 'The caller of the function is not a risk or pool admin'\n    string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \"5\"; // 'The caller of the function is not an asset listing or pool admin'\n    string public constant CALLER_NOT_BRIDGE = \"6\"; // 'The caller of the function is not a bridge'\n    string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \"7\"; // 'Pool addresses provider is not registered'\n    string public constant INVALID_ADDRESSES_PROVIDER_ID = \"8\"; // 'Invalid id for the pool addresses provider'\n    string public constant NOT_CONTRACT = \"9\"; // 'Address is not a contract'\n    string public constant CALLER_NOT_POOL_CONFIGURATOR = \"10\"; // 'The caller of the function is not the pool configurator'\n    string public constant CALLER_NOT_ATOKEN = \"11\"; // 'The caller of the function is not an AToken'\n    string public constant INVALID_ADDRESSES_PROVIDER = \"12\"; // 'The address of the pool addresses provider is invalid'\n    string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \"13\"; // 'Invalid return value of the flashloan executor function'\n    string public constant RESERVE_ALREADY_ADDED = \"14\"; // 'Reserve has already been added to reserve list'\n    string public constant NO_MORE_RESERVES_ALLOWED = \"15\"; // 'Maximum amount of reserves in the pool reached'\n    string public constant EMODE_CATEGORY_RESERVED = \"16\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n    string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \"17\"; // 'Invalid eMode category assignment to asset'\n    string public constant RESERVE_LIQUIDITY_NOT_ZERO = \"18\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant FLASHLOAN_PREMIUM_INVALID = \"19\"; // 'Invalid flashloan premium'\n    string public constant INVALID_RESERVE_PARAMS = \"20\"; // 'Invalid risk parameters for the reserve'\n    string public constant INVALID_EMODE_CATEGORY_PARAMS = \"21\"; // 'Invalid risk parameters for the eMode category'\n    string public constant BRIDGE_PROTOCOL_FEE_INVALID = \"22\"; // 'Invalid bridge protocol fee'\n    string public constant CALLER_MUST_BE_POOL = \"23\"; // 'The caller of this function must be a pool'\n    string public constant INVALID_MINT_AMOUNT = \"24\"; // 'Invalid amount to mint'\n    string public constant INVALID_BURN_AMOUNT = \"25\"; // 'Invalid amount to burn'\n    string public constant INVALID_AMOUNT = \"26\"; // 'Amount must be greater than 0'\n    string public constant RESERVE_INACTIVE = \"27\"; // 'Action requires an active reserve'\n    string public constant RESERVE_FROZEN = \"28\"; // 'Action cannot be performed because the reserve is frozen'\n    string public constant RESERVE_PAUSED = \"29\"; // 'Action cannot be performed because the reserve is paused'\n    string public constant BORROWING_NOT_ENABLED = \"30\"; // 'Borrowing is not enabled'\n    string public constant STABLE_BORROWING_NOT_ENABLED = \"31\"; // 'Stable borrowing is not enabled'\n    string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"32\"; // 'User cannot withdraw more than the available balance'\n    string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \"33\"; // 'Invalid interest rate mode selected'\n    string public constant COLLATERAL_BALANCE_IS_ZERO = \"34\"; // 'The collateral balance is 0'\n    string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \"35\"; // 'Health factor is lesser than the liquidation threshold'\n    string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \"36\"; // 'There is not enough collateral to cover a new borrow'\n    string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"37\"; // 'Collateral is (mostly) the same currency that is being borrowed'\n    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"38\"; // 'The requested amount is greater than the max loan size in stable rate mode'\n    string public constant NO_DEBT_OF_SELECTED_TYPE = \"39\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n    string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"40\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\n    string public constant NO_OUTSTANDING_STABLE_DEBT = \"41\"; // 'User does not have outstanding stable rate debt on this reserve'\n    string public constant NO_OUTSTANDING_VARIABLE_DEBT = \"42\"; // 'User does not have outstanding variable rate debt on this reserve'\n    string public constant UNDERLYING_BALANCE_ZERO = \"43\"; // 'The underlying balance needs to be greater than 0'\n    string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"44\"; // 'Interest rate rebalance conditions were not met'\n    string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"45\"; // 'Health factor is not below the threshold'\n    string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \"46\"; // 'The collateral chosen cannot be liquidated'\n    string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"47\"; // 'User did not borrow the specified currency'\n    string public constant INCONSISTENT_FLASHLOAN_PARAMS = \"49\"; // 'Inconsistent flashloan parameters'\n    string public constant BORROW_CAP_EXCEEDED = \"50\"; // 'Borrow cap is exceeded'\n    string public constant SUPPLY_CAP_EXCEEDED = \"51\"; // 'Supply cap is exceeded'\n    string public constant UNBACKED_MINT_CAP_EXCEEDED = \"52\"; // 'Unbacked mint cap is exceeded'\n    string public constant DEBT_CEILING_EXCEEDED = \"53\"; // 'Debt ceiling is exceeded'\n    string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = \"54\"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n    string public constant STABLE_DEBT_NOT_ZERO = \"55\"; // 'Stable debt supply is not zero'\n    string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \"56\"; // 'Variable debt supply is not zero'\n    string public constant LTV_VALIDATION_FAILED = \"57\"; // 'Ltv validation failed'\n    string public constant INCONSISTENT_EMODE_CATEGORY = \"58\"; // 'Inconsistent eMode category'\n    string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \"59\"; // 'Price oracle sentinel validation failed'\n    string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \"60\"; // 'Asset is not borrowable in isolation mode'\n    string public constant RESERVE_ALREADY_INITIALIZED = \"61\"; // 'Reserve has already been initialized'\n    string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = \"62\"; // 'User is in isolation mode or ltv is zero'\n    string public constant INVALID_LTV = \"63\"; // 'Invalid ltv parameter for the reserve'\n    string public constant INVALID_LIQ_THRESHOLD = \"64\"; // 'Invalid liquidity threshold parameter for the reserve'\n    string public constant INVALID_LIQ_BONUS = \"65\"; // 'Invalid liquidity bonus parameter for the reserve'\n    string public constant INVALID_DECIMALS = \"66\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\n    string public constant INVALID_RESERVE_FACTOR = \"67\"; // 'Invalid reserve factor parameter for the reserve'\n    string public constant INVALID_BORROW_CAP = \"68\"; // 'Invalid borrow cap for the reserve'\n    string public constant INVALID_SUPPLY_CAP = \"69\"; // 'Invalid supply cap for the reserve'\n    string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \"70\"; // 'Invalid liquidation protocol fee for the reserve'\n    string public constant INVALID_EMODE_CATEGORY = \"71\"; // 'Invalid eMode category for the reserve'\n    string public constant INVALID_UNBACKED_MINT_CAP = \"72\"; // 'Invalid unbacked mint cap for the reserve'\n    string public constant INVALID_DEBT_CEILING = \"73\"; // 'Invalid debt ceiling for the reserve\n    string public constant INVALID_RESERVE_INDEX = \"74\"; // 'Invalid reserve index'\n    string public constant ACL_ADMIN_CANNOT_BE_ZERO = \"75\"; // 'ACL admin cannot be set to the zero address'\n    string public constant INCONSISTENT_PARAMS_LENGTH = \"76\"; // 'Array parameters that should be equal length are not'\n    string public constant ZERO_ADDRESS_NOT_VALID = \"77\"; // 'Zero address not valid'\n    string public constant INVALID_EXPIRATION = \"78\"; // 'Invalid expiration'\n    string public constant INVALID_SIGNATURE = \"79\"; // 'Invalid signature'\n    string public constant OPERATION_NOT_SUPPORTED = \"80\"; // 'Operation not supported'\n    string public constant DEBT_CEILING_NOT_ZERO = \"81\"; // 'Debt ceiling is not zero'\n    string public constant ASSET_NOT_LISTED = \"82\"; // 'Asset is not listed'\n    string public constant INVALID_OPTIMAL_USAGE_RATIO = \"83\"; // 'Invalid optimal usage ratio'\n    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \"84\"; // 'Invalid optimal stable to total debt ratio'\n    string public constant UNDERLYING_CANNOT_BE_RESCUED = \"85\"; // 'The underlying asset cannot be rescued'\n    string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \"86\"; // 'Reserve has already been added to reserve list'\n    string public constant POOL_ADDRESSES_DO_NOT_MATCH = \"87\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n    string public constant STABLE_BORROWING_ENABLED = \"88\"; // 'Stable borrowing is enabled'\n    string public constant SILOED_BORROWING_VIOLATION = \"89\"; // 'User is trying to borrow multiple assets including a siloed one'\n    string public constant RESERVE_DEBT_NOT_ZERO = \"90\"; // the total debt of the reserve needs to be 0\n    string public constant FLASHLOAN_DISABLED = \"91\"; // FlashLoaning for this asset is disabled\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/helpers/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\n\n/**\n * @title Helpers library\n * @author Aave\n */\nlibrary Helpers {\n    /**\n     * @notice Fetches the user current stable and variable debt balances\n     * @param user The user address\n     * @param reserveCache The reserve cache data object\n     * @return The stable debt balance\n     * @return The variable debt balance\n     */\n    function getUserCurrentDebt(\n        address user,\n        DataTypes.ReserveCache memory reserveCache\n    ) internal view returns (uint256, uint256) {\n        return (\n            IERC20(reserveCache.stableDebtTokenAddress).balanceOf(user),\n            IERC20(reserveCache.variableDebtTokenAddress).balanceOf(user)\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/BorrowLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IStableDebtToken } from \"../../../interfaces/IStableDebtToken.sol\";\nimport { IVariableDebtToken } from \"../../../interfaces/IVariableDebtToken.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { Helpers } from \"../helpers/Helpers.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { IsolationModeLogic } from \"./IsolationModeLogic.sol\";\n\n/**\n * @title BorrowLogic library\n * @author Aave\n * @notice Implements the base logic for all the actions related to borrowing\n */\nlibrary BorrowLogic {\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using GPv2SafeERC20 for IERC20;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeCast for uint256;\n\n    // See `IPool` for descriptions\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n    event SwapBorrowRateMode(\n        address indexed reserve,\n        address indexed user,\n        DataTypes.InterestRateMode interestRateMode\n    );\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @notice Implements the borrow feature. Borrowing allows users that provided collateral to draw liquidity from the\n     * Aave protocol proportionally to their collateralization power. For isolated positions, it also increases the\n     * isolated debt.\n     * @dev  Emits the `Borrow()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the borrow function\n     */\n    function executeBorrow(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteBorrowParams memory params\n    ) public {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        (\n            bool isolationModeActive,\n            address isolationModeCollateralAddress,\n            uint256 isolationModeDebtCeiling\n        ) = userConfig.getIsolationModeState(reservesData, reservesList);\n\n        ValidationLogic.validateBorrow(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            DataTypes.ValidateBorrowParams({\n                reserveCache: reserveCache,\n                userConfig: userConfig,\n                asset: params.asset,\n                userAddress: params.onBehalfOf,\n                amount: params.amount,\n                interestRateMode: params.interestRateMode,\n                maxStableLoanPercent: params.maxStableRateBorrowSizePercent,\n                reservesCount: params.reservesCount,\n                oracle: params.oracle,\n                userEModeCategory: params.userEModeCategory,\n                priceOracleSentinel: params.priceOracleSentinel,\n                isolationModeActive: isolationModeActive,\n                isolationModeCollateralAddress: isolationModeCollateralAddress,\n                isolationModeDebtCeiling: isolationModeDebtCeiling\n            })\n        );\n\n        uint256 currentStableRate = 0;\n        bool isFirstBorrowing = false;\n\n        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n            currentStableRate = reserve.currentStableBorrowRate;\n\n            (\n                isFirstBorrowing,\n                reserveCache.nextTotalStableDebt,\n                reserveCache.nextAvgStableBorrowRate\n            ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(\n                params.user,\n                params.onBehalfOf,\n                params.amount,\n                currentStableRate\n            );\n        } else {\n            (isFirstBorrowing, reserveCache.nextScaledVariableDebt) = IVariableDebtToken(\n                reserveCache.variableDebtTokenAddress\n            ).mint(params.user, params.onBehalfOf, params.amount, reserveCache.nextVariableBorrowIndex);\n        }\n\n        if (isFirstBorrowing) {\n            userConfig.setBorrowing(reserve.id, true);\n        }\n\n        if (isolationModeActive) {\n            uint256 nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress]\n                .isolationModeTotalDebt += (params.amount /\n                10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n                .toUint128();\n            emit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress, nextIsolationModeTotalDebt);\n        }\n\n        reserve.updateInterestRates(reserveCache, params.asset, 0, params.releaseUnderlying ? params.amount : 0);\n\n        if (params.releaseUnderlying) {\n            IAToken(reserveCache.aTokenAddress).transferUnderlyingTo(params.user, params.amount);\n        }\n\n        emit Borrow(\n            params.asset,\n            params.user,\n            params.onBehalfOf,\n            params.amount,\n            params.interestRateMode,\n            params.interestRateMode == DataTypes.InterestRateMode.STABLE\n                ? currentStableRate\n                : reserve.currentVariableBorrowRate,\n            params.referralCode\n        );\n    }\n\n    /**\n     * @notice Implements the repay feature. Repaying transfers the underlying back to the aToken and clears the\n     * equivalent amount of debt for the user by burning the corresponding debt token. For isolated positions, it also\n     * reduces the isolated debt.\n     * @dev  Emits the `Repay()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the repay function\n     * @return The actual amount being repaid\n     */\n    function executeRepay(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteRepayParams memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n        reserve.updateState(reserveCache);\n\n        (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(params.onBehalfOf, reserveCache);\n\n        ValidationLogic.validateRepay(\n            reserveCache,\n            params.amount,\n            params.interestRateMode,\n            params.onBehalfOf,\n            stableDebt,\n            variableDebt\n        );\n\n        uint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n            ? stableDebt\n            : variableDebt;\n\n        // Allows a user to repay with aTokens without leaving dust from interest.\n        if (params.useATokens && params.amount == type(uint256).max) {\n            params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender);\n        }\n\n        if (params.amount < paybackAmount) {\n            paybackAmount = params.amount;\n        }\n\n        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n            (reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n                reserveCache.stableDebtTokenAddress\n            ).burn(params.onBehalfOf, paybackAmount);\n        } else {\n            reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(\n                params.onBehalfOf,\n                paybackAmount,\n                reserveCache.nextVariableBorrowIndex\n            );\n        }\n\n        reserve.updateInterestRates(reserveCache, params.asset, params.useATokens ? 0 : paybackAmount, 0);\n\n        if (stableDebt + variableDebt - paybackAmount == 0) {\n            userConfig.setBorrowing(reserve.id, false);\n        }\n\n        IsolationModeLogic.updateIsolatedDebtIfIsolated(\n            reservesData,\n            reservesList,\n            userConfig,\n            reserveCache,\n            paybackAmount\n        );\n\n        if (params.useATokens) {\n            IAToken(reserveCache.aTokenAddress).burn(\n                msg.sender,\n                reserveCache.aTokenAddress,\n                paybackAmount,\n                reserveCache.nextLiquidityIndex\n            );\n        } else {\n            IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);\n            IAToken(reserveCache.aTokenAddress).handleRepayment(msg.sender, params.onBehalfOf, paybackAmount);\n        }\n\n        emit Repay(params.asset, params.onBehalfOf, msg.sender, paybackAmount, params.useATokens);\n\n        return paybackAmount;\n    }\n\n    /**\n     * @notice Implements the rebalance stable borrow rate feature. In case of liquidity crunches on the protocol, stable\n     * rate borrows might need to be rebalanced to bring back equilibrium between the borrow and supply APYs.\n     * @dev The rules that define if a position can be rebalanced are implemented in `ValidationLogic.validateRebalanceStableBorrowRate()`\n     * @dev Emits the `RebalanceStableBorrowRate()` event\n     * @param reserve The state of the reserve of the asset being repaid\n     * @param asset The asset of the position being rebalanced\n     * @param user The user being rebalanced\n     */\n    function executeRebalanceStableBorrowRate(\n        DataTypes.ReserveData storage reserve,\n        address asset,\n        address user\n    ) external {\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n        reserve.updateState(reserveCache);\n\n        ValidationLogic.validateRebalanceStableBorrowRate(reserve, reserveCache, asset);\n\n        IStableDebtToken stableDebtToken = IStableDebtToken(reserveCache.stableDebtTokenAddress);\n        uint256 stableDebt = IERC20(address(stableDebtToken)).balanceOf(user);\n\n        stableDebtToken.burn(user, stableDebt);\n\n        (, reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = stableDebtToken.mint(\n            user,\n            user,\n            stableDebt,\n            reserve.currentStableBorrowRate\n        );\n\n        reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n        emit RebalanceStableBorrowRate(asset, user);\n    }\n\n    /**\n     * @notice Implements the swap borrow rate feature. Borrowers can swap from variable to stable positions at any time.\n     * @dev Emits the `Swap()` event\n     * @param reserve The of the reserve of the asset being repaid\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param asset The asset of the position being swapped\n     * @param interestRateMode The current interest rate mode of the position being swapped\n     */\n    function executeSwapBorrowRateMode(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        DataTypes.InterestRateMode interestRateMode\n    ) external {\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserveCache);\n\n        ValidationLogic.validateSwapRateMode(\n            reserve,\n            reserveCache,\n            userConfig,\n            stableDebt,\n            variableDebt,\n            interestRateMode\n        );\n\n        if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n            (reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n                reserveCache.stableDebtTokenAddress\n            ).burn(msg.sender, stableDebt);\n\n            (, reserveCache.nextScaledVariableDebt) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(\n                msg.sender,\n                msg.sender,\n                stableDebt,\n                reserveCache.nextVariableBorrowIndex\n            );\n        } else {\n            reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(\n                msg.sender,\n                variableDebt,\n                reserveCache.nextVariableBorrowIndex\n            );\n\n            (, reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n                reserveCache.stableDebtTokenAddress\n            ).mint(msg.sender, msg.sender, variableDebt, reserve.currentStableBorrowRate);\n        }\n\n        reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n        emit SwapBorrowRateMode(asset, msg.sender, interestRateMode);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/BridgeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\n\nlibrary BridgeLogic {\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using SafeCast for uint256;\n    using GPv2SafeERC20 for IERC20;\n\n    // See `IPool` for descriptions\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n    /**\n     * @notice Mint unbacked aTokens to a user and updates the unbacked for the reserve.\n     * @dev Essentially a supply without transferring the underlying.\n     * @dev Emits the `MintUnbacked` event\n     * @dev Emits the `ReserveUsedAsCollateralEnabled` if asset is set as collateral\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param asset The address of the underlying asset to mint aTokens of\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function executeMintUnbacked(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        ValidationLogic.validateSupply(reserveCache, reserve, amount);\n\n        uint256 unbackedMintCap = reserveCache.reserveConfiguration.getUnbackedMintCap();\n        uint256 reserveDecimals = reserveCache.reserveConfiguration.getDecimals();\n\n        uint256 unbacked = reserve.unbacked += amount.toUint128();\n\n        require(unbacked <= unbackedMintCap * (10 ** reserveDecimals), Errors.UNBACKED_MINT_CAP_EXCEEDED);\n\n        reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n        bool isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(\n            msg.sender,\n            onBehalfOf,\n            amount,\n            reserveCache.nextLiquidityIndex\n        );\n\n        if (isFirstSupply) {\n            if (\n                ValidationLogic.validateAutomaticUseAsCollateral(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    reserveCache.reserveConfiguration,\n                    reserveCache.aTokenAddress\n                )\n            ) {\n                userConfig.setUsingAsCollateral(reserve.id, true);\n                emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n            }\n        }\n\n        emit MintUnbacked(asset, msg.sender, onBehalfOf, amount, referralCode);\n    }\n\n    /**\n     * @notice Back the current unbacked with `amount` and pay `fee`.\n     * @dev It is not possible to back more than the existing unbacked amount of the reserve\n     * @dev Emits the `BackUnbacked` event\n     * @param reserve The reserve to back unbacked for\n     * @param asset The address of the underlying asset to repay\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @param protocolFeeBps The fraction of fees in basis points paid to the protocol\n     * @return The backed amount\n     */\n    function executeBackUnbacked(\n        DataTypes.ReserveData storage reserve,\n        address asset,\n        uint256 amount,\n        uint256 fee,\n        uint256 protocolFeeBps\n    ) external returns (uint256) {\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        uint256 backingAmount = (amount < reserve.unbacked) ? amount : reserve.unbacked;\n\n        uint256 feeToProtocol = fee.percentMul(protocolFeeBps);\n        uint256 feeToLP = fee - feeToProtocol;\n        uint256 added = backingAmount + fee;\n\n        reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(\n            IERC20(reserveCache.aTokenAddress).totalSupply() +\n                uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),\n            feeToLP\n        );\n\n        reserve.accruedToTreasury += feeToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128();\n\n        reserve.unbacked -= backingAmount.toUint128();\n        reserve.updateInterestRates(reserveCache, asset, added, 0);\n\n        IERC20(asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, added);\n\n        emit BackUnbacked(asset, msg.sender, backingAmount, fee);\n\n        return backingAmount;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/CalldataLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title CalldataLogic library\n * @author Aave\n * @notice Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\n */\nlibrary CalldataLogic {\n    /**\n     * @notice Decodes compressed supply params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed supply params\n     * @return The address of the underlying reserve\n     * @return The amount to supply\n     * @return The referralCode\n     */\n    function decodeSupplyParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256, uint16) {\n        uint16 assetId;\n        uint256 amount;\n        uint16 referralCode;\n\n        assembly {\n            assetId := and(args, 0xFFFF)\n            amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            referralCode := and(shr(144, args), 0xFFFF)\n        }\n        return (reservesList[assetId], amount, referralCode);\n    }\n\n    /**\n     * @notice Decodes compressed supply params to standard params along with permit params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed supply with permit params\n     * @return The address of the underlying reserve\n     * @return The amount to supply\n     * @return The referralCode\n     * @return The deadline of the permit\n     * @return The V value of the permit signature\n     */\n    function decodeSupplyWithPermitParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256, uint16, uint256, uint8) {\n        uint256 deadline;\n        uint8 permitV;\n\n        assembly {\n            deadline := and(shr(160, args), 0xFFFFFFFF)\n            permitV := and(shr(192, args), 0xFF)\n        }\n        (address asset, uint256 amount, uint16 referralCode) = decodeSupplyParams(reservesList, args);\n\n        return (asset, amount, referralCode, deadline, permitV);\n    }\n\n    /**\n     * @notice Decodes compressed withdraw params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed withdraw params\n     * @return The address of the underlying reserve\n     * @return The amount to withdraw\n     */\n    function decodeWithdrawParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256) {\n        uint16 assetId;\n        uint256 amount;\n        assembly {\n            assetId := and(args, 0xFFFF)\n            amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        if (amount == type(uint128).max) {\n            amount = type(uint256).max;\n        }\n        return (reservesList[assetId], amount);\n    }\n\n    /**\n     * @notice Decodes compressed borrow params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed borrow params\n     * @return The address of the underlying reserve\n     * @return The amount to borrow\n     * @return The interestRateMode, 1 for stable or 2 for variable debt\n     * @return The referralCode\n     */\n    function decodeBorrowParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256, uint256, uint16) {\n        uint16 assetId;\n        uint256 amount;\n        uint256 interestRateMode;\n        uint16 referralCode;\n\n        assembly {\n            assetId := and(args, 0xFFFF)\n            amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            interestRateMode := and(shr(144, args), 0xFF)\n            referralCode := and(shr(152, args), 0xFFFF)\n        }\n\n        return (reservesList[assetId], amount, interestRateMode, referralCode);\n    }\n\n    /**\n     * @notice Decodes compressed repay params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed repay params\n     * @return The address of the underlying reserve\n     * @return The amount to repay\n     * @return The interestRateMode, 1 for stable or 2 for variable debt\n     */\n    function decodeRepayParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256, uint256) {\n        uint16 assetId;\n        uint256 amount;\n        uint256 interestRateMode;\n\n        assembly {\n            assetId := and(args, 0xFFFF)\n            amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            interestRateMode := and(shr(144, args), 0xFF)\n        }\n\n        if (amount == type(uint128).max) {\n            amount = type(uint256).max;\n        }\n\n        return (reservesList[assetId], amount, interestRateMode);\n    }\n\n    /**\n     * @notice Decodes compressed repay params to standard params along with permit params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed repay with permit params\n     * @return The address of the underlying reserve\n     * @return The amount to repay\n     * @return The interestRateMode, 1 for stable or 2 for variable debt\n     * @return The deadline of the permit\n     * @return The V value of the permit signature\n     */\n    function decodeRepayWithPermitParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256, uint256, uint256, uint8) {\n        uint256 deadline;\n        uint8 permitV;\n\n        (address asset, uint256 amount, uint256 interestRateMode) = decodeRepayParams(reservesList, args);\n\n        assembly {\n            deadline := and(shr(152, args), 0xFFFFFFFF)\n            permitV := and(shr(184, args), 0xFF)\n        }\n\n        return (asset, amount, interestRateMode, deadline, permitV);\n    }\n\n    /**\n     * @notice Decodes compressed swap borrow rate mode params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed swap borrow rate mode params\n     * @return The address of the underlying reserve\n     * @return The interest rate mode, 1 for stable 2 for variable debt\n     */\n    function decodeSwapBorrowRateModeParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, uint256) {\n        uint16 assetId;\n        uint256 interestRateMode;\n\n        assembly {\n            assetId := and(args, 0xFFFF)\n            interestRateMode := and(shr(16, args), 0xFF)\n        }\n\n        return (reservesList[assetId], interestRateMode);\n    }\n\n    /**\n     * @notice Decodes compressed rebalance stable borrow rate params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed rabalance stable borrow rate params\n     * @return The address of the underlying reserve\n     * @return The address of the user to rebalance\n     */\n    function decodeRebalanceStableBorrowRateParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, address) {\n        uint16 assetId;\n        address user;\n        assembly {\n            assetId := and(args, 0xFFFF)\n            user := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        return (reservesList[assetId], user);\n    }\n\n    /**\n     * @notice Decodes compressed set user use reserve as collateral params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args The packed set user use reserve as collateral params\n     * @return The address of the underlying reserve\n     * @return True if to set using as collateral, false otherwise\n     */\n    function decodeSetUserUseReserveAsCollateralParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args\n    ) internal view returns (address, bool) {\n        uint16 assetId;\n        bool useAsCollateral;\n        assembly {\n            assetId := and(args, 0xFFFF)\n            useAsCollateral := and(shr(16, args), 0x1)\n        }\n        return (reservesList[assetId], useAsCollateral);\n    }\n\n    /**\n     * @notice Decodes compressed liquidation call params to standard params\n     * @param reservesList The addresses of all the active reserves\n     * @param args1 The first half of packed liquidation call params\n     * @param args2 The second half of the packed liquidation call params\n     * @return The address of the underlying collateral asset\n     * @return The address of the underlying debt asset\n     * @return The address of the user to liquidate\n     * @return The amount of debt to cover\n     * @return True if receiving aTokens, false otherwise\n     */\n    function decodeLiquidationCallParams(\n        mapping(uint256 => address) storage reservesList,\n        bytes32 args1,\n        bytes32 args2\n    ) internal view returns (address, address, address, uint256, bool) {\n        uint16 collateralAssetId;\n        uint16 debtAssetId;\n        address user;\n        uint256 debtToCover;\n        bool receiveAToken;\n\n        assembly {\n            collateralAssetId := and(args1, 0xFFFF)\n            debtAssetId := and(shr(16, args1), 0xFFFF)\n            user := and(shr(32, args1), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n\n            debtToCover := and(args2, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            receiveAToken := and(shr(128, args2), 0x1)\n        }\n\n        if (debtToCover == type(uint128).max) {\n            debtToCover = type(uint256).max;\n        }\n\n        return (reservesList[collateralAssetId], reservesList[debtAssetId], user, debtToCover, receiveAToken);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/ConfiguratorLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPool } from \"../../../interfaces/IPool.sol\";\nimport { IInitializableAToken } from \"../../../interfaces/IInitializableAToken.sol\";\nimport { IInitializableDebtToken } from \"../../../interfaces/IInitializableDebtToken.sol\";\nimport { InitializableImmutableAdminUpgradeabilityProxy } from \"../aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ConfiguratorInputTypes } from \"../types/ConfiguratorInputTypes.sol\";\n\n/**\n * @title ConfiguratorLogic library\n * @author Aave\n * @notice Implements the functions to initialize reserves and update aTokens and debtTokens\n */\nlibrary ConfiguratorLogic {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    // See `IPoolConfigurator` for descriptions\n    event ReserveInitialized(\n        address indexed asset,\n        address indexed aToken,\n        address stableDebtToken,\n        address variableDebtToken,\n        address interestRateStrategyAddress\n    );\n    event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n    event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n    /**\n     * @notice Initialize a reserve by creating and initializing aToken, stable debt token and variable debt token\n     * @dev Emits the `ReserveInitialized` event\n     * @param pool The Pool in which the reserve will be initialized\n     * @param input The needed parameters for the initialization\n     */\n    function executeInitReserve(IPool pool, ConfiguratorInputTypes.InitReserveInput calldata input) public {\n        address aTokenProxyAddress = _initTokenWithProxy(\n            input.aTokenImpl,\n            abi.encodeWithSelector(\n                IInitializableAToken.initialize.selector,\n                pool,\n                input.treasury,\n                input.underlyingAsset,\n                input.incentivesController,\n                input.underlyingAssetDecimals,\n                input.aTokenName,\n                input.aTokenSymbol,\n                input.params\n            )\n        );\n\n        address stableDebtTokenProxyAddress = _initTokenWithProxy(\n            input.stableDebtTokenImpl,\n            abi.encodeWithSelector(\n                IInitializableDebtToken.initialize.selector,\n                pool,\n                input.underlyingAsset,\n                input.incentivesController,\n                input.underlyingAssetDecimals,\n                input.stableDebtTokenName,\n                input.stableDebtTokenSymbol,\n                input.params\n            )\n        );\n\n        address variableDebtTokenProxyAddress = _initTokenWithProxy(\n            input.variableDebtTokenImpl,\n            abi.encodeWithSelector(\n                IInitializableDebtToken.initialize.selector,\n                pool,\n                input.underlyingAsset,\n                input.incentivesController,\n                input.underlyingAssetDecimals,\n                input.variableDebtTokenName,\n                input.variableDebtTokenSymbol,\n                input.params\n            )\n        );\n\n        pool.initReserve(\n            input.underlyingAsset,\n            aTokenProxyAddress,\n            stableDebtTokenProxyAddress,\n            variableDebtTokenProxyAddress,\n            input.interestRateStrategyAddress\n        );\n\n        DataTypes.ReserveConfigurationMap memory currentConfig = DataTypes.ReserveConfigurationMap(0);\n\n        currentConfig.setDecimals(input.underlyingAssetDecimals);\n\n        currentConfig.setActive(true);\n        currentConfig.setPaused(false);\n        currentConfig.setFrozen(false);\n\n        pool.setConfiguration(input.underlyingAsset, currentConfig);\n\n        emit ReserveInitialized(\n            input.underlyingAsset,\n            aTokenProxyAddress,\n            stableDebtTokenProxyAddress,\n            variableDebtTokenProxyAddress,\n            input.interestRateStrategyAddress\n        );\n    }\n\n    /**\n     * @notice Updates the aToken implementation and initializes it\n     * @dev Emits the `ATokenUpgraded` event\n     * @param cachedPool The Pool containing the reserve with the aToken\n     * @param input The parameters needed for the initialize call\n     */\n    function executeUpdateAToken(IPool cachedPool, ConfiguratorInputTypes.UpdateATokenInput calldata input) public {\n        DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n        (, , , uint256 decimals, , ) = cachedPool.getConfiguration(input.asset).getParams();\n\n        bytes memory encodedCall = abi.encodeWithSelector(\n            IInitializableAToken.initialize.selector,\n            cachedPool,\n            input.treasury,\n            input.asset,\n            input.incentivesController,\n            decimals,\n            input.name,\n            input.symbol,\n            input.params\n        );\n\n        _upgradeTokenImplementation(reserveData.aTokenAddress, input.implementation, encodedCall);\n\n        emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);\n    }\n\n    /**\n     * @notice Updates the stable debt token implementation and initializes it\n     * @dev Emits the `StableDebtTokenUpgraded` event\n     * @param cachedPool The Pool containing the reserve with the stable debt token\n     * @param input The parameters needed for the initialize call\n     */\n    function executeUpdateStableDebtToken(\n        IPool cachedPool,\n        ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n    ) public {\n        DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n        (, , , uint256 decimals, , ) = cachedPool.getConfiguration(input.asset).getParams();\n\n        bytes memory encodedCall = abi.encodeWithSelector(\n            IInitializableDebtToken.initialize.selector,\n            cachedPool,\n            input.asset,\n            input.incentivesController,\n            decimals,\n            input.name,\n            input.symbol,\n            input.params\n        );\n\n        _upgradeTokenImplementation(reserveData.stableDebtTokenAddress, input.implementation, encodedCall);\n\n        emit StableDebtTokenUpgraded(input.asset, reserveData.stableDebtTokenAddress, input.implementation);\n    }\n\n    /**\n     * @notice Updates the variable debt token implementation and initializes it\n     * @dev Emits the `VariableDebtTokenUpgraded` event\n     * @param cachedPool The Pool containing the reserve with the variable debt token\n     * @param input The parameters needed for the initialize call\n     */\n    function executeUpdateVariableDebtToken(\n        IPool cachedPool,\n        ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n    ) public {\n        DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n        (, , , uint256 decimals, , ) = cachedPool.getConfiguration(input.asset).getParams();\n\n        bytes memory encodedCall = abi.encodeWithSelector(\n            IInitializableDebtToken.initialize.selector,\n            cachedPool,\n            input.asset,\n            input.incentivesController,\n            decimals,\n            input.name,\n            input.symbol,\n            input.params\n        );\n\n        _upgradeTokenImplementation(reserveData.variableDebtTokenAddress, input.implementation, encodedCall);\n\n        emit VariableDebtTokenUpgraded(input.asset, reserveData.variableDebtTokenAddress, input.implementation);\n    }\n\n    /**\n     * @notice Creates a new proxy and initializes the implementation\n     * @param implementation The address of the implementation\n     * @param initParams The parameters that is passed to the implementation to initialize\n     * @return The address of initialized proxy\n     */\n    function _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) {\n        InitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(\n            address(this)\n        );\n\n        proxy.initialize(implementation, initParams);\n\n        return address(proxy);\n    }\n\n    /**\n     * @notice Upgrades the implementation and makes call to the proxy\n     * @dev The call is used to initialize the new implementation.\n     * @param proxyAddress The address of the proxy\n     * @param implementation The address of the new implementation\n     * @param  initParams The parameters to the call after the upgrade\n     */\n    function _upgradeTokenImplementation(\n        address proxyAddress,\n        address implementation,\n        bytes memory initParams\n    ) internal {\n        InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\n            payable(proxyAddress)\n        );\n\n        proxy.upgradeToAndCall(implementation, initParams);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/EModeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IPriceOracleGetter } from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\n\n/**\n * @title EModeLogic library\n * @author Aave\n * @notice Implements the base logic for all the actions related to the eMode\n */\nlibrary EModeLogic {\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using GPv2SafeERC20 for IERC20;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n\n    // See `IPool` for descriptions\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @notice Updates the user efficiency mode category\n     * @dev Will revert if user is borrowing non-compatible asset or change will drop HF < HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n     * @dev Emits the `UserEModeSet` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param usersEModeCategory The state of all users efficiency mode category\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the setUserEMode function\n     */\n    function executeSetUserEMode(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        mapping(address => uint8) storage usersEModeCategory,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSetUserEModeParams memory params\n    ) external {\n        ValidationLogic.validateSetUserEMode(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            userConfig,\n            params.reservesCount,\n            params.categoryId\n        );\n\n        uint8 prevCategoryId = usersEModeCategory[msg.sender];\n        usersEModeCategory[msg.sender] = params.categoryId;\n\n        if (prevCategoryId != 0) {\n            ValidationLogic.validateHealthFactor(\n                reservesData,\n                reservesList,\n                eModeCategories,\n                userConfig,\n                msg.sender,\n                params.categoryId,\n                params.reservesCount,\n                params.oracle\n            );\n        }\n        emit UserEModeSet(msg.sender, params.categoryId);\n    }\n\n    /**\n     * @notice Gets the eMode configuration and calculates the eMode asset price if a custom oracle is configured\n     * @dev The eMode asset price returned is 0 if no oracle is specified\n     * @param category The user eMode category\n     * @param oracle The price oracle\n     * @return The eMode ltv\n     * @return The eMode liquidation threshold\n     * @return The eMode asset price\n     */\n    function getEModeConfiguration(\n        DataTypes.EModeCategory storage category,\n        IPriceOracleGetter oracle\n    ) internal view returns (uint256, uint256, uint256) {\n        uint256 eModeAssetPrice = 0;\n        address eModePriceSource = category.priceSource;\n\n        if (eModePriceSource != address(0)) {\n            eModeAssetPrice = oracle.getAssetPrice(eModePriceSource);\n        }\n\n        return (category.ltv, category.liquidationThreshold, eModeAssetPrice);\n    }\n\n    /**\n     * @notice Checks if eMode is active for a user and if yes, if the asset belongs to the eMode category chosen\n     * @param eModeUserCategory The user eMode category\n     * @param eModeAssetCategory The asset eMode category\n     * @return True if eMode is active and the asset belongs to the eMode category chosen by the user, false otherwise\n     */\n    function isInEModeCategory(uint256 eModeUserCategory, uint256 eModeAssetCategory) internal pure returns (bool) {\n        return (eModeUserCategory != 0 && eModeAssetCategory == eModeUserCategory);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/FlashLoanLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { IFlashLoanReceiver } from \"../../../flashloan/interfaces/IFlashLoanReceiver.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../../flashloan/interfaces/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { BorrowLogic } from \"./BorrowLogic.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\n\n/**\n * @title FlashLoanLogic library\n * @author Aave\n * @notice Implements the logic for the flash loans\n */\nlibrary FlashLoanLogic {\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using GPv2SafeERC20 for IERC20;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using SafeCast for uint256;\n\n    // See `IPool` for descriptions\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    // Helper struct for internal variables used in the `executeFlashLoan` function\n    struct FlashLoanLocalVars {\n        IFlashLoanReceiver receiver;\n        uint256 i;\n        address currentAsset;\n        uint256 currentAmount;\n        uint256[] totalPremiums;\n        uint256 flashloanPremiumTotal;\n        uint256 flashloanPremiumToProtocol;\n    }\n\n    /**\n     * @notice Implements the flashloan feature that allow users to access liquidity of the pool for one transaction\n     * as long as the amount taken plus fee is returned or debt is opened.\n     * @dev For authorized flashborrowers the fee is waived\n     * @dev At the end of the transaction the pool will pull amount borrowed + fee from the receiver,\n     * if the receiver have not approved the pool the transaction will revert.\n     * @dev Emits the `FlashLoan()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the flashloan function\n     */\n    function executeFlashLoan(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.FlashloanParams memory params\n    ) external {\n        // The usual action flow (cache -> updateState -> validation -> changeState -> updateRates)\n        // is altered to (validation -> user payload -> cache -> updateState -> changeState -> updateRates) for flashloans.\n        // This is done to protect against reentrance and rate manipulation within the user specified payload.\n\n        ValidationLogic.validateFlashloan(reservesData, params.assets, params.amounts);\n\n        FlashLoanLocalVars memory vars;\n\n        vars.totalPremiums = new uint256[](params.assets.length);\n\n        vars.receiver = IFlashLoanReceiver(params.receiverAddress);\n        (vars.flashloanPremiumTotal, vars.flashloanPremiumToProtocol) = params.isAuthorizedFlashBorrower\n            ? (0, 0)\n            : (params.flashLoanPremiumTotal, params.flashLoanPremiumToProtocol);\n\n        for (vars.i = 0; vars.i < params.assets.length; vars.i++) {\n            vars.currentAmount = params.amounts[vars.i];\n            vars.totalPremiums[vars.i] = DataTypes.InterestRateMode(params.interestRateModes[vars.i]) ==\n                DataTypes.InterestRateMode.NONE\n                ? vars.currentAmount.percentMul(vars.flashloanPremiumTotal)\n                : 0;\n            IAToken(reservesData[params.assets[vars.i]].aTokenAddress).transferUnderlyingTo(\n                params.receiverAddress,\n                vars.currentAmount\n            );\n        }\n\n        require(\n            vars.receiver.executeOperation(\n                params.assets,\n                params.amounts,\n                vars.totalPremiums,\n                msg.sender,\n                params.params\n            ),\n            Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n        );\n\n        for (vars.i = 0; vars.i < params.assets.length; vars.i++) {\n            vars.currentAsset = params.assets[vars.i];\n            vars.currentAmount = params.amounts[vars.i];\n\n            if (DataTypes.InterestRateMode(params.interestRateModes[vars.i]) == DataTypes.InterestRateMode.NONE) {\n                _handleFlashLoanRepayment(\n                    reservesData[vars.currentAsset],\n                    DataTypes.FlashLoanRepaymentParams({\n                        asset: vars.currentAsset,\n                        receiverAddress: params.receiverAddress,\n                        amount: vars.currentAmount,\n                        totalPremium: vars.totalPremiums[vars.i],\n                        flashLoanPremiumToProtocol: vars.flashloanPremiumToProtocol,\n                        referralCode: params.referralCode\n                    })\n                );\n            } else {\n                // If the user chose to not return the funds, the system checks if there is enough collateral and\n                // eventually opens a debt position\n                BorrowLogic.executeBorrow(\n                    reservesData,\n                    reservesList,\n                    eModeCategories,\n                    userConfig,\n                    DataTypes.ExecuteBorrowParams({\n                        asset: vars.currentAsset,\n                        user: msg.sender,\n                        onBehalfOf: params.onBehalfOf,\n                        amount: vars.currentAmount,\n                        interestRateMode: DataTypes.InterestRateMode(params.interestRateModes[vars.i]),\n                        referralCode: params.referralCode,\n                        releaseUnderlying: false,\n                        maxStableRateBorrowSizePercent: params.maxStableRateBorrowSizePercent,\n                        reservesCount: params.reservesCount,\n                        oracle: IPoolAddressesProvider(params.addressesProvider).getPriceOracle(),\n                        userEModeCategory: params.userEModeCategory,\n                        priceOracleSentinel: IPoolAddressesProvider(params.addressesProvider).getPriceOracleSentinel()\n                    })\n                );\n                // no premium is paid when taking on the flashloan as debt\n                emit FlashLoan(\n                    params.receiverAddress,\n                    msg.sender,\n                    vars.currentAsset,\n                    vars.currentAmount,\n                    DataTypes.InterestRateMode(params.interestRateModes[vars.i]),\n                    0,\n                    params.referralCode\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Implements the simple flashloan feature that allow users to access liquidity of ONE reserve for one\n     * transaction as long as the amount taken plus fee is returned.\n     * @dev Does not waive fee for approved flashborrowers nor allow taking on debt instead of repaying to save gas\n     * @dev At the end of the transaction the pool will pull amount borrowed + fee from the receiver,\n     * if the receiver have not approved the pool the transaction will revert.\n     * @dev Emits the `FlashLoan()` event\n     * @param reserve The state of the flashloaned reserve\n     * @param params The additional parameters needed to execute the simple flashloan function\n     */\n    function executeFlashLoanSimple(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.FlashloanSimpleParams memory params\n    ) external {\n        // The usual action flow (cache -> updateState -> validation -> changeState -> updateRates)\n        // is altered to (validation -> user payload -> cache -> updateState -> changeState -> updateRates) for flashloans.\n        // This is done to protect against reentrance and rate manipulation within the user specified payload.\n\n        ValidationLogic.validateFlashloanSimple(reserve);\n\n        IFlashLoanSimpleReceiver receiver = IFlashLoanSimpleReceiver(params.receiverAddress);\n        uint256 totalPremium = params.amount.percentMul(params.flashLoanPremiumTotal);\n        IAToken(reserve.aTokenAddress).transferUnderlyingTo(params.receiverAddress, params.amount);\n\n        require(\n            receiver.executeOperation(params.asset, params.amount, totalPremium, msg.sender, params.params),\n            Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n        );\n\n        _handleFlashLoanRepayment(\n            reserve,\n            DataTypes.FlashLoanRepaymentParams({\n                asset: params.asset,\n                receiverAddress: params.receiverAddress,\n                amount: params.amount,\n                totalPremium: totalPremium,\n                flashLoanPremiumToProtocol: params.flashLoanPremiumToProtocol,\n                referralCode: params.referralCode\n            })\n        );\n    }\n\n    /**\n     * @notice Handles repayment of flashloaned assets + premium\n     * @dev Will pull the amount + premium from the receiver, so must have approved pool\n     * @param reserve The state of the flashloaned reserve\n     * @param params The additional parameters needed to execute the repayment function\n     */\n    function _handleFlashLoanRepayment(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.FlashLoanRepaymentParams memory params\n    ) internal {\n        uint256 premiumToProtocol = params.totalPremium.percentMul(params.flashLoanPremiumToProtocol);\n        uint256 premiumToLP = params.totalPremium - premiumToProtocol;\n        uint256 amountPlusPremium = params.amount + params.totalPremium;\n\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n        reserve.updateState(reserveCache);\n        reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(\n            IERC20(reserveCache.aTokenAddress).totalSupply() +\n                uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),\n            premiumToLP\n        );\n\n        reserve.accruedToTreasury += premiumToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128();\n\n        reserve.updateInterestRates(reserveCache, params.asset, amountPlusPremium, 0);\n\n        IERC20(params.asset).safeTransferFrom(params.receiverAddress, reserveCache.aTokenAddress, amountPlusPremium);\n\n        IAToken(reserveCache.aTokenAddress).handleRepayment(\n            params.receiverAddress,\n            params.receiverAddress,\n            amountPlusPremium\n        );\n\n        emit FlashLoan(\n            params.receiverAddress,\n            msg.sender,\n            params.asset,\n            params.amount,\n            DataTypes.InterestRateMode(0),\n            params.totalPremium,\n            params.referralCode\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/GenericLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IScaledBalanceToken } from \"../../../interfaces/IScaledBalanceToken.sol\";\nimport { IPriceOracleGetter } from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { EModeLogic } from \"./EModeLogic.sol\";\n\n/**\n * @title GenericLogic library\n * @author Aave\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n    using ReserveLogic for DataTypes.ReserveData;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    struct CalculateUserAccountDataVars {\n        uint256 assetPrice;\n        uint256 assetUnit;\n        uint256 userBalanceInBaseCurrency;\n        uint256 decimals;\n        uint256 ltv;\n        uint256 liquidationThreshold;\n        uint256 i;\n        uint256 healthFactor;\n        uint256 totalCollateralInBaseCurrency;\n        uint256 totalDebtInBaseCurrency;\n        uint256 avgLtv;\n        uint256 avgLiquidationThreshold;\n        uint256 eModeAssetPrice;\n        uint256 eModeLtv;\n        uint256 eModeLiqThreshold;\n        uint256 eModeAssetCategory;\n        address currentReserveAddress;\n        bool hasZeroLtvCollateral;\n        bool isInEModeCategory;\n    }\n\n    /**\n     * @notice Calculates the user data across the reserves.\n     * @dev It includes the total liquidity/collateral/borrow balances in the base currency used by the price feed,\n     * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param params Additional parameters needed for the calculation\n     * @return The total collateral of the user in the base currency used by the price feed\n     * @return The total debt of the user in the base currency used by the price feed\n     * @return The average ltv of the user\n     * @return The average liquidation threshold of the user\n     * @return The health factor of the user\n     * @return True if the ltv is zero, false otherwise\n     */\n    function calculateUserAccountData(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.CalculateUserAccountDataParams memory params\n    ) internal view returns (uint256, uint256, uint256, uint256, uint256, bool) {\n        if (params.userConfig.isEmpty()) {\n            return (0, 0, 0, 0, type(uint256).max, false);\n        }\n\n        CalculateUserAccountDataVars memory vars;\n\n        if (params.userEModeCategory != 0) {\n            (vars.eModeLtv, vars.eModeLiqThreshold, vars.eModeAssetPrice) = EModeLogic.getEModeConfiguration(\n                eModeCategories[params.userEModeCategory],\n                IPriceOracleGetter(params.oracle)\n            );\n        }\n\n        while (vars.i < params.reservesCount) {\n            if (!params.userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n                unchecked {\n                    ++vars.i;\n                }\n                continue;\n            }\n\n            vars.currentReserveAddress = reservesList[vars.i];\n\n            if (vars.currentReserveAddress == address(0)) {\n                unchecked {\n                    ++vars.i;\n                }\n                continue;\n            }\n\n            DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\n\n            (vars.ltv, vars.liquidationThreshold, , vars.decimals, , vars.eModeAssetCategory) = currentReserve\n                .configuration\n                .getParams();\n\n            unchecked {\n                vars.assetUnit = 10 ** vars.decimals;\n            }\n\n            vars.assetPrice = vars.eModeAssetPrice != 0 && params.userEModeCategory == vars.eModeAssetCategory\n                ? vars.eModeAssetPrice\n                : IPriceOracleGetter(params.oracle).getAssetPrice(vars.currentReserveAddress);\n\n            if (vars.liquidationThreshold != 0 && params.userConfig.isUsingAsCollateral(vars.i)) {\n                vars.userBalanceInBaseCurrency = _getUserBalanceInBaseCurrency(\n                    params.user,\n                    currentReserve,\n                    vars.assetPrice,\n                    vars.assetUnit\n                );\n\n                vars.totalCollateralInBaseCurrency += vars.userBalanceInBaseCurrency;\n\n                vars.isInEModeCategory = EModeLogic.isInEModeCategory(\n                    params.userEModeCategory,\n                    vars.eModeAssetCategory\n                );\n\n                if (vars.ltv != 0) {\n                    vars.avgLtv += vars.userBalanceInBaseCurrency * (vars.isInEModeCategory ? vars.eModeLtv : vars.ltv);\n                } else {\n                    vars.hasZeroLtvCollateral = true;\n                }\n\n                vars.avgLiquidationThreshold +=\n                    vars.userBalanceInBaseCurrency *\n                    (vars.isInEModeCategory ? vars.eModeLiqThreshold : vars.liquidationThreshold);\n            }\n\n            if (params.userConfig.isBorrowing(vars.i)) {\n                vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(\n                    params.user,\n                    currentReserve,\n                    vars.assetPrice,\n                    vars.assetUnit\n                );\n            }\n\n            unchecked {\n                ++vars.i;\n            }\n        }\n\n        unchecked {\n            vars.avgLtv = vars.totalCollateralInBaseCurrency != 0\n                ? vars.avgLtv / vars.totalCollateralInBaseCurrency\n                : 0;\n            vars.avgLiquidationThreshold = vars.totalCollateralInBaseCurrency != 0\n                ? vars.avgLiquidationThreshold / vars.totalCollateralInBaseCurrency\n                : 0;\n        }\n\n        vars.healthFactor = (vars.totalDebtInBaseCurrency == 0)\n            ? type(uint256).max\n            : (vars.totalCollateralInBaseCurrency.percentMul(vars.avgLiquidationThreshold)).wadDiv(\n                vars.totalDebtInBaseCurrency\n            );\n        return (\n            vars.totalCollateralInBaseCurrency,\n            vars.totalDebtInBaseCurrency,\n            vars.avgLtv,\n            vars.avgLiquidationThreshold,\n            vars.healthFactor,\n            vars.hasZeroLtvCollateral\n        );\n    }\n\n    /**\n     * @notice Calculates the maximum amount that can be borrowed depending on the available collateral, the total debt\n     * and the average Loan To Value\n     * @param totalCollateralInBaseCurrency The total collateral in the base currency used by the price feed\n     * @param totalDebtInBaseCurrency The total borrow balance in the base currency used by the price feed\n     * @param ltv The average loan to value\n     * @return The amount available to borrow in the base currency of the used by the price feed\n     */\n    function calculateAvailableBorrows(\n        uint256 totalCollateralInBaseCurrency,\n        uint256 totalDebtInBaseCurrency,\n        uint256 ltv\n    ) internal pure returns (uint256) {\n        uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMul(ltv);\n\n        if (availableBorrowsInBaseCurrency < totalDebtInBaseCurrency) {\n            return 0;\n        }\n\n        availableBorrowsInBaseCurrency = availableBorrowsInBaseCurrency - totalDebtInBaseCurrency;\n        return availableBorrowsInBaseCurrency;\n    }\n\n    /**\n     * @notice Calculates total debt of the user in the based currency used to normalize the values of the assets\n     * @dev This fetches the `balanceOf` of the stable and variable debt tokens for the user. For gas reasons, the\n     * variable debt balance is calculated by fetching `scaledBalancesOf` normalized debt, which is cheaper than\n     * fetching `balanceOf`\n     * @param user The address of the user\n     * @param reserve The data of the reserve for which the total debt of the user is being calculated\n     * @param assetPrice The price of the asset for which the total debt of the user is being calculated\n     * @param assetUnit The value representing one full unit of the asset (10^decimals)\n     * @return The total debt of the user normalized to the base currency\n     */\n    function _getUserDebtInBaseCurrency(\n        address user,\n        DataTypes.ReserveData storage reserve,\n        uint256 assetPrice,\n        uint256 assetUnit\n    ) private view returns (uint256) {\n        // fetching variable debt\n        uint256 userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n        if (userTotalDebt != 0) {\n            userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt());\n        }\n\n        userTotalDebt = userTotalDebt + IERC20(reserve.stableDebtTokenAddress).balanceOf(user);\n\n        userTotalDebt = assetPrice * userTotalDebt;\n\n        unchecked {\n            return userTotalDebt / assetUnit;\n        }\n    }\n\n    /**\n     * @notice Calculates total aToken balance of the user in the based currency used by the price oracle\n     * @dev For gas reasons, the aToken balance is calculated by fetching `scaledBalancesOf` normalized debt, which\n     * is cheaper than fetching `balanceOf`\n     * @param user The address of the user\n     * @param reserve The data of the reserve for which the total aToken balance of the user is being calculated\n     * @param assetPrice The price of the asset for which the total aToken balance of the user is being calculated\n     * @param assetUnit The value representing one full unit of the asset (10^decimals)\n     * @return The total aToken balance of the user normalized to the base currency of the price oracle\n     */\n    function _getUserBalanceInBaseCurrency(\n        address user,\n        DataTypes.ReserveData storage reserve,\n        uint256 assetPrice,\n        uint256 assetUnit\n    ) private view returns (uint256) {\n        uint256 normalizedIncome = reserve.getNormalizedIncome();\n        uint256 balance = (IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).rayMul(normalizedIncome)) *\n            assetPrice;\n\n        unchecked {\n            return balance / assetUnit;\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/IsolationModeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\n\n/**\n * @title IsolationModeLogic library\n * @author Aave\n * @notice Implements the base logic for handling repayments for assets borrowed in isolation mode\n */\nlibrary IsolationModeLogic {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using SafeCast for uint256;\n\n    // See `IPool` for descriptions\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @notice updated the isolated debt whenever a position collateralized by an isolated asset is repaid or liquidated\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping\n     * @param reserveCache The cached data of the reserve\n     * @param repayAmount The amount being repaid\n     */\n    function updateIsolatedDebtIfIsolated(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 repayAmount\n    ) internal {\n        (bool isolationModeActive, address isolationModeCollateralAddress, ) = userConfig.getIsolationModeState(\n            reservesData,\n            reservesList\n        );\n\n        if (isolationModeActive) {\n            uint128 isolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt;\n\n            uint128 isolatedDebtRepaid = (repayAmount /\n                10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n                .toUint128();\n\n            // since the debt ceiling does not take into account the interest accrued, it might happen that amount\n            // repaid > debt in isolation mode\n            if (isolationModeTotalDebt <= isolatedDebtRepaid) {\n                reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = 0;\n                emit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress, 0);\n            } else {\n                uint256 nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress]\n                    .isolationModeTotalDebt = isolationModeTotalDebt - isolatedDebtRepaid;\n                emit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress, nextIsolationModeTotalDebt);\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/LiquidationLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts//IERC20.sol\";\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { PercentageMath } from \"../../libraries/math/PercentageMath.sol\";\nimport { WadRayMath } from \"../../libraries/math/WadRayMath.sol\";\nimport { Helpers } from \"../../libraries/helpers/Helpers.sol\";\nimport { DataTypes } from \"../../libraries/types/DataTypes.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { GenericLogic } from \"./GenericLogic.sol\";\nimport { IsolationModeLogic } from \"./IsolationModeLogic.sol\";\nimport { EModeLogic } from \"./EModeLogic.sol\";\nimport { UserConfiguration } from \"../../libraries/configuration/UserConfiguration.sol\";\nimport { ReserveConfiguration } from \"../../libraries/configuration/ReserveConfiguration.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { IStableDebtToken } from \"../../../interfaces/IStableDebtToken.sol\";\nimport { IVariableDebtToken } from \"../../../interfaces/IVariableDebtToken.sol\";\nimport { IPriceOracleGetter } from \"../../../interfaces/IPriceOracleGetter.sol\";\n\n/**\n * @title LiquidationLogic library\n * @author Aave\n * @notice Implements actions involving management of collateral in the protocol, the main one being the liquidations\n */\nlibrary LiquidationLogic {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using GPv2SafeERC20 for IERC20;\n\n    // See `IPool` for descriptions\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Default percentage of borrower's debt to be repaid in a liquidation.\n     * @dev Percentage applied when the users health factor is above `CLOSE_FACTOR_HF_THRESHOLD`\n     * Expressed in bps, a value of 0.5e4 results in 50.00%\n     */\n    uint256 internal constant DEFAULT_LIQUIDATION_CLOSE_FACTOR = 0.5e4;\n\n    /**\n     * @dev Maximum percentage of borrower's debt to be repaid in a liquidation\n     * @dev Percentage applied when the users health factor is below `CLOSE_FACTOR_HF_THRESHOLD`\n     * Expressed in bps, a value of 1e4 results in 100.00%\n     */\n    uint256 public constant MAX_LIQUIDATION_CLOSE_FACTOR = 1e4;\n\n    /**\n     * @dev This constant represents below which health factor value it is possible to liquidate\n     * an amount of debt corresponding to `MAX_LIQUIDATION_CLOSE_FACTOR`.\n     * A value of 0.95e18 results in 0.95\n     */\n    uint256 public constant CLOSE_FACTOR_HF_THRESHOLD = 0.95e18;\n\n    struct LiquidationCallLocalVars {\n        uint256 userCollateralBalance;\n        uint256 userVariableDebt;\n        uint256 userTotalDebt;\n        uint256 actualDebtToLiquidate;\n        uint256 actualCollateralToLiquidate;\n        uint256 liquidationBonus;\n        uint256 healthFactor;\n        uint256 liquidationProtocolFeeAmount;\n        address collateralPriceSource;\n        address debtPriceSource;\n        IAToken collateralAToken;\n        DataTypes.ReserveCache debtReserveCache;\n    }\n\n    /**\n     * @notice Function to liquidate a position if its Health Factor drops below 1. The caller (liquidator)\n     * covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     * a proportional amount of the `collateralAsset` plus a bonus to cover market risk\n     * @dev Emits the `LiquidationCall()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param params The additional parameters needed to execute the liquidation function\n     */\n    function executeLiquidationCall(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.ExecuteLiquidationCallParams memory params\n    ) external {\n        LiquidationCallLocalVars memory vars;\n\n        DataTypes.ReserveData storage collateralReserve = reservesData[params.collateralAsset];\n        DataTypes.ReserveData storage debtReserve = reservesData[params.debtAsset];\n        DataTypes.UserConfigurationMap storage userConfig = usersConfig[params.user];\n        vars.debtReserveCache = debtReserve.cache();\n        debtReserve.updateState(vars.debtReserveCache);\n\n        (, , , , vars.healthFactor, ) = GenericLogic.calculateUserAccountData(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            DataTypes.CalculateUserAccountDataParams({\n                userConfig: userConfig,\n                reservesCount: params.reservesCount,\n                user: params.user,\n                oracle: params.priceOracle,\n                userEModeCategory: params.userEModeCategory\n            })\n        );\n\n        (vars.userVariableDebt, vars.userTotalDebt, vars.actualDebtToLiquidate) = _calculateDebt(\n            vars.debtReserveCache,\n            params,\n            vars.healthFactor\n        );\n\n        ValidationLogic.validateLiquidationCall(\n            userConfig,\n            collateralReserve,\n            DataTypes.ValidateLiquidationCallParams({\n                debtReserveCache: vars.debtReserveCache,\n                totalDebt: vars.userTotalDebt,\n                healthFactor: vars.healthFactor,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n\n        (\n            vars.collateralAToken,\n            vars.collateralPriceSource,\n            vars.debtPriceSource,\n            vars.liquidationBonus\n        ) = _getConfigurationData(eModeCategories, collateralReserve, params);\n\n        vars.userCollateralBalance = vars.collateralAToken.balanceOf(params.user);\n\n        (\n            vars.actualCollateralToLiquidate,\n            vars.actualDebtToLiquidate,\n            vars.liquidationProtocolFeeAmount\n        ) = _calculateAvailableCollateralToLiquidate(\n            collateralReserve,\n            vars.debtReserveCache,\n            vars.collateralPriceSource,\n            vars.debtPriceSource,\n            vars.actualDebtToLiquidate,\n            vars.userCollateralBalance,\n            vars.liquidationBonus,\n            IPriceOracleGetter(params.priceOracle)\n        );\n\n        if (vars.userTotalDebt == vars.actualDebtToLiquidate) {\n            userConfig.setBorrowing(debtReserve.id, false);\n        }\n\n        // If the collateral being liquidated is equal to the user balance,\n        // we set the currency as not being used as collateral anymore\n        if (vars.actualCollateralToLiquidate + vars.liquidationProtocolFeeAmount == vars.userCollateralBalance) {\n            userConfig.setUsingAsCollateral(collateralReserve.id, false);\n            emit ReserveUsedAsCollateralDisabled(params.collateralAsset, params.user);\n        }\n\n        _burnDebtTokens(params, vars);\n\n        debtReserve.updateInterestRates(vars.debtReserveCache, params.debtAsset, vars.actualDebtToLiquidate, 0);\n\n        IsolationModeLogic.updateIsolatedDebtIfIsolated(\n            reservesData,\n            reservesList,\n            userConfig,\n            vars.debtReserveCache,\n            vars.actualDebtToLiquidate\n        );\n\n        if (params.receiveAToken) {\n            _liquidateATokens(reservesData, reservesList, usersConfig, collateralReserve, params, vars);\n        } else {\n            _burnCollateralATokens(collateralReserve, params, vars);\n        }\n\n        // Transfer fee to treasury if it is non-zero\n        if (vars.liquidationProtocolFeeAmount != 0) {\n            uint256 liquidityIndex = collateralReserve.getNormalizedIncome();\n            uint256 scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(liquidityIndex);\n            uint256 scaledDownUserBalance = vars.collateralAToken.scaledBalanceOf(params.user);\n            // To avoid trying to send more aTokens than available on balance, due to 1 wei imprecision\n            if (scaledDownLiquidationProtocolFee > scaledDownUserBalance) {\n                vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex);\n            }\n            vars.collateralAToken.transferOnLiquidation(\n                params.user,\n                vars.collateralAToken.RESERVE_TREASURY_ADDRESS(),\n                vars.liquidationProtocolFeeAmount\n            );\n        }\n\n        // Transfers the debt asset being repaid to the aToken, where the liquidity is kept\n        IERC20(params.debtAsset).safeTransferFrom(\n            msg.sender,\n            vars.debtReserveCache.aTokenAddress,\n            vars.actualDebtToLiquidate\n        );\n\n        IAToken(vars.debtReserveCache.aTokenAddress).handleRepayment(\n            msg.sender,\n            params.user,\n            vars.actualDebtToLiquidate\n        );\n\n        emit LiquidationCall(\n            params.collateralAsset,\n            params.debtAsset,\n            params.user,\n            vars.actualDebtToLiquidate,\n            vars.actualCollateralToLiquidate,\n            msg.sender,\n            params.receiveAToken\n        );\n    }\n\n    /**\n     * @notice Burns the collateral aTokens and transfers the underlying to the liquidator.\n     * @dev   The function also updates the state and the interest rate of the collateral reserve.\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars The executeLiquidationCall() function local vars\n     */\n    function _burnCollateralATokens(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidationCallParams memory params,\n        LiquidationCallLocalVars memory vars\n    ) internal {\n        DataTypes.ReserveCache memory collateralReserveCache = collateralReserve.cache();\n        collateralReserve.updateState(collateralReserveCache);\n        collateralReserve.updateInterestRates(\n            collateralReserveCache,\n            params.collateralAsset,\n            0,\n            vars.actualCollateralToLiquidate\n        );\n\n        // Burn the equivalent amount of aToken, sending the underlying to the liquidator\n        vars.collateralAToken.burn(\n            params.user,\n            msg.sender,\n            vars.actualCollateralToLiquidate,\n            collateralReserveCache.nextLiquidityIndex\n        );\n    }\n\n    /**\n     * @notice Liquidates the user aTokens by transferring them to the liquidator.\n     * @dev   The function also checks the state of the liquidator and activates the aToken as collateral\n     *        as in standard transfers if the isolation mode constraints are respected.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars The executeLiquidationCall() function local vars\n     */\n    function _liquidateATokens(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidationCallParams memory params,\n        LiquidationCallLocalVars memory vars\n    ) internal {\n        uint256 liquidatorPreviousATokenBalance = IERC20(vars.collateralAToken).balanceOf(msg.sender);\n        vars.collateralAToken.transferOnLiquidation(params.user, msg.sender, vars.actualCollateralToLiquidate);\n\n        if (liquidatorPreviousATokenBalance == 0) {\n            DataTypes.UserConfigurationMap storage liquidatorConfig = usersConfig[msg.sender];\n            if (\n                ValidationLogic.validateAutomaticUseAsCollateral(\n                    reservesData,\n                    reservesList,\n                    liquidatorConfig,\n                    collateralReserve.configuration,\n                    collateralReserve.aTokenAddress\n                )\n            ) {\n                liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n                emit ReserveUsedAsCollateralEnabled(params.collateralAsset, msg.sender);\n            }\n        }\n    }\n\n    /**\n     * @notice Burns the debt tokens of the user up to the amount being repaid by the liquidator.\n     * @dev The function alters the `debtReserveCache` state in `vars` to update the debt related data.\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars the executeLiquidationCall() function local vars\n     */\n    function _burnDebtTokens(\n        DataTypes.ExecuteLiquidationCallParams memory params,\n        LiquidationCallLocalVars memory vars\n    ) internal {\n        if (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\n            vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(\n                vars.debtReserveCache.variableDebtTokenAddress\n            ).burn(params.user, vars.actualDebtToLiquidate, vars.debtReserveCache.nextVariableBorrowIndex);\n        } else {\n            // If the user doesn't have variable debt, no need to try to burn variable debt tokens\n            if (vars.userVariableDebt != 0) {\n                vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(\n                    vars.debtReserveCache.variableDebtTokenAddress\n                ).burn(params.user, vars.userVariableDebt, vars.debtReserveCache.nextVariableBorrowIndex);\n            }\n            (\n                vars.debtReserveCache.nextTotalStableDebt,\n                vars.debtReserveCache.nextAvgStableBorrowRate\n            ) = IStableDebtToken(vars.debtReserveCache.stableDebtTokenAddress).burn(\n                params.user,\n                vars.actualDebtToLiquidate - vars.userVariableDebt\n            );\n        }\n    }\n\n    /**\n     * @notice Calculates the total debt of the user and the actual amount to liquidate depending on the health factor\n     * and corresponding close factor.\n     * @dev If the Health Factor is below CLOSE_FACTOR_HF_THRESHOLD, the close factor is increased to MAX_LIQUIDATION_CLOSE_FACTOR\n     * @param debtReserveCache The reserve cache data object of the debt reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param healthFactor The health factor of the position\n     * @return The variable debt of the user\n     * @return The total debt of the user\n     * @return The actual debt to liquidate as a function of the closeFactor\n     */\n    function _calculateDebt(\n        DataTypes.ReserveCache memory debtReserveCache,\n        DataTypes.ExecuteLiquidationCallParams memory params,\n        uint256 healthFactor\n    ) internal view returns (uint256, uint256, uint256) {\n        (uint256 userStableDebt, uint256 userVariableDebt) = Helpers.getUserCurrentDebt(params.user, debtReserveCache);\n\n        uint256 userTotalDebt = userStableDebt + userVariableDebt;\n\n        uint256 closeFactor = healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n            ? DEFAULT_LIQUIDATION_CLOSE_FACTOR\n            : MAX_LIQUIDATION_CLOSE_FACTOR;\n\n        uint256 maxLiquidatableDebt = userTotalDebt.percentMul(closeFactor);\n\n        uint256 actualDebtToLiquidate = params.debtToCover > maxLiquidatableDebt\n            ? maxLiquidatableDebt\n            : params.debtToCover;\n\n        return (userVariableDebt, userTotalDebt, actualDebtToLiquidate);\n    }\n\n    /**\n     * @notice Returns the configuration data for the debt and the collateral reserves.\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @return The collateral aToken\n     * @return The address to use as price source for the collateral\n     * @return The address to use as price source for the debt\n     * @return The liquidation bonus to apply to the collateral\n     */\n    function _getConfigurationData(\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidationCallParams memory params\n    ) internal view returns (IAToken, address, address, uint256) {\n        IAToken collateralAToken = IAToken(collateralReserve.aTokenAddress);\n        uint256 liquidationBonus = collateralReserve.configuration.getLiquidationBonus();\n\n        address collateralPriceSource = params.collateralAsset;\n        address debtPriceSource = params.debtAsset;\n\n        if (params.userEModeCategory != 0) {\n            address eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n\n            if (\n                EModeLogic.isInEModeCategory(\n                    params.userEModeCategory,\n                    collateralReserve.configuration.getEModeCategory()\n                )\n            ) {\n                liquidationBonus = eModeCategories[params.userEModeCategory].liquidationBonus;\n\n                if (eModePriceSource != address(0)) {\n                    collateralPriceSource = eModePriceSource;\n                }\n            }\n\n            // when in eMode, debt will always be in the same eMode category, can skip matching category check\n            if (eModePriceSource != address(0)) {\n                debtPriceSource = eModePriceSource;\n            }\n        }\n\n        return (collateralAToken, collateralPriceSource, debtPriceSource, liquidationBonus);\n    }\n\n    struct AvailableCollateralToLiquidateLocalVars {\n        uint256 collateralPrice;\n        uint256 debtAssetPrice;\n        uint256 maxCollateralToLiquidate;\n        uint256 baseCollateral;\n        uint256 bonusCollateral;\n        uint256 debtAssetDecimals;\n        uint256 collateralDecimals;\n        uint256 collateralAssetUnit;\n        uint256 debtAssetUnit;\n        uint256 collateralAmount;\n        uint256 debtAmountNeeded;\n        uint256 liquidationProtocolFeePercentage;\n        uint256 liquidationProtocolFee;\n    }\n\n    /**\n     * @notice Calculates how much of a specific collateral can be liquidated, given\n     * a certain amount of debt asset.\n     * @dev This function needs to be called after all the checks to validate the liquidation have been performed,\n     *   otherwise it might fail.\n     * @param collateralReserve The data of the collateral reserve\n     * @param debtReserveCache The cached data of the debt reserve\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\n     * @param liquidationBonus The collateral bonus percentage to receive as result of the liquidation\n     * @return The maximum amount that is possible to liquidate given all the liquidation constraints (user balance, close factor)\n     * @return The amount to repay with the liquidation\n     * @return The fee taken from the liquidation bonus amount to be paid to the protocol\n     */\n    function _calculateAvailableCollateralToLiquidate(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ReserveCache memory debtReserveCache,\n        address collateralAsset,\n        address debtAsset,\n        uint256 debtToCover,\n        uint256 userCollateralBalance,\n        uint256 liquidationBonus,\n        IPriceOracleGetter oracle\n    ) internal view returns (uint256, uint256, uint256) {\n        AvailableCollateralToLiquidateLocalVars memory vars;\n\n        vars.collateralPrice = oracle.getAssetPrice(collateralAsset);\n        vars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\n\n        vars.collateralDecimals = collateralReserve.configuration.getDecimals();\n        vars.debtAssetDecimals = debtReserveCache.reserveConfiguration.getDecimals();\n\n        unchecked {\n            vars.collateralAssetUnit = 10 ** vars.collateralDecimals;\n            vars.debtAssetUnit = 10 ** vars.debtAssetDecimals;\n        }\n\n        vars.liquidationProtocolFeePercentage = collateralReserve.configuration.getLiquidationProtocolFee();\n\n        // This is the base collateral to liquidate based on the given debt to cover\n        vars.baseCollateral =\n            ((vars.debtAssetPrice * debtToCover * vars.collateralAssetUnit)) /\n            (vars.collateralPrice * vars.debtAssetUnit);\n\n        vars.maxCollateralToLiquidate = vars.baseCollateral.percentMul(liquidationBonus);\n\n        if (vars.maxCollateralToLiquidate > userCollateralBalance) {\n            vars.collateralAmount = userCollateralBalance;\n            vars.debtAmountNeeded = ((vars.collateralPrice * vars.collateralAmount * vars.debtAssetUnit) /\n                (vars.debtAssetPrice * vars.collateralAssetUnit)).percentDiv(liquidationBonus);\n        } else {\n            vars.collateralAmount = vars.maxCollateralToLiquidate;\n            vars.debtAmountNeeded = debtToCover;\n        }\n\n        if (vars.liquidationProtocolFeePercentage != 0) {\n            vars.bonusCollateral = vars.collateralAmount - vars.collateralAmount.percentDiv(liquidationBonus);\n\n            vars.liquidationProtocolFee = vars.bonusCollateral.percentMul(vars.liquidationProtocolFeePercentage);\n\n            return (\n                vars.collateralAmount - vars.liquidationProtocolFee,\n                vars.debtAmountNeeded,\n                vars.liquidationProtocolFee\n            );\n        } else {\n            return (vars.collateralAmount, vars.debtAmountNeeded, 0);\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/PoolLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { Address } from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { GenericLogic } from \"./GenericLogic.sol\";\n\n/**\n * @title PoolLogic library\n * @author Aave\n * @notice Implements the logic for Pool specific functions\n */\nlibrary PoolLogic {\n    using GPv2SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n    using ReserveLogic for DataTypes.ReserveData;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    // See `IPool` for descriptions\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @notice Initialize an asset reserve and add the reserve to the list of reserves\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param params Additional parameters needed for initiation\n     * @return true if appended, false if inserted at existing empty spot\n     */\n    function executeInitReserve(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.InitReserveParams memory params\n    ) external returns (bool) {\n        require(Address.isContract(params.asset), Errors.NOT_CONTRACT);\n        reservesData[params.asset].init(\n            params.aTokenAddress,\n            params.stableDebtAddress,\n            params.variableDebtAddress,\n            params.interestRateStrategyAddress\n        );\n\n        bool reserveAlreadyAdded = reservesData[params.asset].id != 0 || reservesList[0] == params.asset;\n        require(!reserveAlreadyAdded, Errors.RESERVE_ALREADY_ADDED);\n\n        for (uint16 i = 0; i < params.reservesCount; i++) {\n            if (reservesList[i] == address(0)) {\n                reservesData[params.asset].id = i;\n                reservesList[i] = params.asset;\n                return false;\n            }\n        }\n\n        require(params.reservesCount < params.maxNumberReserves, Errors.NO_MORE_RESERVES_ALLOWED);\n        reservesData[params.asset].id = params.reservesCount;\n        reservesList[params.reservesCount] = params.asset;\n        return true;\n    }\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function executeRescueTokens(address token, address to, uint256 amount) external {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param reservesData The state of all the reserves\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function executeMintToTreasury(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        address[] calldata assets\n    ) external {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address assetAddress = assets[i];\n\n            DataTypes.ReserveData storage reserve = reservesData[assetAddress];\n\n            // this cover both inactive reserves and invalid reserves since the flag will be 0 for both\n            if (!reserve.configuration.getActive()) {\n                continue;\n            }\n\n            uint256 accruedToTreasury = reserve.accruedToTreasury;\n\n            if (accruedToTreasury != 0) {\n                reserve.accruedToTreasury = 0;\n                uint256 normalizedIncome = reserve.getNormalizedIncome();\n                uint256 amountToMint = accruedToTreasury.rayMul(normalizedIncome);\n                IAToken(reserve.aTokenAddress).mintToTreasury(amountToMint, normalizedIncome);\n\n                emit MintedToTreasury(assetAddress, amountToMint);\n            }\n        }\n    }\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param reservesData The state of all the reserves\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function executeResetIsolationModeTotalDebt(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        address asset\n    ) external {\n        require(reservesData[asset].configuration.getDebtCeiling() == 0, Errors.DEBT_CEILING_NOT_ZERO);\n        reservesData[asset].isolationModeTotalDebt = 0;\n        emit IsolationModeTotalDebtUpdated(asset, 0);\n    }\n\n    /**\n     * @notice Drop a reserve\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function executeDropReserve(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        address asset\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        ValidationLogic.validateDropReserve(reservesList, reserve, asset);\n        reservesList[reservesData[asset].id] = address(0);\n        delete reservesData[asset];\n    }\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param params Additional params needed for the calculation\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function executeGetUserAccountData(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.CalculateUserAccountDataParams memory params\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        )\n    {\n        (totalCollateralBase, totalDebtBase, ltv, currentLiquidationThreshold, healthFactor, ) = GenericLogic\n            .calculateUserAccountData(reservesData, reservesList, eModeCategories, params);\n\n        availableBorrowsBase = GenericLogic.calculateAvailableBorrows(totalCollateralBase, totalDebtBase, ltv);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IStableDebtToken } from \"../../../interfaces/IStableDebtToken.sol\";\nimport { IVariableDebtToken } from \"../../../interfaces/IVariableDebtToken.sol\";\nimport { IReserveInterestRateStrategy } from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { MathUtils } from \"../math/MathUtils.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using SafeCast for uint256;\n    using GPv2SafeERC20 for IERC20;\n    using ReserveLogic for DataTypes.ReserveData;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    // See `IPool` for descriptions\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @notice Returns the ongoing normalized income for the reserve.\n     * @dev A value of 1e27 means there is no income. As time passes, the income is accrued\n     * @dev A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n     * @param reserve The reserve object\n     * @return The normalized income, expressed in ray\n     */\n    function getNormalizedIncome(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n        uint40 timestamp = reserve.lastUpdateTimestamp;\n\n        //solium-disable-next-line\n        if (timestamp == block.timestamp) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return reserve.liquidityIndex;\n        } else {\n            return\n                MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n                    reserve.liquidityIndex\n                );\n        }\n    }\n\n    /**\n     * @notice Returns the ongoing normalized variable debt for the reserve.\n     * @dev A value of 1e27 means there is no debt. As time passes, the debt is accrued\n     * @dev A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param reserve The reserve object\n     * @return The normalized variable debt, expressed in ray\n     */\n    function getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n        uint40 timestamp = reserve.lastUpdateTimestamp;\n\n        //solium-disable-next-line\n        if (timestamp == block.timestamp) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return reserve.variableBorrowIndex;\n        } else {\n            return\n                MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\n                    reserve.variableBorrowIndex\n                );\n        }\n    }\n\n    /**\n     * @notice Updates the liquidity cumulative index and the variable borrow index.\n     * @param reserve The reserve object\n     * @param reserveCache The caching layer for the reserve data\n     */\n    function updateState(DataTypes.ReserveData storage reserve, DataTypes.ReserveCache memory reserveCache) internal {\n        // If time didn't pass since last stored timestamp, skip state update\n        //solium-disable-next-line\n        if (reserve.lastUpdateTimestamp == uint40(block.timestamp)) {\n            return;\n        }\n\n        _updateIndexes(reserve, reserveCache);\n        _accrueToTreasury(reserve, reserveCache);\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example\n     * to accumulate the flashloan fee to the reserve, and spread it between all the suppliers.\n     * @param reserve The reserve object\n     * @param totalLiquidity The total liquidity available in the reserve\n     * @param amount The amount to accumulate\n     * @return The next liquidity index of the reserve\n     */\n    function cumulateToLiquidityIndex(\n        DataTypes.ReserveData storage reserve,\n        uint256 totalLiquidity,\n        uint256 amount\n    ) internal returns (uint256) {\n        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`\n        //division `amount / totalLiquidity` done in ray for precision\n        uint256 result = (amount.wadToRay().rayDiv(totalLiquidity.wadToRay()) + WadRayMath.RAY).rayMul(\n            reserve.liquidityIndex\n        );\n        reserve.liquidityIndex = result.toUint128();\n        return result;\n    }\n\n    /**\n     * @notice Initializes a reserve.\n     * @param reserve The reserve object\n     * @param aTokenAddress The address of the overlying atoken contract\n     * @param stableDebtTokenAddress The address of the overlying stable debt token contract\n     * @param variableDebtTokenAddress The address of the overlying variable debt token contract\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function init(\n        DataTypes.ReserveData storage reserve,\n        address aTokenAddress,\n        address stableDebtTokenAddress,\n        address variableDebtTokenAddress,\n        address interestRateStrategyAddress\n    ) internal {\n        require(reserve.aTokenAddress == address(0), Errors.RESERVE_ALREADY_INITIALIZED);\n\n        reserve.liquidityIndex = uint128(WadRayMath.RAY);\n        reserve.variableBorrowIndex = uint128(WadRayMath.RAY);\n        reserve.aTokenAddress = aTokenAddress;\n        reserve.stableDebtTokenAddress = stableDebtTokenAddress;\n        reserve.variableDebtTokenAddress = variableDebtTokenAddress;\n        reserve.interestRateStrategyAddress = interestRateStrategyAddress;\n    }\n\n    struct UpdateInterestRatesLocalVars {\n        uint256 nextLiquidityRate;\n        uint256 nextStableRate;\n        uint256 nextVariableRate;\n        uint256 totalVariableDebt;\n    }\n\n    /**\n     * @notice Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate.\n     * @param reserve The reserve reserve to be updated\n     * @param reserveCache The caching layer for the reserve data\n     * @param reserveAddress The address of the reserve to be updated\n     * @param liquidityAdded The amount of liquidity added to the protocol (supply or repay) in the previous action\n     * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\n     */\n    function updateInterestRates(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.ReserveCache memory reserveCache,\n        address reserveAddress,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken\n    ) internal {\n        UpdateInterestRatesLocalVars memory vars;\n\n        vars.totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex);\n\n        (vars.nextLiquidityRate, vars.nextStableRate, vars.nextVariableRate) = IReserveInterestRateStrategy(\n            reserve.interestRateStrategyAddress\n        ).calculateInterestRates(\n                DataTypes.CalculateInterestRatesParams({\n                    unbacked: reserve.unbacked,\n                    liquidityAdded: liquidityAdded,\n                    liquidityTaken: liquidityTaken,\n                    totalStableDebt: reserveCache.nextTotalStableDebt,\n                    totalVariableDebt: vars.totalVariableDebt,\n                    averageStableBorrowRate: reserveCache.nextAvgStableBorrowRate,\n                    reserveFactor: reserveCache.reserveFactor,\n                    reserve: reserveAddress,\n                    aToken: reserveCache.aTokenAddress\n                })\n            );\n\n        reserve.currentLiquidityRate = vars.nextLiquidityRate.toUint128();\n        reserve.currentStableBorrowRate = vars.nextStableRate.toUint128();\n        reserve.currentVariableBorrowRate = vars.nextVariableRate.toUint128();\n\n        emit ReserveDataUpdated(\n            reserveAddress,\n            vars.nextLiquidityRate,\n            vars.nextStableRate,\n            vars.nextVariableRate,\n            reserveCache.nextLiquidityIndex,\n            reserveCache.nextVariableBorrowIndex\n        );\n    }\n\n    struct AccrueToTreasuryLocalVars {\n        uint256 prevTotalStableDebt;\n        uint256 prevTotalVariableDebt;\n        uint256 currTotalVariableDebt;\n        uint256 cumulatedStableInterest;\n        uint256 totalDebtAccrued;\n        uint256 amountToMint;\n    }\n\n    /**\n     * @notice Mints part of the repaid interest to the reserve treasury as a function of the reserve factor for the\n     * specific asset.\n     * @param reserve The reserve to be updated\n     * @param reserveCache The caching layer for the reserve data\n     */\n    function _accrueToTreasury(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.ReserveCache memory reserveCache\n    ) internal {\n        AccrueToTreasuryLocalVars memory vars;\n\n        if (reserveCache.reserveFactor == 0) {\n            return;\n        }\n\n        //calculate the total variable debt at moment of the last interaction\n        vars.prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.currVariableBorrowIndex);\n\n        //calculate the new total variable debt after accumulation of the interest on the index\n        vars.currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex);\n\n        //calculate the stable debt until the last timestamp update\n        vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n            reserveCache.currAvgStableBorrowRate,\n            reserveCache.stableDebtLastUpdateTimestamp,\n            reserveCache.reserveLastUpdateTimestamp\n        );\n\n        vars.prevTotalStableDebt = reserveCache.currPrincipalStableDebt.rayMul(vars.cumulatedStableInterest);\n\n        //debt accrued is the sum of the current debt minus the sum of the debt at the last update\n        vars.totalDebtAccrued =\n            vars.currTotalVariableDebt +\n            reserveCache.currTotalStableDebt -\n            vars.prevTotalVariableDebt -\n            vars.prevTotalStableDebt;\n\n        vars.amountToMint = vars.totalDebtAccrued.percentMul(reserveCache.reserveFactor);\n\n        if (vars.amountToMint != 0) {\n            reserve.accruedToTreasury += vars.amountToMint.rayDiv(reserveCache.nextLiquidityIndex).toUint128();\n        }\n    }\n\n    /**\n     * @notice Updates the reserve indexes and the timestamp of the update.\n     * @param reserve The reserve reserve to be updated\n     * @param reserveCache The cache layer holding the cached protocol data\n     */\n    function _updateIndexes(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.ReserveCache memory reserveCache\n    ) internal {\n        // Only cumulating on the supply side if there is any income being produced\n        // The case of Reserve Factor 100% is not a problem (currentLiquidityRate == 0),\n        // as liquidity index should not be updated\n        if (reserveCache.currLiquidityRate != 0) {\n            uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(\n                reserveCache.currLiquidityRate,\n                reserveCache.reserveLastUpdateTimestamp\n            );\n            reserveCache.nextLiquidityIndex = cumulatedLiquidityInterest.rayMul(reserveCache.currLiquidityIndex);\n            reserve.liquidityIndex = reserveCache.nextLiquidityIndex.toUint128();\n        }\n\n        // Variable borrow index only gets updated if there is any variable debt.\n        // reserveCache.currVariableBorrowRate != 0 is not a correct validation,\n        // because a positive base variable rate can be stored on\n        // reserveCache.currVariableBorrowRate, but the index should not increase\n        if (reserveCache.currScaledVariableDebt != 0) {\n            uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\n                reserveCache.currVariableBorrowRate,\n                reserveCache.reserveLastUpdateTimestamp\n            );\n            reserveCache.nextVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(\n                reserveCache.currVariableBorrowIndex\n            );\n            reserve.variableBorrowIndex = reserveCache.nextVariableBorrowIndex.toUint128();\n        }\n    }\n\n    /**\n     * @notice Creates a cache object to avoid repeated storage reads and external contract calls when updating state and\n     * interest rates.\n     * @param reserve The reserve object for which the cache will be filled\n     * @return The cache object\n     */\n    function cache(DataTypes.ReserveData storage reserve) internal view returns (DataTypes.ReserveCache memory) {\n        DataTypes.ReserveCache memory reserveCache;\n\n        reserveCache.reserveConfiguration = reserve.configuration;\n        reserveCache.reserveFactor = reserveCache.reserveConfiguration.getReserveFactor();\n        reserveCache.currLiquidityIndex = reserveCache.nextLiquidityIndex = reserve.liquidityIndex;\n        reserveCache.currVariableBorrowIndex = reserveCache.nextVariableBorrowIndex = reserve.variableBorrowIndex;\n        reserveCache.currLiquidityRate = reserve.currentLiquidityRate;\n        reserveCache.currVariableBorrowRate = reserve.currentVariableBorrowRate;\n\n        reserveCache.aTokenAddress = reserve.aTokenAddress;\n        reserveCache.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n        reserveCache.variableDebtTokenAddress = reserve.variableDebtTokenAddress;\n\n        reserveCache.reserveLastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n        reserveCache.currScaledVariableDebt = reserveCache.nextScaledVariableDebt = IVariableDebtToken(\n            reserveCache.variableDebtTokenAddress\n        ).scaledTotalSupply();\n\n        (\n            reserveCache.currPrincipalStableDebt,\n            reserveCache.currTotalStableDebt,\n            reserveCache.currAvgStableBorrowRate,\n            reserveCache.stableDebtLastUpdateTimestamp\n        ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).getSupplyData();\n\n        // by default the actions are considered as not affecting the debt balances.\n        // if the action involves mint/burn of debt, the cache needs to be updated\n        reserveCache.nextTotalStableDebt = reserveCache.currTotalStableDebt;\n        reserveCache.nextAvgStableBorrowRate = reserveCache.currAvgStableBorrowRate;\n\n        return reserveCache;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/SupplyLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { ValidationLogic } from \"./ValidationLogic.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\n\n/**\n * @title SupplyLogic library\n * @author Aave\n * @notice Implements the base logic for supply/withdraw\n */\nlibrary SupplyLogic {\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using GPv2SafeERC20 for IERC20;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n\n    // See `IPool` for descriptions\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @notice Implements the supply feature. Through `supply()`, users supply assets to the Aave protocol.\n     * @dev Emits the `Supply()` event.\n     * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n     * collateral.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the supply function\n     */\n    function executeSupply(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSupplyParams memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        ValidationLogic.validateSupply(reserveCache, reserve, params.amount);\n\n        reserve.updateInterestRates(reserveCache, params.asset, params.amount, 0);\n\n        IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, params.amount);\n\n        bool isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(\n            msg.sender,\n            params.onBehalfOf,\n            params.amount,\n            reserveCache.nextLiquidityIndex\n        );\n\n        if (isFirstSupply) {\n            if (\n                ValidationLogic.validateAutomaticUseAsCollateral(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    reserveCache.reserveConfiguration,\n                    reserveCache.aTokenAddress\n                )\n            ) {\n                userConfig.setUsingAsCollateral(reserve.id, true);\n                emit ReserveUsedAsCollateralEnabled(params.asset, params.onBehalfOf);\n            }\n        }\n\n        emit Supply(params.asset, msg.sender, params.onBehalfOf, params.amount, params.referralCode);\n    }\n\n    /**\n     * @notice Implements the withdraw feature. Through `withdraw()`, users redeem their aTokens for the underlying asset\n     * previously supplied in the Aave protocol.\n     * @dev Emits the `Withdraw()` event.\n     * @dev If the user withdraws everything, `ReserveUsedAsCollateralDisabled()` is emitted.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the withdraw function\n     * @return The actual amount withdrawn\n     */\n    function executeWithdraw(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteWithdrawParams memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        uint256 userBalance = IAToken(reserveCache.aTokenAddress).scaledBalanceOf(msg.sender).rayMul(\n            reserveCache.nextLiquidityIndex\n        );\n\n        uint256 amountToWithdraw = params.amount;\n\n        if (params.amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n\n        ValidationLogic.validateWithdraw(reserveCache, amountToWithdraw, userBalance);\n\n        reserve.updateInterestRates(reserveCache, params.asset, 0, amountToWithdraw);\n\n        bool isCollateral = userConfig.isUsingAsCollateral(reserve.id);\n\n        if (isCollateral && amountToWithdraw == userBalance) {\n            userConfig.setUsingAsCollateral(reserve.id, false);\n            emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);\n        }\n\n        IAToken(reserveCache.aTokenAddress).burn(\n            msg.sender,\n            params.to,\n            amountToWithdraw,\n            reserveCache.nextLiquidityIndex\n        );\n\n        if (isCollateral && userConfig.isBorrowingAny()) {\n            ValidationLogic.validateHFAndLtv(\n                reservesData,\n                reservesList,\n                eModeCategories,\n                userConfig,\n                params.asset,\n                msg.sender,\n                params.reservesCount,\n                params.oracle,\n                params.userEModeCategory\n            );\n        }\n\n        emit Withdraw(params.asset, msg.sender, params.to, amountToWithdraw);\n\n        return amountToWithdraw;\n    }\n\n    /**\n     * @notice Validates a transfer of aTokens. The sender is subjected to health factor validation to avoid\n     * collateralization constraints violation.\n     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event for the `to` account, if the asset is being activated as\n     * collateral.\n     * @dev In case the `from` user transfers everything, `ReserveUsedAsCollateralDisabled()` is emitted for `from`.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the finalizeTransfer function\n     */\n    function executeFinalizeTransfer(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.FinalizeTransferParams memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n\n        ValidationLogic.validateTransfer(reserve);\n\n        uint256 reserveId = reserve.id;\n\n        if (params.from != params.to && params.amount != 0) {\n            DataTypes.UserConfigurationMap storage fromConfig = usersConfig[params.from];\n\n            if (fromConfig.isUsingAsCollateral(reserveId)) {\n                if (fromConfig.isBorrowingAny()) {\n                    ValidationLogic.validateHFAndLtv(\n                        reservesData,\n                        reservesList,\n                        eModeCategories,\n                        usersConfig[params.from],\n                        params.asset,\n                        params.from,\n                        params.reservesCount,\n                        params.oracle,\n                        params.fromEModeCategory\n                    );\n                }\n                if (params.balanceFromBefore == params.amount) {\n                    fromConfig.setUsingAsCollateral(reserveId, false);\n                    emit ReserveUsedAsCollateralDisabled(params.asset, params.from);\n                }\n            }\n\n            if (params.balanceToBefore == 0) {\n                DataTypes.UserConfigurationMap storage toConfig = usersConfig[params.to];\n                if (\n                    ValidationLogic.validateAutomaticUseAsCollateral(\n                        reservesData,\n                        reservesList,\n                        toConfig,\n                        reserve.configuration,\n                        reserve.aTokenAddress\n                    )\n                ) {\n                    toConfig.setUsingAsCollateral(reserveId, true);\n                    emit ReserveUsedAsCollateralEnabled(params.asset, params.to);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Executes the 'set as collateral' feature. A user can choose to activate or deactivate an asset as\n     * collateral at any point in time. Deactivating an asset as collateral is subjected to the usual health factor\n     * checks to ensure collateralization.\n     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event if the asset can be activated as collateral.\n     * @dev In case the asset is being deactivated as collateral, `ReserveUsedAsCollateralDisabled()` is emitted.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param asset The address of the asset being configured as collateral\n     * @param useAsCollateral True if the user wants to set the asset as collateral, false otherwise\n     * @param reservesCount The number of initialized reserves\n     * @param priceOracle The address of the price oracle\n     * @param userEModeCategory The eMode category chosen by the user\n     */\n    function executeUseReserveAsCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        bool useAsCollateral,\n        uint256 reservesCount,\n        address priceOracle,\n        uint8 userEModeCategory\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        uint256 userBalance = IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender);\n\n        ValidationLogic.validateSetUseReserveAsCollateral(reserveCache, userBalance);\n\n        if (useAsCollateral == userConfig.isUsingAsCollateral(reserve.id)) return;\n\n        if (useAsCollateral) {\n            require(\n                ValidationLogic.validateUseAsCollateral(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    reserveCache.reserveConfiguration\n                ),\n                Errors.USER_IN_ISOLATION_MODE_OR_LTV_ZERO\n            );\n\n            userConfig.setUsingAsCollateral(reserve.id, true);\n            emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n        } else {\n            userConfig.setUsingAsCollateral(reserve.id, false);\n            ValidationLogic.validateHFAndLtv(\n                reservesData,\n                reservesList,\n                eModeCategories,\n                userConfig,\n                asset,\n                msg.sender,\n                reservesCount,\n                priceOracle,\n                userEModeCategory\n            );\n\n            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { Address } from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\nimport { GPv2SafeERC20 } from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IReserveInterestRateStrategy } from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport { IStableDebtToken } from \"../../../interfaces/IStableDebtToken.sol\";\nimport { IScaledBalanceToken } from \"../../../interfaces/IScaledBalanceToken.sol\";\nimport { IPriceOracleGetter } from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport { IAToken } from \"../../../interfaces/IAToken.sol\";\nimport { IPriceOracleSentinel } from \"../../../interfaces/IPriceOracleSentinel.sol\";\nimport { IPoolAddressesProvider } from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport { IAccessControl } from \"../../../dependencies/openzeppelin/contracts/IAccessControl.sol\";\nimport { ReserveConfiguration } from \"../configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"../configuration/UserConfiguration.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\nimport { WadRayMath } from \"../math/WadRayMath.sol\";\nimport { PercentageMath } from \"../math/PercentageMath.sol\";\nimport { DataTypes } from \"../types/DataTypes.sol\";\nimport { ReserveLogic } from \"./ReserveLogic.sol\";\nimport { GenericLogic } from \"./GenericLogic.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IncentivizedERC20 } from \"../../tokenization/base/IncentivizedERC20.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n    using ReserveLogic for DataTypes.ReserveData;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using SafeCast for uint256;\n    using GPv2SafeERC20 for IERC20;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using Address for address;\n\n    // Factor to apply to \"only-variable-debt\" liquidity rate to get threshold for rebalancing, expressed in bps\n    // A value of 0.9e4 results in 90%\n    uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4;\n\n    // Minimum health factor allowed under any circumstance\n    // A value of 0.95e18 results in 0.95\n    uint256 public constant MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18;\n\n    /**\n     * @dev Minimum health factor to consider a user position healthy\n     * A value of 1e18 results in 1\n     */\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n    /**\n     * @dev Role identifier for the role allowed to supply isolated reserves as collateral\n     */\n    bytes32 public constant ISOLATED_COLLATERAL_SUPPLIER_ROLE = keccak256(\"ISOLATED_COLLATERAL_SUPPLIER\");\n\n    /**\n     * @notice Validates a supply action.\n     * @param reserveCache The cached data of the reserve\n     * @param amount The amount to be supplied\n     */\n    function validateSupply(\n        DataTypes.ReserveCache memory reserveCache,\n        DataTypes.ReserveData storage reserve,\n        uint256 amount\n    ) internal view {\n        require(amount != 0, Errors.INVALID_AMOUNT);\n\n        (bool isActive, bool isFrozen, , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n        require(!isFrozen, Errors.RESERVE_FROZEN);\n\n        uint256 supplyCap = reserveCache.reserveConfiguration.getSupplyCap();\n        require(\n            supplyCap == 0 ||\n                ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() + uint256(reserve.accruedToTreasury)).rayMul(\n                    reserveCache.nextLiquidityIndex\n                ) + amount) <=\n                supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),\n            Errors.SUPPLY_CAP_EXCEEDED\n        );\n    }\n\n    /**\n     * @notice Validates a withdraw action.\n     * @param reserveCache The cached data of the reserve\n     * @param amount The amount to be withdrawn\n     * @param userBalance The balance of the user\n     */\n    function validateWithdraw(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 amount,\n        uint256 userBalance\n    ) internal pure {\n        require(amount != 0, Errors.INVALID_AMOUNT);\n        require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n        (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n    }\n\n    struct ValidateBorrowLocalVars {\n        uint256 currentLtv;\n        uint256 collateralNeededInBaseCurrency;\n        uint256 userCollateralInBaseCurrency;\n        uint256 userDebtInBaseCurrency;\n        uint256 availableLiquidity;\n        uint256 healthFactor;\n        uint256 totalDebt;\n        uint256 totalSupplyVariableDebt;\n        uint256 reserveDecimals;\n        uint256 borrowCap;\n        uint256 amountInBaseCurrency;\n        uint256 assetUnit;\n        address eModePriceSource;\n        address siloedBorrowingAddress;\n        bool isActive;\n        bool isFrozen;\n        bool isPaused;\n        bool borrowingEnabled;\n        bool stableRateBorrowingEnabled;\n        bool siloedBorrowingEnabled;\n    }\n\n    /**\n     * @notice Validates a borrow action.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param params Additional params needed for the validation\n     */\n    function validateBorrow(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.ValidateBorrowParams memory params\n    ) internal view {\n        require(params.amount != 0, Errors.INVALID_AMOUNT);\n\n        ValidateBorrowLocalVars memory vars;\n\n        (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled, vars.isPaused) = params\n            .reserveCache\n            .reserveConfiguration\n            .getFlags();\n\n        require(vars.isActive, Errors.RESERVE_INACTIVE);\n        require(!vars.isPaused, Errors.RESERVE_PAUSED);\n        require(!vars.isFrozen, Errors.RESERVE_FROZEN);\n        require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n\n        require(\n            params.priceOracleSentinel == address(0) ||\n                IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),\n            Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n        );\n\n        //validate interest rate mode\n        require(\n            params.interestRateMode == DataTypes.InterestRateMode.VARIABLE ||\n                params.interestRateMode == DataTypes.InterestRateMode.STABLE,\n            Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n        );\n\n        vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals();\n        vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap();\n        unchecked {\n            vars.assetUnit = 10 ** vars.reserveDecimals;\n        }\n\n        if (vars.borrowCap != 0) {\n            vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(\n                params.reserveCache.nextVariableBorrowIndex\n            );\n\n            vars.totalDebt = params.reserveCache.currTotalStableDebt + vars.totalSupplyVariableDebt + params.amount;\n\n            unchecked {\n                require(vars.totalDebt <= vars.borrowCap * vars.assetUnit, Errors.BORROW_CAP_EXCEEDED);\n            }\n        }\n\n        if (params.isolationModeActive) {\n            // check that the asset being borrowed is borrowable in isolation mode AND\n            // the total exposure is no bigger than the collateral debt ceiling\n            require(\n                params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),\n                Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n            );\n\n            require(\n                reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt +\n                    (params.amount / 10 ** (vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n                        .toUint128() <=\n                    params.isolationModeDebtCeiling,\n                Errors.DEBT_CEILING_EXCEEDED\n            );\n        }\n\n        if (params.userEModeCategory != 0) {\n            require(\n                params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,\n                Errors.INCONSISTENT_EMODE_CATEGORY\n            );\n            vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n        }\n\n        (\n            vars.userCollateralInBaseCurrency,\n            vars.userDebtInBaseCurrency,\n            vars.currentLtv,\n            ,\n            vars.healthFactor,\n\n        ) = GenericLogic.calculateUserAccountData(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            DataTypes.CalculateUserAccountDataParams({\n                userConfig: params.userConfig,\n                reservesCount: params.reservesCount,\n                user: params.userAddress,\n                oracle: params.oracle,\n                userEModeCategory: params.userEModeCategory\n            })\n        );\n\n        require(vars.userCollateralInBaseCurrency != 0, Errors.COLLATERAL_BALANCE_IS_ZERO);\n        require(vars.currentLtv != 0, Errors.LTV_VALIDATION_FAILED);\n\n        require(\n            vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n        );\n\n        vars.amountInBaseCurrency =\n            IPriceOracleGetter(params.oracle).getAssetPrice(\n                vars.eModePriceSource != address(0) ? vars.eModePriceSource : params.asset\n            ) *\n            params.amount;\n        unchecked {\n            vars.amountInBaseCurrency /= vars.assetUnit;\n        }\n\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n        vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency).percentDiv(\n            vars.currentLtv\n        ); //LTV is calculated in percentage\n\n        require(\n            vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,\n            Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n        );\n\n        /**\n         * Following conditions need to be met if the user is borrowing at a stable rate:\n         * 1. Reserve must be enabled for stable rate borrowing\n         * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n         *    they are borrowing, to prevent abuses.\n         * 3. Users will be able to borrow only a portion of the total available liquidity\n         */\n\n        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n            require(vars.stableRateBorrowingEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n            require(\n                !params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) ||\n                    params.reserveCache.reserveConfiguration.getLtv() == 0 ||\n                    params.amount > IERC20(params.reserveCache.aTokenAddress).balanceOf(params.userAddress),\n                Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n            );\n\n            vars.availableLiquidity = IERC20(params.asset).balanceOf(params.reserveCache.aTokenAddress);\n\n            //calculate the max available loan size in stable rate mode as a percentage of the\n            //available liquidity\n            uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(params.maxStableLoanPercent);\n\n            require(params.amount <= maxLoanSizeStable, Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n        }\n\n        if (params.userConfig.isBorrowingAny()) {\n            (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) = params.userConfig.getSiloedBorrowingState(\n                reservesData,\n                reservesList\n            );\n\n            if (vars.siloedBorrowingEnabled) {\n                require(vars.siloedBorrowingAddress == params.asset, Errors.SILOED_BORROWING_VIOLATION);\n            } else {\n                require(\n                    !params.reserveCache.reserveConfiguration.getSiloedBorrowing(),\n                    Errors.SILOED_BORROWING_VIOLATION\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a repay action.\n     * @param reserveCache The cached data of the reserve\n     * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n     * @param interestRateMode The interest rate mode of the debt being repaid\n     * @param onBehalfOf The address of the user msg.sender is repaying for\n     * @param stableDebt The borrow balance of the user\n     * @param variableDebt The borrow balance of the user\n     */\n    function validateRepay(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 amountSent,\n        DataTypes.InterestRateMode interestRateMode,\n        address onBehalfOf,\n        uint256 stableDebt,\n        uint256 variableDebt\n    ) internal view {\n        require(amountSent != 0, Errors.INVALID_AMOUNT);\n        require(\n            amountSent != type(uint256).max || msg.sender == onBehalfOf,\n            Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n        );\n\n        (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n\n        require(\n            (stableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.STABLE) ||\n                (variableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.VARIABLE),\n            Errors.NO_DEBT_OF_SELECTED_TYPE\n        );\n    }\n\n    /**\n     * @notice Validates a swap of borrow rate mode.\n     * @param reserve The reserve state on which the user is swapping the rate\n     * @param reserveCache The cached data of the reserve\n     * @param userConfig The user reserves configuration\n     * @param stableDebt The stable debt of the user\n     * @param variableDebt The variable debt of the user\n     * @param currentRateMode The rate mode of the debt being swapped\n     */\n    function validateSwapRateMode(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.ReserveCache memory reserveCache,\n        DataTypes.UserConfigurationMap storage userConfig,\n        uint256 stableDebt,\n        uint256 variableDebt,\n        DataTypes.InterestRateMode currentRateMode\n    ) internal view {\n        (bool isActive, bool isFrozen, , bool stableRateEnabled, bool isPaused) = reserveCache\n            .reserveConfiguration\n            .getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n        require(!isFrozen, Errors.RESERVE_FROZEN);\n\n        if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n            require(stableDebt != 0, Errors.NO_OUTSTANDING_STABLE_DEBT);\n        } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n            require(variableDebt != 0, Errors.NO_OUTSTANDING_VARIABLE_DEBT);\n            /**\n             * user wants to swap to stable, before swapping we need to ensure that\n             * 1. stable borrow rate is enabled on the reserve\n             * 2. user is not trying to abuse the reserve by supplying\n             * more collateral than he is borrowing, artificially lowering\n             * the interest rate, borrowing at variable, and switching to stable\n             */\n            require(stableRateEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n            require(\n                !userConfig.isUsingAsCollateral(reserve.id) ||\n                    reserveCache.reserveConfiguration.getLtv() == 0 ||\n                    stableDebt + variableDebt > IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),\n                Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n            );\n        } else {\n            revert(Errors.INVALID_INTEREST_RATE_MODE_SELECTED);\n        }\n    }\n\n    /**\n     * @notice Validates a stable borrow rate rebalance action.\n     * @dev Rebalancing is accepted when depositors are earning <= 90% of their earnings in pure supply/demand market (variable rate only)\n     * For this to be the case, there has to be quite large stable debt with an interest rate below the current variable rate.\n     * @param reserve The reserve state on which the user is getting rebalanced\n     * @param reserveCache The cached state of the reserve\n     * @param reserveAddress The address of the reserve\n     */\n    function validateRebalanceStableBorrowRate(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.ReserveCache memory reserveCache,\n        address reserveAddress\n    ) internal view {\n        (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n\n        uint256 totalDebt = IERC20(reserveCache.stableDebtTokenAddress).totalSupply() +\n            IERC20(reserveCache.variableDebtTokenAddress).totalSupply();\n\n        (uint256 liquidityRateVariableDebtOnly, , ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .calculateInterestRates(\n                DataTypes.CalculateInterestRatesParams({\n                    unbacked: reserve.unbacked,\n                    liquidityAdded: 0,\n                    liquidityTaken: 0,\n                    totalStableDebt: 0,\n                    totalVariableDebt: totalDebt,\n                    averageStableBorrowRate: 0,\n                    reserveFactor: reserveCache.reserveFactor,\n                    reserve: reserveAddress,\n                    aToken: reserveCache.aTokenAddress\n                })\n            );\n\n        require(\n            reserveCache.currLiquidityRate <=\n                liquidityRateVariableDebtOnly.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n            Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n        );\n    }\n\n    /**\n     * @notice Validates the action of setting an asset as collateral.\n     * @param reserveCache The cached data of the reserve\n     * @param userBalance The balance of the user\n     */\n    function validateSetUseReserveAsCollateral(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 userBalance\n    ) internal pure {\n        require(userBalance != 0, Errors.UNDERLYING_BALANCE_ZERO);\n\n        (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n    }\n\n    /**\n     * @notice Validates a flashloan action.\n     * @param reservesData The state of all the reserves\n     * @param assets The assets being flash-borrowed\n     * @param amounts The amounts for each asset being borrowed\n     */\n    function validateFlashloan(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal view {\n        require(assets.length == amounts.length, Errors.INCONSISTENT_FLASHLOAN_PARAMS);\n        for (uint256 i = 0; i < assets.length; i++) {\n            validateFlashloanSimple(reservesData[assets[i]]);\n        }\n    }\n\n    /**\n     * @notice Validates a flashloan action.\n     * @param reserve The state of the reserve\n     */\n    function validateFlashloanSimple(DataTypes.ReserveData storage reserve) internal view {\n        DataTypes.ReserveConfigurationMap memory configuration = reserve.configuration;\n        require(!configuration.getPaused(), Errors.RESERVE_PAUSED);\n        require(configuration.getActive(), Errors.RESERVE_INACTIVE);\n        require(configuration.getFlashLoanEnabled(), Errors.FLASHLOAN_DISABLED);\n    }\n\n    struct ValidateLiquidationCallLocalVars {\n        bool collateralReserveActive;\n        bool collateralReservePaused;\n        bool principalReserveActive;\n        bool principalReservePaused;\n        bool isCollateralEnabled;\n    }\n\n    /**\n     * @notice Validates the liquidation action.\n     * @param userConfig The user configuration mapping\n     * @param collateralReserve The reserve data of the collateral\n     * @param params Additional parameters needed for the validation\n     */\n    function validateLiquidationCall(\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ValidateLiquidationCallParams memory params\n    ) internal view {\n        ValidateLiquidationCallLocalVars memory vars;\n\n        (vars.collateralReserveActive, , , , vars.collateralReservePaused) = collateralReserve.configuration.getFlags();\n\n        (vars.principalReserveActive, , , , vars.principalReservePaused) = params\n            .debtReserveCache\n            .reserveConfiguration\n            .getFlags();\n\n        require(vars.collateralReserveActive && vars.principalReserveActive, Errors.RESERVE_INACTIVE);\n        require(!vars.collateralReservePaused && !vars.principalReservePaused, Errors.RESERVE_PAUSED);\n\n        require(\n            params.priceOracleSentinel == address(0) ||\n                params.healthFactor < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD ||\n                IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed(),\n            Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n        );\n\n        require(params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD);\n\n        vars.isCollateralEnabled =\n            collateralReserve.configuration.getLiquidationThreshold() != 0 &&\n            userConfig.isUsingAsCollateral(collateralReserve.id);\n\n        //if collateral isn't enabled as collateral by user, it cannot be liquidated\n        require(vars.isCollateralEnabled, Errors.COLLATERAL_CANNOT_BE_LIQUIDATED);\n        require(params.totalDebt != 0, Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER);\n    }\n\n    /**\n     * @notice Validates the health factor of a user.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The state of the user for the specific reserve\n     * @param user The user to validate health factor of\n     * @param userEModeCategory The users active efficiency mode category\n     * @param reservesCount The number of available reserves\n     * @param oracle The price oracle\n     */\n    function validateHealthFactor(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap memory userConfig,\n        address user,\n        uint8 userEModeCategory,\n        uint256 reservesCount,\n        address oracle\n    ) internal view returns (uint256, bool) {\n        (, , , , uint256 healthFactor, bool hasZeroLtvCollateral) = GenericLogic.calculateUserAccountData(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            DataTypes.CalculateUserAccountDataParams({\n                userConfig: userConfig,\n                reservesCount: reservesCount,\n                user: user,\n                oracle: oracle,\n                userEModeCategory: userEModeCategory\n            })\n        );\n\n        require(\n            healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n        );\n\n        return (healthFactor, hasZeroLtvCollateral);\n    }\n\n    /**\n     * @notice Validates the health factor of a user and the ltv of the asset being withdrawn.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories The configuration of all the efficiency mode categories\n     * @param userConfig The state of the user for the specific reserve\n     * @param asset The asset for which the ltv will be validated\n     * @param from The user from which the aTokens are being transferred\n     * @param reservesCount The number of available reserves\n     * @param oracle The price oracle\n     * @param userEModeCategory The users active efficiency mode category\n     */\n    function validateHFAndLtv(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap memory userConfig,\n        address asset,\n        address from,\n        uint256 reservesCount,\n        address oracle,\n        uint8 userEModeCategory\n    ) internal view {\n        DataTypes.ReserveData memory reserve = reservesData[asset];\n\n        (, bool hasZeroLtvCollateral) = validateHealthFactor(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            userConfig,\n            from,\n            userEModeCategory,\n            reservesCount,\n            oracle\n        );\n\n        require(!hasZeroLtvCollateral || reserve.configuration.getLtv() == 0, Errors.LTV_VALIDATION_FAILED);\n    }\n\n    /**\n     * @notice Validates a transfer action.\n     * @param reserve The reserve object\n     */\n    function validateTransfer(DataTypes.ReserveData storage reserve) internal view {\n        require(!reserve.configuration.getPaused(), Errors.RESERVE_PAUSED);\n    }\n\n    /**\n     * @notice Validates a drop reserve action.\n     * @param reservesList The addresses of all the active reserves\n     * @param reserve The reserve object\n     * @param asset The address of the reserve's underlying asset\n     */\n    function validateDropReserve(\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.ReserveData storage reserve,\n        address asset\n    ) internal view {\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(reserve.id != 0 || reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n        require(IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0, Errors.STABLE_DEBT_NOT_ZERO);\n        require(IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0, Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO);\n        require(\n            IERC20(reserve.aTokenAddress).totalSupply() == 0 && reserve.accruedToTreasury == 0,\n            Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO\n        );\n    }\n\n    /**\n     * @notice Validates the action of setting efficiency mode.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param eModeCategories a mapping storing configurations for all efficiency mode categories\n     * @param userConfig the user configuration\n     * @param reservesCount The total number of valid reserves\n     * @param categoryId The id of the category\n     */\n    function validateSetUserEMode(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n        DataTypes.UserConfigurationMap memory userConfig,\n        uint256 reservesCount,\n        uint8 categoryId\n    ) internal view {\n        // category is invalid if the liq threshold is not set\n        require(\n            categoryId == 0 || eModeCategories[categoryId].liquidationThreshold != 0,\n            Errors.INCONSISTENT_EMODE_CATEGORY\n        );\n\n        // eMode can always be enabled if the user hasn't supplied anything\n        if (userConfig.isEmpty()) {\n            return;\n        }\n\n        // if user is trying to set another category than default we require that\n        // either the user is not borrowing, or it's borrowing assets of categoryId\n        if (categoryId != 0) {\n            unchecked {\n                for (uint256 i = 0; i < reservesCount; i++) {\n                    if (userConfig.isBorrowing(i)) {\n                        DataTypes.ReserveConfigurationMap memory configuration = reservesData[reservesList[i]]\n                            .configuration;\n                        require(configuration.getEModeCategory() == categoryId, Errors.INCONSISTENT_EMODE_CATEGORY);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Validates the action of activating the asset as collateral.\n     * @dev Only possible if the asset has non-zero LTV and the user is not in isolation mode\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig the user configuration\n     * @param reserveConfig The reserve configuration\n     * @return True if the asset can be activated as collateral, false otherwise\n     */\n    function validateUseAsCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveConfigurationMap memory reserveConfig\n    ) internal view returns (bool) {\n        if (reserveConfig.getLtv() == 0) {\n            return false;\n        }\n        if (!userConfig.isUsingAsCollateralAny()) {\n            return true;\n        }\n        (bool isolationModeActive, , ) = userConfig.getIsolationModeState(reservesData, reservesList);\n\n        return (!isolationModeActive && reserveConfig.getDebtCeiling() == 0);\n    }\n\n    /**\n     * @notice Validates if an asset should be automatically activated as collateral in the following actions: supply,\n     * transfer, mint unbacked, and liquidate\n     * @dev This is used to ensure that isolated assets are not enabled as collateral automatically\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig the user configuration\n     * @param reserveConfig The reserve configuration\n     * @return True if the asset can be activated as collateral, false otherwise\n     */\n    function validateAutomaticUseAsCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveConfigurationMap memory reserveConfig,\n        address aTokenAddress\n    ) internal view returns (bool) {\n        if (reserveConfig.getDebtCeiling() != 0) {\n            // ensures only the ISOLATED_COLLATERAL_SUPPLIER_ROLE can enable collateral as side-effect of an action\n            IPoolAddressesProvider addressesProvider = IncentivizedERC20(aTokenAddress).POOL().ADDRESSES_PROVIDER();\n            if (\n                !IAccessControl(addressesProvider.getACLManager()).hasRole(\n                    ISOLATED_COLLATERAL_SUPPLIER_ROLE,\n                    msg.sender\n                )\n            ) return false;\n        }\n        return validateUseAsCollateral(reservesData, reservesList, userConfig, reserveConfig);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { WadRayMath } from \"./WadRayMath.sol\";\n\n/**\n * @title MathUtils library\n * @author Aave\n * @notice Provides functions to perform linear and compounded interest calculations\n */\nlibrary MathUtils {\n    using WadRayMath for uint256;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\n     */\n    function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 result = rate * (block.timestamp - uint256(lastUpdateTimestamp));\n        unchecked {\n            result = result / SECONDS_PER_YEAR;\n        }\n\n        return WadRayMath.RAY + result;\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great\n     * gas cost reductions. The whitepaper contains reference to the approximation and a table showing the margin of\n     * error per different time periods\n     *\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     */\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp,\n        uint256 currentTimestamp\n    ) internal pure returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRayMath.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n     * @param rate The interest rate (in ray)\n     * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n     * @return The interest rate compounded between lastUpdateTimestamp and current block timestamp, in ray\n     */\n    function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n        return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n    // Maximum percentage factor (100.00%)\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    /**\n     * @notice Executes a percentage multiplication\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentmul percentage\n     */\n    function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n        assembly {\n            if iszero(or(iszero(percentage), iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage))))) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n        }\n    }\n\n    /**\n     * @notice Executes a percentage division\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentdiv percentage\n     */\n    function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n        assembly {\n            if or(\n                iszero(percentage),\n                iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     */\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     */\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     */\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     */\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     */\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     */\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nlibrary ConfiguratorInputTypes {\n    struct InitReserveInput {\n        address aTokenImpl;\n        address stableDebtTokenImpl;\n        address variableDebtTokenImpl;\n        uint8 underlyingAssetDecimals;\n        address interestRateStrategyAddress;\n        address underlyingAsset;\n        address treasury;\n        address incentivesController;\n        string aTokenName;\n        string aTokenSymbol;\n        string variableDebtTokenName;\n        string variableDebtTokenSymbol;\n        string stableDebtTokenName;\n        string stableDebtTokenSymbol;\n        bytes params;\n    }\n\n    struct UpdateATokenInput {\n        address asset;\n        address treasury;\n        address incentivesController;\n        string name;\n        string symbol;\n        address implementation;\n        bytes params;\n    }\n\n    struct UpdateDebtTokenInput {\n        address asset;\n        address incentivesController;\n        string name;\n        string symbol;\n        address implementation;\n        bytes params;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62: siloed borrowing enabled\n        //bit 63: flashloaning enabled\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n    }\n\n    struct EModeCategory {\n        // each eMode category has a custom ltv and liquidation threshold\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n        address priceSource;\n        string label;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currPrincipalStableDebt;\n        uint256 currAvgStableBorrowRate;\n        uint256 currTotalStableDebt;\n        uint256 nextAvgStableBorrowRate;\n        uint256 nextTotalStableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n        uint40 stableDebtLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidationCallParams {\n        uint256 reservesCount;\n        uint256 debtToCover;\n        address collateralAsset;\n        address debtAsset;\n        address user;\n        bool receiveAToken;\n        address priceOracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        address onBehalfOf;\n        bool useATokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ExecuteSetUserEModeParams {\n        uint256 reservesCount;\n        address oracle;\n        uint8 categoryId;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n        uint8 fromEModeCategory;\n    }\n\n    struct FlashloanParams {\n        address receiverAddress;\n        address[] assets;\n        uint256[] amounts;\n        uint256[] interestRateModes;\n        address onBehalfOf;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address addressesProvider;\n        uint8 userEModeCategory;\n        bool isAuthorizedFlashBorrower;\n    }\n\n    struct FlashloanSimpleParams {\n        address receiverAddress;\n        address asset;\n        uint256 amount;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n    }\n\n    struct FlashLoanRepaymentParams {\n        uint256 amount;\n        uint256 totalPremium;\n        uint256 flashLoanPremiumToProtocol;\n        address asset;\n        address receiverAddress;\n        uint16 referralCode;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint256 maxStableLoanPercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n        bool isolationModeActive;\n        address isolationModeCollateralAddress;\n        uint256 isolationModeDebtCeiling;\n    }\n\n    struct ValidateLiquidationCallParams {\n        ReserveCache debtReserveCache;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        address priceOracleSentinel;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 unbacked;\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 averageStableBorrowRate;\n        uint256 reserveFactor;\n        address reserve;\n        address aToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address aTokenAddress;\n        address stableDebtAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/pool/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { WadRayMath } from \"../libraries/math/WadRayMath.sol\";\nimport { PercentageMath } from \"../libraries/math/PercentageMath.sol\";\nimport { DataTypes } from \"../libraries/types/DataTypes.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { IDefaultInterestRateStrategy } from \"../../interfaces/IDefaultInterestRateStrategy.sol\";\nimport { IReserveInterestRateStrategy } from \"../../interfaces/IReserveInterestRateStrategy.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\n\n/**\n * @title DefaultReserveInterestRateStrategy contract\n * @author Aave\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO`\n * point of usage and another from that one to 100%.\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\n *   of the PoolAddressesProvider\n */\ncontract DefaultReserveInterestRateStrategy is IDefaultInterestRateStrategy {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public immutable OPTIMAL_USAGE_RATIO;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public immutable OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public immutable MAX_EXCESS_USAGE_RATIO;\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    uint256 public immutable MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO;\n\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    // Base variable borrow rate when usage rate = 0. Expressed in ray\n    uint256 internal immutable _baseVariableBorrowRate;\n\n    // Slope of the variable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal immutable _variableRateSlope1;\n\n    // Slope of the variable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal immutable _variableRateSlope2;\n\n    // Slope of the stable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal immutable _stableRateSlope1;\n\n    // Slope of the stable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\n    uint256 internal immutable _stableRateSlope2;\n\n    // Premium on top of `_variableRateSlope1` for base stable borrowing rate\n    uint256 internal immutable _baseStableRateOffset;\n\n    // Additional premium applied to stable rate when stable debt surpass `OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO`\n    uint256 internal immutable _stableRateExcessOffset;\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     * @param optimalUsageRatio The optimal usage ratio\n     * @param baseVariableBorrowRate The base variable borrow rate\n     * @param variableRateSlope1 The variable rate slope below optimal usage ratio\n     * @param variableRateSlope2 The variable rate slope above optimal usage ratio\n     * @param stableRateSlope1 The stable rate slope below optimal usage ratio\n     * @param stableRateSlope2 The stable rate slope above optimal usage ratio\n     * @param baseStableRateOffset The premium on top of variable rate for base stable borrowing rate\n     * @param stableRateExcessOffset The premium on top of stable rate when there stable debt surpass the threshold\n     * @param optimalStableToTotalDebtRatio The optimal stable debt to total debt ratio of the reserve\n     */\n    constructor(\n        IPoolAddressesProvider provider,\n        uint256 optimalUsageRatio,\n        uint256 baseVariableBorrowRate,\n        uint256 variableRateSlope1,\n        uint256 variableRateSlope2,\n        uint256 stableRateSlope1,\n        uint256 stableRateSlope2,\n        uint256 baseStableRateOffset,\n        uint256 stableRateExcessOffset,\n        uint256 optimalStableToTotalDebtRatio\n    ) {\n        require(WadRayMath.RAY >= optimalUsageRatio, Errors.INVALID_OPTIMAL_USAGE_RATIO);\n        require(WadRayMath.RAY >= optimalStableToTotalDebtRatio, Errors.INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO);\n        OPTIMAL_USAGE_RATIO = optimalUsageRatio;\n        MAX_EXCESS_USAGE_RATIO = WadRayMath.RAY - optimalUsageRatio;\n        OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = optimalStableToTotalDebtRatio;\n        MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = WadRayMath.RAY - optimalStableToTotalDebtRatio;\n        ADDRESSES_PROVIDER = provider;\n        _baseVariableBorrowRate = baseVariableBorrowRate;\n        _variableRateSlope1 = variableRateSlope1;\n        _variableRateSlope2 = variableRateSlope2;\n        _stableRateSlope1 = stableRateSlope1;\n        _stableRateSlope2 = stableRateSlope2;\n        _baseStableRateOffset = baseStableRateOffset;\n        _stableRateExcessOffset = stableRateExcessOffset;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getVariableRateSlope1() external view returns (uint256) {\n        return _variableRateSlope1;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getVariableRateSlope2() external view returns (uint256) {\n        return _variableRateSlope2;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateSlope1() external view returns (uint256) {\n        return _stableRateSlope1;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateSlope2() external view returns (uint256) {\n        return _stableRateSlope2;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getStableRateExcessOffset() external view returns (uint256) {\n        return _stableRateExcessOffset;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getBaseStableBorrowRate() public view returns (uint256) {\n        return _variableRateSlope1 + _baseStableRateOffset;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getBaseVariableBorrowRate() external view override returns (uint256) {\n        return _baseVariableBorrowRate;\n    }\n\n    /// @inheritdoc IDefaultInterestRateStrategy\n    function getMaxVariableBorrowRate() external view override returns (uint256) {\n        return _baseVariableBorrowRate + _variableRateSlope1 + _variableRateSlope2;\n    }\n\n    struct CalcInterestRatesLocalVars {\n        uint256 availableLiquidity;\n        uint256 totalDebt;\n        uint256 currentVariableBorrowRate;\n        uint256 currentStableBorrowRate;\n        uint256 currentLiquidityRate;\n        uint256 borrowUsageRatio;\n        uint256 supplyUsageRatio;\n        uint256 stableToTotalDebtRatio;\n        uint256 availableLiquidityPlusDebt;\n    }\n\n    /// @inheritdoc IReserveInterestRateStrategy\n    function calculateInterestRates(\n        DataTypes.CalculateInterestRatesParams memory params\n    ) public view override returns (uint256, uint256, uint256) {\n        CalcInterestRatesLocalVars memory vars;\n\n        vars.totalDebt = params.totalStableDebt + params.totalVariableDebt;\n\n        vars.currentLiquidityRate = 0;\n        vars.currentVariableBorrowRate = _baseVariableBorrowRate;\n        vars.currentStableBorrowRate = getBaseStableBorrowRate();\n\n        if (vars.totalDebt != 0) {\n            vars.stableToTotalDebtRatio = params.totalStableDebt.rayDiv(vars.totalDebt);\n            vars.availableLiquidity =\n                IERC20(params.reserve).balanceOf(params.aToken) +\n                params.liquidityAdded -\n                params.liquidityTaken;\n\n            vars.availableLiquidityPlusDebt = vars.availableLiquidity + vars.totalDebt;\n            vars.borrowUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);\n            vars.supplyUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt + params.unbacked);\n        }\n\n        if (vars.borrowUsageRatio > OPTIMAL_USAGE_RATIO) {\n            uint256 excessBorrowUsageRatio = (vars.borrowUsageRatio - OPTIMAL_USAGE_RATIO).rayDiv(\n                MAX_EXCESS_USAGE_RATIO\n            );\n\n            vars.currentStableBorrowRate += _stableRateSlope1 + _stableRateSlope2.rayMul(excessBorrowUsageRatio);\n\n            vars.currentVariableBorrowRate += _variableRateSlope1 + _variableRateSlope2.rayMul(excessBorrowUsageRatio);\n        } else {\n            vars.currentStableBorrowRate += _stableRateSlope1.rayMul(vars.borrowUsageRatio).rayDiv(OPTIMAL_USAGE_RATIO);\n\n            vars.currentVariableBorrowRate += _variableRateSlope1.rayMul(vars.borrowUsageRatio).rayDiv(\n                OPTIMAL_USAGE_RATIO\n            );\n        }\n\n        if (vars.stableToTotalDebtRatio > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO) {\n            uint256 excessStableDebtRatio = (vars.stableToTotalDebtRatio - OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO).rayDiv(\n                MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO\n            );\n            vars.currentStableBorrowRate += _stableRateExcessOffset.rayMul(excessStableDebtRatio);\n        }\n\n        vars.currentLiquidityRate = _getOverallBorrowRate(\n            params.totalStableDebt,\n            params.totalVariableDebt,\n            vars.currentVariableBorrowRate,\n            params.averageStableBorrowRate\n        ).rayMul(vars.supplyUsageRatio).percentMul(PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor);\n\n        return (vars.currentLiquidityRate, vars.currentStableBorrowRate, vars.currentVariableBorrowRate);\n    }\n\n    /**\n     * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable\n     * debt\n     * @param totalStableDebt The total borrowed from the reserve at a stable rate\n     * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n     * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n     * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n     * @return The weighted averaged borrow rate\n     */\n    function _getOverallBorrowRate(\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 currentVariableBorrowRate,\n        uint256 currentAverageStableBorrowRate\n    ) internal pure returns (uint256) {\n        uint256 totalDebt = totalStableDebt + totalVariableDebt;\n\n        if (totalDebt == 0) return 0;\n\n        uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n        uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n        uint256 overallBorrowRate = (weightedVariableRate + weightedStableRate).rayDiv(totalDebt.wadToRay());\n\n        return overallBorrowRate;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/pool/L2Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Pool } from \"./Pool.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IL2Pool } from \"../../interfaces/IL2Pool.sol\";\nimport { CalldataLogic } from \"../libraries/logic/CalldataLogic.sol\";\n\n/**\n * @title L2Pool\n * @author Aave\n * @notice Calldata optimized extension of the Pool contract allowing users to pass compact calldata representation\n * to reduce transaction costs on rollups.\n */\ncontract L2Pool is Pool, IL2Pool {\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) Pool(provider) {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IL2Pool\n    function supply(bytes32 args) external override {\n        (address asset, uint256 amount, uint16 referralCode) = CalldataLogic.decodeSupplyParams(_reservesList, args);\n\n        supply(asset, amount, msg.sender, referralCode);\n    }\n\n    /// @inheritdoc IL2Pool\n    function supplyWithPermit(bytes32 args, bytes32 r, bytes32 s) external override {\n        (address asset, uint256 amount, uint16 referralCode, uint256 deadline, uint8 v) = CalldataLogic\n            .decodeSupplyWithPermitParams(_reservesList, args);\n\n        supplyWithPermit(asset, amount, msg.sender, referralCode, deadline, v, r, s);\n    }\n\n    /// @inheritdoc IL2Pool\n    function withdraw(bytes32 args) external override returns (uint256) {\n        (address asset, uint256 amount) = CalldataLogic.decodeWithdrawParams(_reservesList, args);\n\n        return withdraw(asset, amount, msg.sender);\n    }\n\n    /// @inheritdoc IL2Pool\n    function borrow(bytes32 args) external override {\n        (address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode) = CalldataLogic\n            .decodeBorrowParams(_reservesList, args);\n\n        borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n    }\n\n    /// @inheritdoc IL2Pool\n    function repay(bytes32 args) external override returns (uint256) {\n        (address asset, uint256 amount, uint256 interestRateMode) = CalldataLogic.decodeRepayParams(\n            _reservesList,\n            args\n        );\n\n        return repay(asset, amount, interestRateMode, msg.sender);\n    }\n\n    /// @inheritdoc IL2Pool\n    function repayWithPermit(bytes32 args, bytes32 r, bytes32 s) external override returns (uint256) {\n        (address asset, uint256 amount, uint256 interestRateMode, uint256 deadline, uint8 v) = CalldataLogic\n            .decodeRepayWithPermitParams(_reservesList, args);\n\n        return repayWithPermit(asset, amount, interestRateMode, msg.sender, deadline, v, r, s);\n    }\n\n    /// @inheritdoc IL2Pool\n    function repayWithATokens(bytes32 args) external override returns (uint256) {\n        (address asset, uint256 amount, uint256 interestRateMode) = CalldataLogic.decodeRepayParams(\n            _reservesList,\n            args\n        );\n\n        return repayWithATokens(asset, amount, interestRateMode);\n    }\n\n    /// @inheritdoc IL2Pool\n    function swapBorrowRateMode(bytes32 args) external override {\n        (address asset, uint256 interestRateMode) = CalldataLogic.decodeSwapBorrowRateModeParams(_reservesList, args);\n        swapBorrowRateMode(asset, interestRateMode);\n    }\n\n    /// @inheritdoc IL2Pool\n    function rebalanceStableBorrowRate(bytes32 args) external override {\n        (address asset, address user) = CalldataLogic.decodeRebalanceStableBorrowRateParams(_reservesList, args);\n        rebalanceStableBorrowRate(asset, user);\n    }\n\n    /// @inheritdoc IL2Pool\n    function setUserUseReserveAsCollateral(bytes32 args) external override {\n        (address asset, bool useAsCollateral) = CalldataLogic.decodeSetUserUseReserveAsCollateralParams(\n            _reservesList,\n            args\n        );\n        setUserUseReserveAsCollateral(asset, useAsCollateral);\n    }\n\n    /// @inheritdoc IL2Pool\n    function liquidationCall(bytes32 args1, bytes32 args2) external override {\n        (\n            address collateralAsset,\n            address debtAsset,\n            address user,\n            uint256 debtToCover,\n            bool receiveAToken\n        ) = CalldataLogic.decodeLiquidationCallParams(_reservesList, args1, args2);\n        liquidationCall(collateralAsset, debtAsset, user, debtToCover, receiveAToken);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/pool/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { VersionedInitializable } from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { ReserveConfiguration } from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport { PoolLogic } from \"../libraries/logic/PoolLogic.sol\";\nimport { ReserveLogic } from \"../libraries/logic/ReserveLogic.sol\";\nimport { EModeLogic } from \"../libraries/logic/EModeLogic.sol\";\nimport { SupplyLogic } from \"../libraries/logic/SupplyLogic.sol\";\nimport { FlashLoanLogic } from \"../libraries/logic/FlashLoanLogic.sol\";\nimport { BorrowLogic } from \"../libraries/logic/BorrowLogic.sol\";\nimport { LiquidationLogic } from \"../libraries/logic/LiquidationLogic.sol\";\nimport { DataTypes } from \"../libraries/types/DataTypes.sol\";\nimport { BridgeLogic } from \"../libraries/logic/BridgeLogic.sol\";\nimport { IERC20WithPermit } from \"../../interfaces/IERC20WithPermit.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { PoolStorage } from \"./PoolStorage.sol\";\n\n/**\n * @title Pool contract\n * @author Aave\n * @notice Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Supply\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their supplied assets as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n */\ncontract Pool is VersionedInitializable, PoolStorage, IPool {\n    using ReserveLogic for DataTypes.ReserveData;\n\n    uint256 public constant POOL_REVISION = 0x1;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    /**\n     * @dev Only pool configurator can call functions marked by this modifier.\n     */\n    modifier onlyPoolConfigurator() {\n        _onlyPoolConfigurator();\n        _;\n    }\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     */\n    modifier onlyPoolAdmin() {\n        _onlyPoolAdmin();\n        _;\n    }\n\n    /**\n     * @dev Only bridge can call functions marked by this modifier.\n     */\n    modifier onlyBridge() {\n        _onlyBridge();\n        _;\n    }\n\n    function _onlyPoolConfigurator() internal view virtual {\n        require(ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender, Errors.CALLER_NOT_POOL_CONFIGURATOR);\n    }\n\n    function _onlyPoolAdmin() internal view virtual {\n        require(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);\n    }\n\n    function _onlyBridge() internal view virtual {\n        require(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isBridge(msg.sender), Errors.CALLER_NOT_BRIDGE);\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return POOL_REVISION;\n    }\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n    }\n\n    /**\n     * @notice Initializes the Pool.\n     * @dev Function is invoked by the proxy contract when the Pool contract is added to the\n     * PoolAddressesProvider of the market.\n     * @dev Caching the address of the PoolAddressesProvider in order to reduce gas consumption on subsequent operations\n     * @param provider The address of the PoolAddressesProvider\n     */\n    function initialize(IPoolAddressesProvider provider) external virtual initializer {\n        require(provider == ADDRESSES_PROVIDER, Errors.INVALID_ADDRESSES_PROVIDER);\n        _maxStableRateBorrowSizePercent = 0.25e4;\n    }\n\n    /// @inheritdoc IPool\n    function mintUnbacked(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external virtual override onlyBridge {\n        BridgeLogic.executeMintUnbacked(\n            _reserves,\n            _reservesList,\n            _usersConfig[onBehalfOf],\n            asset,\n            amount,\n            onBehalfOf,\n            referralCode\n        );\n    }\n\n    /// @inheritdoc IPool\n    function backUnbacked(\n        address asset,\n        uint256 amount,\n        uint256 fee\n    ) external virtual override onlyBridge returns (uint256) {\n        return BridgeLogic.executeBackUnbacked(_reserves[asset], asset, amount, fee, _bridgeProtocolFee);\n    }\n\n    /// @inheritdoc IPool\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) public virtual override {\n        SupplyLogic.executeSupply(\n            _reserves,\n            _reservesList,\n            _usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf,\n                referralCode: referralCode\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) public virtual override {\n        IERC20WithPermit(asset).permit(msg.sender, address(this), amount, deadline, permitV, permitR, permitS);\n        SupplyLogic.executeSupply(\n            _reserves,\n            _reservesList,\n            _usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf,\n                referralCode: referralCode\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function withdraw(address asset, uint256 amount, address to) public virtual override returns (uint256) {\n        return\n            SupplyLogic.executeWithdraw(\n                _reserves,\n                _reservesList,\n                _eModeCategories,\n                _usersConfig[msg.sender],\n                DataTypes.ExecuteWithdrawParams({\n                    asset: asset,\n                    amount: amount,\n                    to: to,\n                    reservesCount: _reservesCount,\n                    oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                    userEModeCategory: _usersEModeCategory[msg.sender]\n                })\n            );\n    }\n\n    /// @inheritdoc IPool\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) public virtual override {\n        BorrowLogic.executeBorrow(\n            _reserves,\n            _reservesList,\n            _eModeCategories,\n            _usersConfig[onBehalfOf],\n            DataTypes.ExecuteBorrowParams({\n                asset: asset,\n                user: msg.sender,\n                onBehalfOf: onBehalfOf,\n                amount: amount,\n                interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n                referralCode: referralCode,\n                releaseUnderlying: true,\n                maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n                reservesCount: _reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                userEModeCategory: _usersEModeCategory[onBehalfOf],\n                priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) public virtual override returns (uint256) {\n        return\n            BorrowLogic.executeRepay(\n                _reserves,\n                _reservesList,\n                _usersConfig[onBehalfOf],\n                DataTypes.ExecuteRepayParams({\n                    asset: asset,\n                    amount: amount,\n                    interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n                    onBehalfOf: onBehalfOf,\n                    useATokens: false\n                })\n            );\n    }\n\n    /// @inheritdoc IPool\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) public virtual override returns (uint256) {\n        {\n            IERC20WithPermit(asset).permit(msg.sender, address(this), amount, deadline, permitV, permitR, permitS);\n        }\n        {\n            DataTypes.ExecuteRepayParams memory params = DataTypes.ExecuteRepayParams({\n                asset: asset,\n                amount: amount,\n                interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n                onBehalfOf: onBehalfOf,\n                useATokens: false\n            });\n            return BorrowLogic.executeRepay(_reserves, _reservesList, _usersConfig[onBehalfOf], params);\n        }\n    }\n\n    /// @inheritdoc IPool\n    function repayWithATokens(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) public virtual override returns (uint256) {\n        return\n            BorrowLogic.executeRepay(\n                _reserves,\n                _reservesList,\n                _usersConfig[msg.sender],\n                DataTypes.ExecuteRepayParams({\n                    asset: asset,\n                    amount: amount,\n                    interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n                    onBehalfOf: msg.sender,\n                    useATokens: true\n                })\n            );\n    }\n\n    /// @inheritdoc IPool\n    function swapBorrowRateMode(address asset, uint256 interestRateMode) public virtual override {\n        BorrowLogic.executeSwapBorrowRateMode(\n            _reserves[asset],\n            _usersConfig[msg.sender],\n            asset,\n            DataTypes.InterestRateMode(interestRateMode)\n        );\n    }\n\n    /// @inheritdoc IPool\n    function rebalanceStableBorrowRate(address asset, address user) public virtual override {\n        BorrowLogic.executeRebalanceStableBorrowRate(_reserves[asset], asset, user);\n    }\n\n    /// @inheritdoc IPool\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) public virtual override {\n        SupplyLogic.executeUseReserveAsCollateral(\n            _reserves,\n            _reservesList,\n            _eModeCategories,\n            _usersConfig[msg.sender],\n            asset,\n            useAsCollateral,\n            _reservesCount,\n            ADDRESSES_PROVIDER.getPriceOracle(),\n            _usersEModeCategory[msg.sender]\n        );\n    }\n\n    /// @inheritdoc IPool\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) public virtual override {\n        LiquidationLogic.executeLiquidationCall(\n            _reserves,\n            _reservesList,\n            _usersConfig,\n            _eModeCategories,\n            DataTypes.ExecuteLiquidationCallParams({\n                reservesCount: _reservesCount,\n                debtToCover: debtToCover,\n                collateralAsset: collateralAsset,\n                debtAsset: debtAsset,\n                user: user,\n                receiveAToken: receiveAToken,\n                priceOracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                userEModeCategory: _usersEModeCategory[user],\n                priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) public virtual override {\n        DataTypes.FlashloanParams memory flashParams = DataTypes.FlashloanParams({\n            receiverAddress: receiverAddress,\n            assets: assets,\n            amounts: amounts,\n            interestRateModes: interestRateModes,\n            onBehalfOf: onBehalfOf,\n            params: params,\n            referralCode: referralCode,\n            flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n            flashLoanPremiumTotal: _flashLoanPremiumTotal,\n            maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n            reservesCount: _reservesCount,\n            addressesProvider: address(ADDRESSES_PROVIDER),\n            userEModeCategory: _usersEModeCategory[onBehalfOf],\n            isAuthorizedFlashBorrower: IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(msg.sender)\n        });\n\n        FlashLoanLogic.executeFlashLoan(\n            _reserves,\n            _reservesList,\n            _eModeCategories,\n            _usersConfig[onBehalfOf],\n            flashParams\n        );\n    }\n\n    /// @inheritdoc IPool\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) public virtual override {\n        DataTypes.FlashloanSimpleParams memory flashParams = DataTypes.FlashloanSimpleParams({\n            receiverAddress: receiverAddress,\n            asset: asset,\n            amount: amount,\n            params: params,\n            referralCode: referralCode,\n            flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n            flashLoanPremiumTotal: _flashLoanPremiumTotal\n        });\n        FlashLoanLogic.executeFlashLoanSimple(_reserves[asset], flashParams);\n    }\n\n    /// @inheritdoc IPool\n    function mintToTreasury(address[] calldata assets) external virtual override {\n        PoolLogic.executeMintToTreasury(_reserves, assets);\n    }\n\n    /// @inheritdoc IPool\n    function getReserveData(address asset) external view virtual override returns (DataTypes.ReserveData memory) {\n        return _reserves[asset];\n    }\n\n    /// @inheritdoc IPool\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        )\n    {\n        return\n            PoolLogic.executeGetUserAccountData(\n                _reserves,\n                _reservesList,\n                _eModeCategories,\n                DataTypes.CalculateUserAccountDataParams({\n                    userConfig: _usersConfig[user],\n                    reservesCount: _reservesCount,\n                    user: user,\n                    oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                    userEModeCategory: _usersEModeCategory[user]\n                })\n            );\n    }\n\n    /// @inheritdoc IPool\n    function getConfiguration(\n        address asset\n    ) external view virtual override returns (DataTypes.ReserveConfigurationMap memory) {\n        return _reserves[asset].configuration;\n    }\n\n    /// @inheritdoc IPool\n    function getUserConfiguration(\n        address user\n    ) external view virtual override returns (DataTypes.UserConfigurationMap memory) {\n        return _usersConfig[user];\n    }\n\n    /// @inheritdoc IPool\n    function getReserveNormalizedIncome(address asset) external view virtual override returns (uint256) {\n        return _reserves[asset].getNormalizedIncome();\n    }\n\n    /// @inheritdoc IPool\n    function getReserveNormalizedVariableDebt(address asset) external view virtual override returns (uint256) {\n        return _reserves[asset].getNormalizedDebt();\n    }\n\n    /// @inheritdoc IPool\n    function getReservesList() external view virtual override returns (address[] memory) {\n        uint256 reservesListCount = _reservesCount;\n        uint256 droppedReservesCount = 0;\n        address[] memory reservesList = new address[](reservesListCount);\n\n        for (uint256 i = 0; i < reservesListCount; i++) {\n            if (_reservesList[i] != address(0)) {\n                reservesList[i - droppedReservesCount] = _reservesList[i];\n            } else {\n                droppedReservesCount++;\n            }\n        }\n\n        // Reduces the length of the reserves array by `droppedReservesCount`\n        assembly {\n            mstore(reservesList, sub(reservesListCount, droppedReservesCount))\n        }\n        return reservesList;\n    }\n\n    /// @inheritdoc IPool\n    function getReserveAddressById(uint16 id) external view returns (address) {\n        return _reservesList[id];\n    }\n\n    /// @inheritdoc IPool\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view virtual override returns (uint256) {\n        return _maxStableRateBorrowSizePercent;\n    }\n\n    /// @inheritdoc IPool\n    function BRIDGE_PROTOCOL_FEE() public view virtual override returns (uint256) {\n        return _bridgeProtocolFee;\n    }\n\n    /// @inheritdoc IPool\n    function FLASHLOAN_PREMIUM_TOTAL() public view virtual override returns (uint128) {\n        return _flashLoanPremiumTotal;\n    }\n\n    /// @inheritdoc IPool\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() public view virtual override returns (uint128) {\n        return _flashLoanPremiumToProtocol;\n    }\n\n    /// @inheritdoc IPool\n    function MAX_NUMBER_RESERVES() public view virtual override returns (uint16) {\n        return ReserveConfiguration.MAX_RESERVES_COUNT;\n    }\n\n    /// @inheritdoc IPool\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external virtual override {\n        require(msg.sender == _reserves[asset].aTokenAddress, Errors.CALLER_NOT_ATOKEN);\n        SupplyLogic.executeFinalizeTransfer(\n            _reserves,\n            _reservesList,\n            _eModeCategories,\n            _usersConfig,\n            DataTypes.FinalizeTransferParams({\n                asset: asset,\n                from: from,\n                to: to,\n                amount: amount,\n                balanceFromBefore: balanceFromBefore,\n                balanceToBefore: balanceToBefore,\n                reservesCount: _reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                fromEModeCategory: _usersEModeCategory[from]\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        if (\n            PoolLogic.executeInitReserve(\n                _reserves,\n                _reservesList,\n                DataTypes.InitReserveParams({\n                    asset: asset,\n                    aTokenAddress: aTokenAddress,\n                    stableDebtAddress: stableDebtAddress,\n                    variableDebtAddress: variableDebtAddress,\n                    interestRateStrategyAddress: interestRateStrategyAddress,\n                    reservesCount: _reservesCount,\n                    maxNumberReserves: MAX_NUMBER_RESERVES()\n                })\n            )\n        ) {\n            _reservesCount++;\n        }\n    }\n\n    /// @inheritdoc IPool\n    function dropReserve(address asset) external virtual override onlyPoolConfigurator {\n        PoolLogic.executeDropReserve(_reserves, _reservesList, asset);\n    }\n\n    /// @inheritdoc IPool\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n        _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n    }\n\n    /// @inheritdoc IPool\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external virtual override onlyPoolConfigurator {\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n        _reserves[asset].configuration = configuration;\n    }\n\n    /// @inheritdoc IPool\n    function updateBridgeProtocolFee(uint256 protocolFee) external virtual override onlyPoolConfigurator {\n        _bridgeProtocolFee = protocolFee;\n    }\n\n    /// @inheritdoc IPool\n    function updateFlashloanPremiums(\n        uint128 flashLoanPremiumTotal,\n        uint128 flashLoanPremiumToProtocol\n    ) external virtual override onlyPoolConfigurator {\n        _flashLoanPremiumTotal = flashLoanPremiumTotal;\n        _flashLoanPremiumToProtocol = flashLoanPremiumToProtocol;\n    }\n\n    /// @inheritdoc IPool\n    function configureEModeCategory(\n        uint8 id,\n        DataTypes.EModeCategory memory category\n    ) external virtual override onlyPoolConfigurator {\n        // category 0 is reserved for volatile heterogeneous assets and it's always disabled\n        require(id != 0, Errors.EMODE_CATEGORY_RESERVED);\n        _eModeCategories[id] = category;\n    }\n\n    /// @inheritdoc IPool\n    function getEModeCategoryData(uint8 id) external view virtual override returns (DataTypes.EModeCategory memory) {\n        return _eModeCategories[id];\n    }\n\n    /// @inheritdoc IPool\n    function setUserEMode(uint8 categoryId) external virtual override {\n        EModeLogic.executeSetUserEMode(\n            _reserves,\n            _reservesList,\n            _eModeCategories,\n            _usersEModeCategory,\n            _usersConfig[msg.sender],\n            DataTypes.ExecuteSetUserEModeParams({\n                reservesCount: _reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                categoryId: categoryId\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function getUserEMode(address user) external view virtual override returns (uint256) {\n        return _usersEModeCategory[user];\n    }\n\n    /// @inheritdoc IPool\n    function resetIsolationModeTotalDebt(address asset) external virtual override onlyPoolConfigurator {\n        PoolLogic.executeResetIsolationModeTotalDebt(_reserves, asset);\n    }\n\n    /// @inheritdoc IPool\n    function rescueTokens(address token, address to, uint256 amount) external virtual override onlyPoolAdmin {\n        PoolLogic.executeRescueTokens(token, to, amount);\n    }\n\n    /// @inheritdoc IPool\n    /// @dev Deprecated: maintained for compatibility purposes\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external virtual override {\n        SupplyLogic.executeSupply(\n            _reserves,\n            _reservesList,\n            _usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf,\n                referralCode: referralCode\n            })\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/pool/PoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { VersionedInitializable } from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { ReserveConfiguration } from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { PercentageMath } from \"../libraries/math/PercentageMath.sol\";\nimport { DataTypes } from \"../libraries/types/DataTypes.sol\";\nimport { ConfiguratorLogic } from \"../libraries/logic/ConfiguratorLogic.sol\";\nimport { ConfiguratorInputTypes } from \"../libraries/types/ConfiguratorInputTypes.sol\";\nimport { IPoolConfigurator } from \"../../interfaces/IPoolConfigurator.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { IPoolDataProvider } from \"../../interfaces/IPoolDataProvider.sol\";\n\n/**\n * @title PoolConfigurator\n * @author Aave\n * @dev Implements the configuration methods for the Aave protocol\n */\ncontract PoolConfigurator is VersionedInitializable, IPoolConfigurator {\n    using PercentageMath for uint256;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    IPoolAddressesProvider internal _addressesProvider;\n    IPool internal _pool;\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     */\n    modifier onlyPoolAdmin() {\n        _onlyPoolAdmin();\n        _;\n    }\n\n    /**\n     * @dev Only emergency admin can call functions marked by this modifier.\n     */\n    modifier onlyEmergencyAdmin() {\n        _onlyEmergencyAdmin();\n        _;\n    }\n\n    /**\n     * @dev Only emergency or pool admin can call functions marked by this modifier.\n     */\n    modifier onlyEmergencyOrPoolAdmin() {\n        _onlyPoolOrEmergencyAdmin();\n        _;\n    }\n\n    /**\n     * @dev Only asset listing or pool admin can call functions marked by this modifier.\n     */\n    modifier onlyAssetListingOrPoolAdmins() {\n        _onlyAssetListingOrPoolAdmins();\n        _;\n    }\n\n    /**\n     * @dev Only risk or pool admin can call functions marked by this modifier.\n     */\n    modifier onlyRiskOrPoolAdmins() {\n        _onlyRiskOrPoolAdmins();\n        _;\n    }\n\n    uint256 public constant CONFIGURATOR_REVISION = 0x1;\n\n    /// @inheritdoc VersionedInitializable\n    function getRevision() internal pure virtual override returns (uint256) {\n        return CONFIGURATOR_REVISION;\n    }\n\n    function initialize(IPoolAddressesProvider provider) public initializer {\n        _addressesProvider = provider;\n        _pool = IPool(_addressesProvider.getPool());\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function initReserves(\n        ConfiguratorInputTypes.InitReserveInput[] calldata input\n    ) external override onlyAssetListingOrPoolAdmins {\n        IPool cachedPool = _pool;\n        for (uint256 i = 0; i < input.length; i++) {\n            ConfiguratorLogic.executeInitReserve(cachedPool, input[i]);\n        }\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function dropReserve(address asset) external override onlyPoolAdmin {\n        _pool.dropReserve(asset);\n        emit ReserveDropped(asset);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external override onlyPoolAdmin {\n        ConfiguratorLogic.executeUpdateAToken(_pool, input);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateStableDebtToken(\n        ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n    ) external override onlyPoolAdmin {\n        ConfiguratorLogic.executeUpdateStableDebtToken(_pool, input);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateVariableDebtToken(\n        ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n    ) external override onlyPoolAdmin {\n        ConfiguratorLogic.executeUpdateVariableDebtToken(_pool, input);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        if (!enabled) {\n            require(!currentConfig.getStableRateBorrowingEnabled(), Errors.STABLE_BORROWING_ENABLED);\n        }\n        currentConfig.setBorrowingEnabled(enabled);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveBorrowing(asset, enabled);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function configureReserveAsCollateral(\n        address asset,\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus\n    ) external override onlyRiskOrPoolAdmins {\n        //validation of the parameters: the LTV can\n        //only be lower or equal than the liquidation threshold\n        //(otherwise a loan against the asset would cause instantaneous liquidation)\n        require(ltv <= liquidationThreshold, Errors.INVALID_RESERVE_PARAMS);\n\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n\n        if (liquidationThreshold != 0) {\n            //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\n            //collateral than needed to cover the debt\n            require(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_PARAMS);\n\n            //if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\n            //a loan is taken there is enough collateral available to cover the liquidation bonus\n            require(\n                liquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\n                Errors.INVALID_RESERVE_PARAMS\n            );\n        } else {\n            require(liquidationBonus == 0, Errors.INVALID_RESERVE_PARAMS);\n            //if the liquidation threshold is being set to 0,\n            // the reserve is being disabled as collateral. To do so,\n            //we need to ensure no liquidity is supplied\n            _checkNoSuppliers(asset);\n        }\n\n        currentConfig.setLtv(ltv);\n        currentConfig.setLiquidationThreshold(liquidationThreshold);\n        currentConfig.setLiquidationBonus(liquidationBonus);\n\n        _pool.setConfiguration(asset, currentConfig);\n\n        emit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveStableRateBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        if (enabled) {\n            require(currentConfig.getBorrowingEnabled(), Errors.BORROWING_NOT_ENABLED);\n        }\n        currentConfig.setStableRateBorrowingEnabled(enabled);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveStableRateBorrowing(asset, enabled);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveFlashLoaning(address asset, bool enabled) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n\n        currentConfig.setFlashLoanEnabled(enabled);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveFlashLoaning(asset, enabled);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveActive(address asset, bool active) external override onlyPoolAdmin {\n        if (!active) _checkNoSuppliers(asset);\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        currentConfig.setActive(active);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveActive(asset, active);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveFreeze(address asset, bool freeze) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        currentConfig.setFrozen(freeze);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveFrozen(asset, freeze);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setBorrowableInIsolation(address asset, bool borrowable) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        currentConfig.setBorrowableInIsolation(borrowable);\n        _pool.setConfiguration(asset, currentConfig);\n        emit BorrowableInIsolationChanged(asset, borrowable);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReservePause(address asset, bool paused) public override onlyEmergencyOrPoolAdmin {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        currentConfig.setPaused(paused);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReservePaused(asset, paused);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveFactor(address asset, uint256 newReserveFactor) external override onlyRiskOrPoolAdmins {\n        require(newReserveFactor <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        uint256 oldReserveFactor = currentConfig.getReserveFactor();\n        currentConfig.setReserveFactor(newReserveFactor);\n        _pool.setConfiguration(asset, currentConfig);\n        emit ReserveFactorChanged(asset, oldReserveFactor, newReserveFactor);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setDebtCeiling(address asset, uint256 newDebtCeiling) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n\n        uint256 oldDebtCeiling = currentConfig.getDebtCeiling();\n        if (oldDebtCeiling == 0) {\n            _checkNoSuppliers(asset);\n        }\n        currentConfig.setDebtCeiling(newDebtCeiling);\n        _pool.setConfiguration(asset, currentConfig);\n\n        if (newDebtCeiling == 0) {\n            _pool.resetIsolationModeTotalDebt(asset);\n        }\n\n        emit DebtCeilingChanged(asset, oldDebtCeiling, newDebtCeiling);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setSiloedBorrowing(address asset, bool newSiloed) external override onlyRiskOrPoolAdmins {\n        if (newSiloed) {\n            _checkNoBorrowers(asset);\n        }\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n\n        bool oldSiloed = currentConfig.getSiloedBorrowing();\n\n        currentConfig.setSiloedBorrowing(newSiloed);\n\n        _pool.setConfiguration(asset, currentConfig);\n\n        emit SiloedBorrowingChanged(asset, oldSiloed, newSiloed);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setBorrowCap(address asset, uint256 newBorrowCap) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        uint256 oldBorrowCap = currentConfig.getBorrowCap();\n        currentConfig.setBorrowCap(newBorrowCap);\n        _pool.setConfiguration(asset, currentConfig);\n        emit BorrowCapChanged(asset, oldBorrowCap, newBorrowCap);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setSupplyCap(address asset, uint256 newSupplyCap) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        uint256 oldSupplyCap = currentConfig.getSupplyCap();\n        currentConfig.setSupplyCap(newSupplyCap);\n        _pool.setConfiguration(asset, currentConfig);\n        emit SupplyCapChanged(asset, oldSupplyCap, newSupplyCap);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setLiquidationProtocolFee(address asset, uint256 newFee) external override onlyRiskOrPoolAdmins {\n        require(newFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        uint256 oldFee = currentConfig.getLiquidationProtocolFee();\n        currentConfig.setLiquidationProtocolFee(newFee);\n        _pool.setConfiguration(asset, currentConfig);\n        emit LiquidationProtocolFeeChanged(asset, oldFee, newFee);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setEModeCategory(\n        uint8 categoryId,\n        uint16 ltv,\n        uint16 liquidationThreshold,\n        uint16 liquidationBonus,\n        address oracle,\n        string calldata label\n    ) external override onlyRiskOrPoolAdmins {\n        require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);\n        require(liquidationThreshold != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);\n\n        // validation of the parameters: the LTV can\n        // only be lower or equal than the liquidation threshold\n        // (otherwise a loan against the asset would cause instantaneous liquidation)\n        require(ltv <= liquidationThreshold, Errors.INVALID_EMODE_CATEGORY_PARAMS);\n        require(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_EMODE_CATEGORY_PARAMS);\n\n        // if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\n        // a loan is taken there is enough collateral available to cover the liquidation bonus\n        require(\n            uint256(liquidationThreshold).percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\n            Errors.INVALID_EMODE_CATEGORY_PARAMS\n        );\n\n        address[] memory reserves = _pool.getReservesList();\n        for (uint256 i = 0; i < reserves.length; i++) {\n            DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(reserves[i]);\n            if (categoryId == currentConfig.getEModeCategory()) {\n                require(ltv > currentConfig.getLtv(), Errors.INVALID_EMODE_CATEGORY_PARAMS);\n                require(\n                    liquidationThreshold > currentConfig.getLiquidationThreshold(),\n                    Errors.INVALID_EMODE_CATEGORY_PARAMS\n                );\n            }\n        }\n\n        _pool.configureEModeCategory(\n            categoryId,\n            DataTypes.EModeCategory({\n                ltv: ltv,\n                liquidationThreshold: liquidationThreshold,\n                liquidationBonus: liquidationBonus,\n                priceSource: oracle,\n                label: label\n            })\n        );\n        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setAssetEModeCategory(address asset, uint8 newCategoryId) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n\n        if (newCategoryId != 0) {\n            DataTypes.EModeCategory memory categoryData = _pool.getEModeCategoryData(newCategoryId);\n            require(\n                categoryData.liquidationThreshold > currentConfig.getLiquidationThreshold(),\n                Errors.INVALID_EMODE_CATEGORY_ASSIGNMENT\n            );\n        }\n        uint256 oldCategoryId = currentConfig.getEModeCategory();\n        currentConfig.setEModeCategory(newCategoryId);\n        _pool.setConfiguration(asset, currentConfig);\n        emit EModeAssetCategoryChanged(asset, uint8(oldCategoryId), newCategoryId);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n        uint256 oldUnbackedMintCap = currentConfig.getUnbackedMintCap();\n        currentConfig.setUnbackedMintCap(newUnbackedMintCap);\n        _pool.setConfiguration(asset, currentConfig);\n        emit UnbackedMintCapChanged(asset, oldUnbackedMintCap, newUnbackedMintCap);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address newRateStrategyAddress\n    ) external override onlyRiskOrPoolAdmins {\n        DataTypes.ReserveData memory reserve = _pool.getReserveData(asset);\n        address oldRateStrategyAddress = reserve.interestRateStrategyAddress;\n        _pool.setReserveInterestRateStrategyAddress(asset, newRateStrategyAddress);\n        emit ReserveInterestRateStrategyChanged(asset, oldRateStrategyAddress, newRateStrategyAddress);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function setPoolPause(bool paused) external override onlyEmergencyAdmin {\n        address[] memory reserves = _pool.getReservesList();\n\n        for (uint256 i = 0; i < reserves.length; i++) {\n            if (reserves[i] != address(0)) {\n                setReservePause(reserves[i], paused);\n            }\n        }\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external override onlyPoolAdmin {\n        require(newBridgeProtocolFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.BRIDGE_PROTOCOL_FEE_INVALID);\n        uint256 oldBridgeProtocolFee = _pool.BRIDGE_PROTOCOL_FEE();\n        _pool.updateBridgeProtocolFee(newBridgeProtocolFee);\n        emit BridgeProtocolFeeUpdated(oldBridgeProtocolFee, newBridgeProtocolFee);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external override onlyPoolAdmin {\n        require(newFlashloanPremiumTotal <= PercentageMath.PERCENTAGE_FACTOR, Errors.FLASHLOAN_PREMIUM_INVALID);\n        uint128 oldFlashloanPremiumTotal = _pool.FLASHLOAN_PREMIUM_TOTAL();\n        _pool.updateFlashloanPremiums(newFlashloanPremiumTotal, _pool.FLASHLOAN_PREMIUM_TO_PROTOCOL());\n        emit FlashloanPremiumTotalUpdated(oldFlashloanPremiumTotal, newFlashloanPremiumTotal);\n    }\n\n    /// @inheritdoc IPoolConfigurator\n    function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external override onlyPoolAdmin {\n        require(newFlashloanPremiumToProtocol <= PercentageMath.PERCENTAGE_FACTOR, Errors.FLASHLOAN_PREMIUM_INVALID);\n        uint128 oldFlashloanPremiumToProtocol = _pool.FLASHLOAN_PREMIUM_TO_PROTOCOL();\n        _pool.updateFlashloanPremiums(_pool.FLASHLOAN_PREMIUM_TOTAL(), newFlashloanPremiumToProtocol);\n        emit FlashloanPremiumToProtocolUpdated(oldFlashloanPremiumToProtocol, newFlashloanPremiumToProtocol);\n    }\n\n    function _checkNoSuppliers(address asset) internal view {\n        (, uint256 accruedToTreasury, uint256 totalATokens, , , , , , , , , ) = IPoolDataProvider(\n            _addressesProvider.getPoolDataProvider()\n        ).getReserveData(asset);\n\n        require(totalATokens == 0 && accruedToTreasury == 0, Errors.RESERVE_LIQUIDITY_NOT_ZERO);\n    }\n\n    function _checkNoBorrowers(address asset) internal view {\n        uint256 totalDebt = IPoolDataProvider(_addressesProvider.getPoolDataProvider()).getTotalDebt(asset);\n        require(totalDebt == 0, Errors.RESERVE_DEBT_NOT_ZERO);\n    }\n\n    function _onlyPoolAdmin() internal view {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(aclManager.isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);\n    }\n\n    function _onlyEmergencyAdmin() internal view {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(aclManager.isEmergencyAdmin(msg.sender), Errors.CALLER_NOT_EMERGENCY_ADMIN);\n    }\n\n    function _onlyPoolOrEmergencyAdmin() internal view {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(\n            aclManager.isPoolAdmin(msg.sender) || aclManager.isEmergencyAdmin(msg.sender),\n            Errors.CALLER_NOT_POOL_OR_EMERGENCY_ADMIN\n        );\n    }\n\n    function _onlyAssetListingOrPoolAdmins() internal view {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(\n            aclManager.isAssetListingAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN\n        );\n    }\n\n    function _onlyRiskOrPoolAdmins() internal view {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(\n            aclManager.isRiskAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_RISK_OR_POOL_ADMIN\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/pool/PoolStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { UserConfiguration } from \"../libraries/configuration/UserConfiguration.sol\";\nimport { ReserveConfiguration } from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport { ReserveLogic } from \"../libraries/logic/ReserveLogic.sol\";\nimport { DataTypes } from \"../libraries/types/DataTypes.sol\";\n\n/**\n * @title PoolStorage\n * @author Aave\n * @notice Contract used as storage of the Pool contract.\n * @dev It defines the storage layout of the Pool contract.\n */\ncontract PoolStorage {\n    using ReserveLogic for DataTypes.ReserveData;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    // Map of reserves and their data (underlyingAssetOfReserve => reserveData)\n    mapping(address => DataTypes.ReserveData) internal _reserves;\n\n    // Map of users address and their configuration data (userAddress => userConfiguration)\n    mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\n\n    // List of reserves as a map (reserveId => reserve).\n    // It is structured as a mapping for gas savings reasons, using the reserve id as index\n    mapping(uint256 => address) internal _reservesList;\n\n    // List of eMode categories as a map (eModeCategoryId => eModeCategory).\n    // It is structured as a mapping for gas savings reasons, using the eModeCategoryId as index\n    mapping(uint8 => DataTypes.EModeCategory) internal _eModeCategories;\n\n    // Map of users address and their eMode category (userAddress => eModeCategoryId)\n    mapping(address => uint8) internal _usersEModeCategory;\n\n    // Fee of the protocol bridge, expressed in bps\n    uint256 internal _bridgeProtocolFee;\n\n    // Total FlashLoan Premium, expressed in bps\n    uint128 internal _flashLoanPremiumTotal;\n\n    // FlashLoan premium paid to protocol treasury, expressed in bps\n    uint128 internal _flashLoanPremiumToProtocol;\n\n    // Available liquidity that can be borrowed at once at stable rate, expressed in bps\n    uint64 internal _maxStableRateBorrowSizePercent;\n\n    // Maximum number of active reserves there have been in the protocol. It is the upper bound of the reserves list\n    uint16 internal _reservesCount;\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/AToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { GPv2SafeERC20 } from \"../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { SafeCast } from \"../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { VersionedInitializable } from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { WadRayMath } from \"../libraries/math/WadRayMath.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IAToken } from \"../../interfaces/IAToken.sol\";\nimport { IAaveIncentivesController } from \"../../interfaces/IAaveIncentivesController.sol\";\nimport { IInitializableAToken } from \"../../interfaces/IInitializableAToken.sol\";\nimport { ScaledBalanceTokenBase } from \"./base/ScaledBalanceTokenBase.sol\";\nimport { IncentivizedERC20 } from \"./base/IncentivizedERC20.sol\";\nimport { EIP712Base } from \"./base/EIP712Base.sol\";\n\n/**\n * @title Aave ERC20 AToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IAToken {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n    using GPv2SafeERC20 for IERC20;\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 public constant ATOKEN_REVISION = 0x1;\n\n    address internal _treasury;\n    address internal _underlyingAsset;\n\n    /// @inheritdoc VersionedInitializable\n    function getRevision() internal pure virtual override returns (uint256) {\n        return ATOKEN_REVISION;\n    }\n\n    /**\n     * @dev Constructor.\n     * @param pool The address of the Pool contract\n     */\n    constructor(IPool pool) ScaledBalanceTokenBase(pool, \"ATOKEN_IMPL\", \"ATOKEN_IMPL\", 0) EIP712Base() {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IInitializableAToken\n    function initialize(\n        IPool initializingPool,\n        address treasury,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 aTokenDecimals,\n        string calldata aTokenName,\n        string calldata aTokenSymbol,\n        bytes calldata params\n    ) public virtual override initializer {\n        require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n        _setName(aTokenName);\n        _setSymbol(aTokenSymbol);\n        _setDecimals(aTokenDecimals);\n\n        _treasury = treasury;\n        _underlyingAsset = underlyingAsset;\n        _incentivesController = incentivesController;\n\n        _domainSeparator = _calculateDomainSeparator();\n\n        emit Initialized(\n            underlyingAsset,\n            address(POOL),\n            treasury,\n            address(incentivesController),\n            aTokenDecimals,\n            aTokenName,\n            aTokenSymbol,\n            params\n        );\n    }\n\n    /// @inheritdoc IAToken\n    function mint(\n        address caller,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 index\n    ) external virtual override onlyPool returns (bool) {\n        return _mintScaled(caller, onBehalfOf, amount, index);\n    }\n\n    /// @inheritdoc IAToken\n    function burn(\n        address from,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external virtual override onlyPool {\n        _burnScaled(from, receiverOfUnderlying, amount, index);\n        if (receiverOfUnderlying != address(this)) {\n            IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n        }\n    }\n\n    /// @inheritdoc IAToken\n    function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n        if (amount == 0) {\n            return;\n        }\n        _mintScaled(address(POOL), _treasury, amount, index);\n    }\n\n    /// @inheritdoc IAToken\n    function transferOnLiquidation(address from, address to, uint256 value) external virtual override onlyPool {\n        // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n        // so no need to emit a specific event here\n        _transfer(from, to, value, false);\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address user) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n        return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n\n        if (currentSupplyScaled == 0) {\n            return 0;\n        }\n\n        return currentSupplyScaled.rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));\n    }\n\n    /// @inheritdoc IAToken\n    function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n        return _treasury;\n    }\n\n    /// @inheritdoc IAToken\n    function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n        return _underlyingAsset;\n    }\n\n    /// @inheritdoc IAToken\n    function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n        IERC20(_underlyingAsset).safeTransfer(target, amount);\n    }\n\n    /// @inheritdoc IAToken\n    function handleRepayment(address user, address onBehalfOf, uint256 amount) external virtual override onlyPool {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IAToken\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        //solium-disable-next-line\n        require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);\n        uint256 currentValidNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);\n        _nonces[owner] = currentValidNonce + 1;\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Transfers the aTokens between two users. Validates the transfer\n     * (ie checks for valid HF after the transfer) if required\n     * @param from The source address\n     * @param to The destination address\n     * @param amount The amount getting transferred\n     * @param validate True if the transfer needs to be validated, false otherwise\n     */\n    function _transfer(address from, address to, uint256 amount, bool validate) internal virtual {\n        address underlyingAsset = _underlyingAsset;\n\n        uint256 index = POOL.getReserveNormalizedIncome(underlyingAsset);\n\n        uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n        uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n        super._transfer(from, to, amount, index);\n\n        if (validate) {\n            POOL.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n        }\n\n        emit BalanceTransfer(from, to, amount.rayDiv(index), index);\n    }\n\n    /**\n     * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n     * @param from The source address\n     * @param to The destination address\n     * @param amount The amount getting transferred\n     */\n    function _transfer(address from, address to, uint128 amount) internal virtual override {\n        _transfer(from, to, amount, true);\n    }\n\n    /**\n     * @dev Overrides the base function to fully implement IAToken\n     * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n     */\n    function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n        return super.DOMAIN_SEPARATOR();\n    }\n\n    /**\n     * @dev Overrides the base function to fully implement IAToken\n     * @dev see `EIP712Base.nonces()` for more detailed documentation\n     */\n    function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc EIP712Base\n    function _EIP712BaseId() internal view override returns (string memory) {\n        return name();\n    }\n\n    /// @inheritdoc IAToken\n    function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n        require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/base/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Context } from \"../../../dependencies/openzeppelin/contracts/Context.sol\";\nimport { Errors } from \"../../libraries/helpers/Errors.sol\";\nimport { VersionedInitializable } from \"../../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { ICreditDelegationToken } from \"../../../interfaces/ICreditDelegationToken.sol\";\nimport { EIP712Base } from \"./EIP712Base.sol\";\n\n/**\n * @title DebtTokenBase\n * @author Aave\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\n */\nabstract contract DebtTokenBase is VersionedInitializable, EIP712Base, Context, ICreditDelegationToken {\n    // Map of borrow allowances (delegator => delegatee => borrowAllowanceAmount)\n    mapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n    // Credit Delegation Typehash\n    bytes32 public constant DELEGATION_WITH_SIG_TYPEHASH =\n        keccak256(\"DelegationWithSig(address delegatee,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    address internal _underlyingAsset;\n\n    /**\n     * @dev Constructor.\n     */\n    constructor() EIP712Base() {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc ICreditDelegationToken\n    function approveDelegation(address delegatee, uint256 amount) external override {\n        _approveDelegation(_msgSender(), delegatee, amount);\n    }\n\n    /// @inheritdoc ICreditDelegationToken\n    function delegationWithSig(\n        address delegator,\n        address delegatee,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        //solium-disable-next-line\n        require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);\n        uint256 currentValidNonce = _nonces[delegator];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline))\n            )\n        );\n        require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);\n        _nonces[delegator] = currentValidNonce + 1;\n        _approveDelegation(delegator, delegatee, value);\n    }\n\n    /// @inheritdoc ICreditDelegationToken\n    function borrowAllowance(address fromUser, address toUser) external view override returns (uint256) {\n        return _borrowAllowances[fromUser][toUser];\n    }\n\n    /**\n     * @notice Updates the borrow allowance of a user on the specific debt token.\n     * @param delegator The address delegating the borrowing power\n     * @param delegatee The address receiving the delegated borrowing power\n     * @param amount The allowance amount being delegated.\n     */\n    function _approveDelegation(address delegator, address delegatee, uint256 amount) internal {\n        _borrowAllowances[delegator][delegatee] = amount;\n        emit BorrowAllowanceDelegated(delegator, delegatee, _underlyingAsset, amount);\n    }\n\n    /**\n     * @notice Decreases the borrow allowance of a user on the specific debt token.\n     * @param delegator The address delegating the borrowing power\n     * @param delegatee The address receiving the delegated borrowing power\n     * @param amount The amount to subtract from the current allowance\n     */\n    function _decreaseBorrowAllowance(address delegator, address delegatee, uint256 amount) internal {\n        uint256 newAllowance = _borrowAllowances[delegator][delegatee] - amount;\n\n        _borrowAllowances[delegator][delegatee] = newAllowance;\n\n        emit BorrowAllowanceDelegated(delegator, delegatee, _underlyingAsset, newAllowance);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/base/EIP712Base.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title EIP712Base\n * @author Aave\n * @notice Base contract implementation of EIP712.\n */\nabstract contract EIP712Base {\n    bytes public constant EIP712_REVISION = bytes(\"1\");\n    bytes32 internal constant EIP712_DOMAIN =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Map of address nonces (address => nonce)\n    mapping(address => uint256) internal _nonces;\n\n    bytes32 internal _domainSeparator;\n    uint256 internal immutable _chainId;\n\n    /**\n     * @dev Constructor.\n     */\n    constructor() {\n        _chainId = block.chainid;\n    }\n\n    /**\n     * @notice Get the domain separator for the token\n     * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n     * @return The domain separator of the token at current chain\n     */\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        if (block.chainid == _chainId) {\n            return _domainSeparator;\n        }\n        return _calculateDomainSeparator();\n    }\n\n    /**\n     * @notice Returns the nonce value for address specified as parameter\n     * @param owner The address for which the nonce is being returned\n     * @return The nonce value for the input address`\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @notice Compute the current domain separator\n     * @return The domain separator for the token\n     */\n    function _calculateDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN,\n                    keccak256(bytes(_EIP712BaseId())),\n                    keccak256(EIP712_REVISION),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the user readable name of signing domain (e.g. token name)\n     * @return The name of the signing domain\n     */\n    function _EIP712BaseId() internal view virtual returns (string memory);\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/base/IncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Context } from \"../../../dependencies/openzeppelin/contracts/Context.sol\";\nimport { IERC20 } from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IERC20Detailed } from \"../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { WadRayMath } from \"../../libraries/math/WadRayMath.sol\";\nimport { Errors } from \"../../libraries/helpers/Errors.sol\";\nimport { IAaveIncentivesController } from \"../../../interfaces/IAaveIncentivesController.sol\";\nimport { IPoolAddressesProvider } from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"../../../interfaces/IPool.sol\";\nimport { IACLManager } from \"../../../interfaces/IACLManager.sol\";\n\n/**\n * @title IncentivizedERC20\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\n * @notice Basic ERC20 implementation\n */\nabstract contract IncentivizedERC20 is Context, IERC20Detailed {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     */\n    modifier onlyPoolAdmin() {\n        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n        require(aclManager.isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);\n        _;\n    }\n\n    /**\n     * @dev Only pool can call functions marked by this modifier.\n     */\n    modifier onlyPool() {\n        require(_msgSender() == address(POOL), Errors.CALLER_MUST_BE_POOL);\n        _;\n    }\n\n    /**\n     * @dev UserState - additionalData is a flexible field.\n     * ATokens and VariableDebtTokens use this field store the index of the\n     * user's last supply/withdrawal/borrow/repayment. StableDebtTokens use\n     * this field to store the user's stable rate.\n     */\n    struct UserState {\n        uint128 balance;\n        uint128 additionalData;\n    }\n    // Map of users address and their state data (userAddress => userStateData)\n    mapping(address => UserState) internal _userState;\n\n    // Map of allowances (delegator => delegatee => allowanceAmount)\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    IAaveIncentivesController internal _incentivesController;\n    IPoolAddressesProvider internal immutable _addressesProvider;\n    IPool public immutable POOL;\n\n    /**\n     * @dev Constructor.\n     * @param pool The reference to the main Pool contract\n     * @param tokenName The name of the token\n     * @param tokenSymbol The symbol of the token\n     * @param tokenDecimals The number of decimals of the token\n     */\n    constructor(IPool pool, string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {\n        _addressesProvider = pool.ADDRESSES_PROVIDER();\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = tokenDecimals;\n        POOL = pool;\n    }\n\n    /// @inheritdoc IERC20Detailed\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /// @inheritdoc IERC20Detailed\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IERC20Detailed\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _userState[account].balance;\n    }\n\n    /**\n     * @notice Returns the address of the Incentives Controller contract\n     * @return The address of the Incentives Controller\n     */\n    function getIncentivesController() external view virtual returns (IAaveIncentivesController) {\n        return _incentivesController;\n    }\n\n    /**\n     * @notice Sets a new Incentives Controller\n     * @param controller the new Incentives controller\n     */\n    function setIncentivesController(IAaveIncentivesController controller) external onlyPoolAdmin {\n        _incentivesController = controller;\n    }\n\n    /// @inheritdoc IERC20\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        uint128 castAmount = amount.toUint128();\n        _transfer(_msgSender(), recipient, castAmount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        uint128 castAmount = amount.toUint128();\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - castAmount);\n        _transfer(sender, recipient, castAmount);\n        return true;\n    }\n\n    /**\n     * @notice Increases the allowance of spender to spend _msgSender() tokens\n     * @param spender The user allowed to spend on behalf of _msgSender()\n     * @param addedValue The amount being added to the allowance\n     * @return `true`\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Decreases the allowance of spender to spend _msgSender() tokens\n     * @param spender The user allowed to spend on behalf of _msgSender()\n     * @param subtractedValue The amount being subtracted to the allowance\n     * @return `true`\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @notice Transfers tokens between two users and apply incentives if defined.\n     * @param sender The source address\n     * @param recipient The destination address\n     * @param amount The amount getting transferred\n     */\n    function _transfer(address sender, address recipient, uint128 amount) internal virtual {\n        uint128 oldSenderBalance = _userState[sender].balance;\n        _userState[sender].balance = oldSenderBalance - amount;\n        uint128 oldRecipientBalance = _userState[recipient].balance;\n        _userState[recipient].balance = oldRecipientBalance + amount;\n\n        IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n        if (address(incentivesControllerLocal) != address(0)) {\n            uint256 currentTotalSupply = _totalSupply;\n            incentivesControllerLocal.handleAction(sender, currentTotalSupply, oldSenderBalance);\n            if (sender != recipient) {\n                incentivesControllerLocal.handleAction(recipient, currentTotalSupply, oldRecipientBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Approve `spender` to use `amount` of `owner`s balance\n     * @param owner The address owning the tokens\n     * @param spender The address approved for spending\n     * @param amount The amount of tokens to approve spending of\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Update the name of the token\n     * @param newName The new name for the token\n     */\n    function _setName(string memory newName) internal {\n        _name = newName;\n    }\n\n    /**\n     * @notice Update the symbol for the token\n     * @param newSymbol The new symbol for the token\n     */\n    function _setSymbol(string memory newSymbol) internal {\n        _symbol = newSymbol;\n    }\n\n    /**\n     * @notice Update the number of decimals for the token\n     * @param newDecimals The new number of decimals for the token\n     */\n    function _setDecimals(uint8 newDecimals) internal {\n        _decimals = newDecimals;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/base/MintableIncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveIncentivesController } from \"../../../interfaces/IAaveIncentivesController.sol\";\nimport { IPool } from \"../../../interfaces/IPool.sol\";\nimport { IncentivizedERC20 } from \"./IncentivizedERC20.sol\";\n\n/**\n * @title MintableIncentivizedERC20\n * @author Aave\n * @notice Implements mint and burn functions for IncentivizedERC20\n */\nabstract contract MintableIncentivizedERC20 is IncentivizedERC20 {\n    /**\n     * @dev Constructor.\n     * @param pool The reference to the main Pool contract\n     * @param name The name of the token\n     * @param symbol The symbol of the token\n     * @param decimals The number of decimals of the token\n     */\n    constructor(\n        IPool pool,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) IncentivizedERC20(pool, name, symbol, decimals) {\n        // Intentionally left blank\n    }\n\n    /**\n     * @notice Mints tokens to an account and apply incentives if defined\n     * @param account The address receiving tokens\n     * @param amount The amount of tokens to mint\n     */\n    function _mint(address account, uint128 amount) internal virtual {\n        uint256 oldTotalSupply = _totalSupply;\n        _totalSupply = oldTotalSupply + amount;\n\n        uint128 oldAccountBalance = _userState[account].balance;\n        _userState[account].balance = oldAccountBalance + amount;\n\n        IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n        if (address(incentivesControllerLocal) != address(0)) {\n            incentivesControllerLocal.handleAction(account, oldTotalSupply, oldAccountBalance);\n        }\n    }\n\n    /**\n     * @notice Burns tokens from an account and apply incentives if defined\n     * @param account The account whose tokens are burnt\n     * @param amount The amount of tokens to burn\n     */\n    function _burn(address account, uint128 amount) internal virtual {\n        uint256 oldTotalSupply = _totalSupply;\n        _totalSupply = oldTotalSupply - amount;\n\n        uint128 oldAccountBalance = _userState[account].balance;\n        _userState[account].balance = oldAccountBalance - amount;\n\n        IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n\n        if (address(incentivesControllerLocal) != address(0)) {\n            incentivesControllerLocal.handleAction(account, oldTotalSupply, oldAccountBalance);\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/base/ScaledBalanceTokenBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { Errors } from \"../../libraries/helpers/Errors.sol\";\nimport { WadRayMath } from \"../../libraries/math/WadRayMath.sol\";\nimport { IPool } from \"../../../interfaces/IPool.sol\";\nimport { IScaledBalanceToken } from \"../../../interfaces/IScaledBalanceToken.sol\";\nimport { MintableIncentivizedERC20 } from \"./MintableIncentivizedERC20.sol\";\n\n/**\n * @title ScaledBalanceTokenBase\n * @author Aave\n * @notice Basic ERC20 implementation of scaled balance token\n */\nabstract contract ScaledBalanceTokenBase is MintableIncentivizedERC20, IScaledBalanceToken {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev Constructor.\n     * @param pool The reference to the main Pool contract\n     * @param name The name of the token\n     * @param symbol The symbol of the token\n     * @param decimals The number of decimals of the token\n     */\n    constructor(\n        IPool pool,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) MintableIncentivizedERC20(pool, name, symbol, decimals) {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IScaledBalanceToken\n    function scaledBalanceOf(address user) external view override returns (uint256) {\n        return super.balanceOf(user);\n    }\n\n    /// @inheritdoc IScaledBalanceToken\n    function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n        return (super.balanceOf(user), super.totalSupply());\n    }\n\n    /// @inheritdoc IScaledBalanceToken\n    function scaledTotalSupply() public view virtual override returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /// @inheritdoc IScaledBalanceToken\n    function getPreviousIndex(address user) external view virtual override returns (uint256) {\n        return _userState[user].additionalData;\n    }\n\n    /**\n     * @notice Implements the basic logic to mint a scaled balance token.\n     * @param caller The address performing the mint\n     * @param onBehalfOf The address of the user that will receive the scaled tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The next liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function _mintScaled(address caller, address onBehalfOf, uint256 amount, uint256 index) internal returns (bool) {\n        uint256 amountScaled = amount.rayDiv(index);\n        require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT);\n\n        uint256 scaledBalance = super.balanceOf(onBehalfOf);\n        uint256 balanceIncrease = scaledBalance.rayMul(index) -\n            scaledBalance.rayMul(_userState[onBehalfOf].additionalData);\n\n        _userState[onBehalfOf].additionalData = index.toUint128();\n\n        _mint(onBehalfOf, amountScaled.toUint128());\n\n        uint256 amountToMint = amount + balanceIncrease;\n        emit Transfer(address(0), onBehalfOf, amountToMint);\n        emit Mint(caller, onBehalfOf, amountToMint, balanceIncrease, index);\n\n        return (scaledBalance == 0);\n    }\n\n    /**\n     * @notice Implements the basic logic to burn a scaled balance token.\n     * @dev In some instances, a burn transaction will emit a mint event\n     * if the amount to burn is less than the interest that the user accrued\n     * @param user The user which debt is burnt\n     * @param target The address that will receive the underlying, if any\n     * @param amount The amount getting burned\n     * @param index The variable debt index of the reserve\n     */\n    function _burnScaled(address user, address target, uint256 amount, uint256 index) internal {\n        uint256 amountScaled = amount.rayDiv(index);\n        require(amountScaled != 0, Errors.INVALID_BURN_AMOUNT);\n\n        uint256 scaledBalance = super.balanceOf(user);\n        uint256 balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[user].additionalData);\n\n        _userState[user].additionalData = index.toUint128();\n\n        _burn(user, amountScaled.toUint128());\n\n        if (balanceIncrease > amount) {\n            uint256 amountToMint = balanceIncrease - amount;\n            emit Transfer(address(0), user, amountToMint);\n            emit Mint(user, user, amountToMint, balanceIncrease, index);\n        } else {\n            uint256 amountToBurn = amount - balanceIncrease;\n            emit Transfer(user, address(0), amountToBurn);\n            emit Burn(user, target, amountToBurn, balanceIncrease, index);\n        }\n    }\n\n    /**\n     * @notice Implements the basic logic to transfer scaled balance tokens between two users\n     * @dev It emits a mint event with the interest accrued per user\n     * @param sender The source address\n     * @param recipient The destination address\n     * @param amount The amount getting transferred\n     * @param index The next liquidity index of the reserve\n     */\n    function _transfer(address sender, address recipient, uint256 amount, uint256 index) internal {\n        uint256 senderScaledBalance = super.balanceOf(sender);\n        uint256 senderBalanceIncrease = senderScaledBalance.rayMul(index) -\n            senderScaledBalance.rayMul(_userState[sender].additionalData);\n\n        uint256 recipientScaledBalance = super.balanceOf(recipient);\n        uint256 recipientBalanceIncrease = recipientScaledBalance.rayMul(index) -\n            recipientScaledBalance.rayMul(_userState[recipient].additionalData);\n\n        _userState[sender].additionalData = index.toUint128();\n        _userState[recipient].additionalData = index.toUint128();\n\n        super._transfer(sender, recipient, amount.rayDiv(index).toUint128());\n\n        if (senderBalanceIncrease > 0) {\n            emit Transfer(address(0), sender, senderBalanceIncrease);\n            emit Mint(_msgSender(), sender, senderBalanceIncrease, senderBalanceIncrease, index);\n        }\n\n        if (sender != recipient && recipientBalanceIncrease > 0) {\n            emit Transfer(address(0), recipient, recipientBalanceIncrease);\n            emit Mint(_msgSender(), recipient, recipientBalanceIncrease, recipientBalanceIncrease, index);\n        }\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/DelegationAwareAToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IDelegationToken } from \"../../interfaces/IDelegationToken.sol\";\nimport { AToken } from \"./AToken.sol\";\n\n/**\n * @title DelegationAwareAToken\n * @author Aave\n * @notice AToken enabled to delegate voting power of the underlying asset to a different address\n * @dev The underlying asset needs to be compatible with the COMP delegation interface\n */\ncontract DelegationAwareAToken is AToken {\n    /**\n     * @dev Emitted when underlying voting power is delegated\n     * @param delegatee The address of the delegatee\n     */\n    event DelegateUnderlyingTo(address indexed delegatee);\n\n    /**\n     * @dev Constructor.\n     * @param pool The address of the Pool contract\n     */\n    constructor(IPool pool) AToken(pool) {\n        // Intentionally left blank\n    }\n\n    /**\n     * @notice Delegates voting power of the underlying asset to a `delegatee` address\n     * @param delegatee The address that will receive the delegation\n     */\n    function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin {\n        IDelegationToken(_underlyingAsset).delegate(delegatee);\n        emit DelegateUnderlyingTo(delegatee);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { VersionedInitializable } from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { MathUtils } from \"../libraries/math/MathUtils.sol\";\nimport { WadRayMath } from \"../libraries/math/WadRayMath.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { IAaveIncentivesController } from \"../../interfaces/IAaveIncentivesController.sol\";\nimport { IInitializableDebtToken } from \"../../interfaces/IInitializableDebtToken.sol\";\nimport { IStableDebtToken } from \"../../interfaces/IStableDebtToken.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { EIP712Base } from \"./base/EIP712Base.sol\";\nimport { DebtTokenBase } from \"./base/DebtTokenBase.sol\";\nimport { IncentivizedERC20 } from \"./base/IncentivizedERC20.sol\";\nimport { SafeCast } from \"../../dependencies/openzeppelin/contracts/SafeCast.sol\";\n\n/**\n * @title StableDebtToken\n * @author Aave\n * @notice Implements a stable debt token to track the borrowing positions of users\n * at stable rate mode\n * @dev Transfer and approve functionalities are disabled since its a non-transferable token\n */\ncontract StableDebtToken is DebtTokenBase, IncentivizedERC20, IStableDebtToken {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n    // Map of users address and the timestamp of their last update (userAddress => lastUpdateTimestamp)\n    mapping(address => uint40) internal _timestamps;\n\n    uint128 internal _avgStableRate;\n\n    // Timestamp of the last update of the total supply\n    uint40 internal _totalSupplyTimestamp;\n\n    /**\n     * @dev Constructor.\n     * @param pool The address of the Pool contract\n     */\n    constructor(\n        IPool pool\n    ) DebtTokenBase() IncentivizedERC20(pool, \"STABLE_DEBT_TOKEN_IMPL\", \"STABLE_DEBT_TOKEN_IMPL\", 0) {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IInitializableDebtToken\n    function initialize(\n        IPool initializingPool,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 debtTokenDecimals,\n        string memory debtTokenName,\n        string memory debtTokenSymbol,\n        bytes calldata params\n    ) external override initializer {\n        require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n        _setName(debtTokenName);\n        _setSymbol(debtTokenSymbol);\n        _setDecimals(debtTokenDecimals);\n\n        _underlyingAsset = underlyingAsset;\n        _incentivesController = incentivesController;\n\n        _domainSeparator = _calculateDomainSeparator();\n\n        emit Initialized(\n            underlyingAsset,\n            address(POOL),\n            address(incentivesController),\n            debtTokenDecimals,\n            debtTokenName,\n            debtTokenSymbol,\n            params\n        );\n    }\n\n    /// @inheritdoc VersionedInitializable\n    function getRevision() internal pure virtual override returns (uint256) {\n        return DEBT_TOKEN_REVISION;\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getAverageStableRate() external view virtual override returns (uint256) {\n        return _avgStableRate;\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getUserLastUpdated(address user) external view virtual override returns (uint40) {\n        return _timestamps[user];\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getUserStableRate(address user) external view virtual override returns (uint256) {\n        return _userState[user].additionalData;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        uint256 accountBalance = super.balanceOf(account);\n        uint256 stableRate = _userState[account].additionalData;\n        if (accountBalance == 0) {\n            return 0;\n        }\n        uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\n        return accountBalance.rayMul(cumulatedInterest);\n    }\n\n    struct MintLocalVars {\n        uint256 previousSupply;\n        uint256 nextSupply;\n        uint256 amountInRay;\n        uint256 currentStableRate;\n        uint256 nextStableRate;\n        uint256 currentAvgStableRate;\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 rate\n    ) external virtual override onlyPool returns (bool, uint256, uint256) {\n        MintLocalVars memory vars;\n\n        if (user != onBehalfOf) {\n            _decreaseBorrowAllowance(onBehalfOf, user, amount);\n        }\n\n        (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n\n        vars.previousSupply = totalSupply();\n        vars.currentAvgStableRate = _avgStableRate;\n        vars.nextSupply = _totalSupply = vars.previousSupply + amount;\n\n        vars.amountInRay = amount.wadToRay();\n\n        vars.currentStableRate = _userState[onBehalfOf].additionalData;\n        vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) + vars.amountInRay.rayMul(rate))\n            .rayDiv((currentBalance + amount).wadToRay());\n\n        _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();\n\n        //solium-disable-next-line\n        _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n\n        // Calculates the updated average stable rate\n        vars.currentAvgStableRate = _avgStableRate = (\n            (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) + rate.rayMul(vars.amountInRay)).rayDiv(\n                vars.nextSupply.wadToRay()\n            )\n        ).toUint128();\n\n        uint256 amountToMint = amount + balanceIncrease;\n        _mint(onBehalfOf, amountToMint, vars.previousSupply);\n\n        emit Transfer(address(0), onBehalfOf, amountToMint);\n        emit Mint(\n            user,\n            onBehalfOf,\n            amountToMint,\n            currentBalance,\n            balanceIncrease,\n            vars.nextStableRate,\n            vars.currentAvgStableRate,\n            vars.nextSupply\n        );\n\n        return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function burn(address from, uint256 amount) external virtual override onlyPool returns (uint256, uint256) {\n        (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);\n\n        uint256 previousSupply = totalSupply();\n        uint256 nextAvgStableRate = 0;\n        uint256 nextSupply = 0;\n        uint256 userStableRate = _userState[from].additionalData;\n\n        // Since the total supply and each single user debt accrue separately,\n        // there might be accumulation errors so that the last borrower repaying\n        // might actually try to repay more than the available debt supply.\n        // In this case we simply set the total supply and the avg stable rate to 0\n        if (previousSupply <= amount) {\n            _avgStableRate = 0;\n            _totalSupply = 0;\n        } else {\n            nextSupply = _totalSupply = previousSupply - amount;\n            uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());\n            uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n            // For the same reason described above, when the last user is repaying it might\n            // happen that user rate * user balance > avg rate * total supply. In that case,\n            // we simply set the avg rate to 0\n            if (secondTerm >= firstTerm) {\n                nextAvgStableRate = _totalSupply = _avgStableRate = 0;\n            } else {\n                nextAvgStableRate = _avgStableRate = ((firstTerm - secondTerm).rayDiv(nextSupply.wadToRay()))\n                    .toUint128();\n            }\n        }\n\n        if (amount == currentBalance) {\n            _userState[from].additionalData = 0;\n            _timestamps[from] = 0;\n        } else {\n            //solium-disable-next-line\n            _timestamps[from] = uint40(block.timestamp);\n        }\n        //solium-disable-next-line\n        _totalSupplyTimestamp = uint40(block.timestamp);\n\n        if (balanceIncrease > amount) {\n            uint256 amountToMint = balanceIncrease - amount;\n            _mint(from, amountToMint, previousSupply);\n            emit Transfer(address(0), from, amountToMint);\n            emit Mint(\n                from,\n                from,\n                amountToMint,\n                currentBalance,\n                balanceIncrease,\n                userStableRate,\n                nextAvgStableRate,\n                nextSupply\n            );\n        } else {\n            uint256 amountToBurn = amount - balanceIncrease;\n            _burn(from, amountToBurn, previousSupply);\n            emit Transfer(from, address(0), amountToBurn);\n            emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);\n        }\n\n        return (nextSupply, nextAvgStableRate);\n    }\n\n    /**\n     * @notice Calculates the increase in balance since the last user interaction\n     * @param user The address of the user for which the interest is being accumulated\n     * @return The previous principal balance\n     * @return The new principal balance\n     * @return The balance increase\n     */\n    function _calculateBalanceIncrease(address user) internal view returns (uint256, uint256, uint256) {\n        uint256 previousPrincipalBalance = super.balanceOf(user);\n\n        if (previousPrincipalBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 newPrincipalBalance = balanceOf(user);\n\n        return (previousPrincipalBalance, newPrincipalBalance, newPrincipalBalance - previousPrincipalBalance);\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getSupplyData() external view override returns (uint256, uint256, uint256, uint40) {\n        uint256 avgRate = _avgStableRate;\n        return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getTotalSupplyAndAvgRate() external view override returns (uint256, uint256) {\n        uint256 avgRate = _avgStableRate;\n        return (_calcTotalSupply(avgRate), avgRate);\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual override returns (uint256) {\n        return _calcTotalSupply(_avgStableRate);\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function getTotalSupplyLastUpdated() external view override returns (uint40) {\n        return _totalSupplyTimestamp;\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function principalBalanceOf(address user) external view virtual override returns (uint256) {\n        return super.balanceOf(user);\n    }\n\n    /// @inheritdoc IStableDebtToken\n    function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n        return _underlyingAsset;\n    }\n\n    /**\n     * @notice Calculates the total supply\n     * @param avgRate The average rate at which the total supply increases\n     * @return The debt balance of the user since the last burn/mint action\n     */\n    function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {\n        uint256 principalSupply = super.totalSupply();\n\n        if (principalSupply == 0) {\n            return 0;\n        }\n\n        uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\n\n        return principalSupply.rayMul(cumulatedInterest);\n    }\n\n    /**\n     * @notice Mints stable debt tokens to a user\n     * @param account The account receiving the debt tokens\n     * @param amount The amount being minted\n     * @param oldTotalSupply The total supply before the minting event\n     */\n    function _mint(address account, uint256 amount, uint256 oldTotalSupply) internal {\n        uint128 castAmount = amount.toUint128();\n        uint128 oldAccountBalance = _userState[account].balance;\n        _userState[account].balance = oldAccountBalance + castAmount;\n\n        if (address(_incentivesController) != address(0)) {\n            _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n        }\n    }\n\n    /**\n     * @notice Burns stable debt tokens of a user\n     * @param account The user getting his debt burned\n     * @param amount The amount being burned\n     * @param oldTotalSupply The total supply before the burning event\n     */\n    function _burn(address account, uint256 amount, uint256 oldTotalSupply) internal {\n        uint128 castAmount = amount.toUint128();\n        uint128 oldAccountBalance = _userState[account].balance;\n        _userState[account].balance = oldAccountBalance - castAmount;\n\n        if (address(_incentivesController) != address(0)) {\n            _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n        }\n    }\n\n    /// @inheritdoc EIP712Base\n    function _EIP712BaseId() internal view override returns (string memory) {\n        return name();\n    }\n\n    /**\n     * @dev Being non transferrable, the debt token does not implement any of the\n     * standard ERC20 functions for transfer and allowance.\n     */\n    function transfer(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function allowance(address, address) external view virtual override returns (uint256) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function approve(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function transferFrom(address, address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function increaseAllowance(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function decreaseAllowance(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/tokenization/VariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { SafeCast } from \"../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { VersionedInitializable } from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { WadRayMath } from \"../libraries/math/WadRayMath.sol\";\nimport { Errors } from \"../libraries/helpers/Errors.sol\";\nimport { IPool } from \"../../interfaces/IPool.sol\";\nimport { IAaveIncentivesController } from \"../../interfaces/IAaveIncentivesController.sol\";\nimport { IInitializableDebtToken } from \"../../interfaces/IInitializableDebtToken.sol\";\nimport { IVariableDebtToken } from \"../../interfaces/IVariableDebtToken.sol\";\nimport { EIP712Base } from \"./base/EIP712Base.sol\";\nimport { DebtTokenBase } from \"./base/DebtTokenBase.sol\";\nimport { ScaledBalanceTokenBase } from \"./base/ScaledBalanceTokenBase.sol\";\n\n/**\n * @title VariableDebtToken\n * @author Aave\n * @notice Implements a variable debt token to track the borrowing positions of users\n * at variable rate mode\n * @dev Transfer and approve functionalities are disabled since its a non-transferable token\n */\ncontract VariableDebtToken is DebtTokenBase, ScaledBalanceTokenBase, IVariableDebtToken {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n    /**\n     * @dev Constructor.\n     * @param pool The address of the Pool contract\n     */\n    constructor(\n        IPool pool\n    ) DebtTokenBase() ScaledBalanceTokenBase(pool, \"VARIABLE_DEBT_TOKEN_IMPL\", \"VARIABLE_DEBT_TOKEN_IMPL\", 0) {\n        // Intentionally left blank\n    }\n\n    /// @inheritdoc IInitializableDebtToken\n    function initialize(\n        IPool initializingPool,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 debtTokenDecimals,\n        string memory debtTokenName,\n        string memory debtTokenSymbol,\n        bytes calldata params\n    ) external override initializer {\n        require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n        _setName(debtTokenName);\n        _setSymbol(debtTokenSymbol);\n        _setDecimals(debtTokenDecimals);\n\n        _underlyingAsset = underlyingAsset;\n        _incentivesController = incentivesController;\n\n        _domainSeparator = _calculateDomainSeparator();\n\n        emit Initialized(\n            underlyingAsset,\n            address(POOL),\n            address(incentivesController),\n            debtTokenDecimals,\n            debtTokenName,\n            debtTokenSymbol,\n            params\n        );\n    }\n\n    /// @inheritdoc VersionedInitializable\n    function getRevision() internal pure virtual override returns (uint256) {\n        return DEBT_TOKEN_REVISION;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address user) public view virtual override returns (uint256) {\n        uint256 scaledBalance = super.balanceOf(user);\n\n        if (scaledBalance == 0) {\n            return 0;\n        }\n\n        return scaledBalance.rayMul(POOL.getReserveNormalizedVariableDebt(_underlyingAsset));\n    }\n\n    /// @inheritdoc IVariableDebtToken\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 index\n    ) external virtual override onlyPool returns (bool, uint256) {\n        if (user != onBehalfOf) {\n            _decreaseBorrowAllowance(onBehalfOf, user, amount);\n        }\n        return (_mintScaled(user, onBehalfOf, amount, index), scaledTotalSupply());\n    }\n\n    /// @inheritdoc IVariableDebtToken\n    function burn(address from, uint256 amount, uint256 index) external virtual override onlyPool returns (uint256) {\n        _burnScaled(from, address(0), amount, index);\n        return scaledTotalSupply();\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual override returns (uint256) {\n        return super.totalSupply().rayMul(POOL.getReserveNormalizedVariableDebt(_underlyingAsset));\n    }\n\n    /// @inheritdoc EIP712Base\n    function _EIP712BaseId() internal view override returns (string memory) {\n        return name();\n    }\n\n    /**\n     * @dev Being non transferrable, the debt token does not implement any of the\n     * standard ERC20 functions for transfer and allowance.\n     */\n    function transfer(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function allowance(address, address) external view virtual override returns (uint256) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function approve(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function transferFrom(address, address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function increaseAllowance(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    function decreaseAllowance(address, uint256) external virtual override returns (bool) {\n        revert(Errors.OPERATION_NOT_SUPPORTED);\n    }\n\n    /// @inheritdoc IVariableDebtToken\n    function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n        return _underlyingAsset;\n    }\n}\n"
    },
    "contracts/dlend/periphery/libraries/DataTypesHelper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title DataTypesHelper\n * @author Aave\n * @dev Helper library to track user current debt balance, used by WrappedTokenGatewayV3\n */\nlibrary DataTypesHelper {\n    /**\n     * @notice Fetches the user current stable and variable debt balances\n     * @param user The user address\n     * @param reserve The reserve data object\n     * @return The stable debt balance\n     * @return The variable debt balance\n     **/\n    function getUserCurrentDebt(\n        address user,\n        DataTypes.ReserveData memory reserve\n    ) internal view returns (uint256, uint256) {\n        return (\n            IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n            IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n        );\n    }\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IEACAggregatorProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IEACAggregatorProxy {\n    function decimals() external view returns (uint8);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n    event NewRound(uint256 indexed roundId, address indexed startedBy);\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IERC20DetailedBytes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IERC20DetailedBytes is IERC20 {\n    function name() external view returns (bytes32);\n\n    function symbol() external view returns (bytes32);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IUiIncentiveDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"contracts/dlend/core/interfaces/IPoolAddressesProvider.sol\";\n\ninterface IUiIncentiveDataProviderV3 {\n    struct AggregatedReserveIncentiveData {\n        address underlyingAsset;\n        IncentiveData aIncentiveData;\n        IncentiveData vIncentiveData;\n        IncentiveData sIncentiveData;\n    }\n\n    struct IncentiveData {\n        address tokenAddress;\n        address incentiveControllerAddress;\n        RewardInfo[] rewardsTokenInformation;\n    }\n\n    struct RewardInfo {\n        string rewardTokenSymbol;\n        address rewardTokenAddress;\n        address rewardOracleAddress;\n        uint256 emissionPerSecond;\n        uint256 incentivesLastUpdateTimestamp;\n        uint256 tokenIncentivesIndex;\n        uint256 emissionEndTimestamp;\n        int256 rewardPriceFeed;\n        uint8 rewardTokenDecimals;\n        uint8 precision;\n        uint8 priceFeedDecimals;\n    }\n\n    struct UserReserveIncentiveData {\n        address underlyingAsset;\n        UserIncentiveData aTokenIncentivesUserData;\n        UserIncentiveData vTokenIncentivesUserData;\n        UserIncentiveData sTokenIncentivesUserData;\n    }\n\n    struct UserIncentiveData {\n        address tokenAddress;\n        address incentiveControllerAddress;\n        UserRewardInfo[] userRewardsInformation;\n    }\n\n    struct UserRewardInfo {\n        string rewardTokenSymbol;\n        address rewardOracleAddress;\n        address rewardTokenAddress;\n        uint256 userUnclaimedRewards;\n        uint256 tokenIncentivesUserIndex;\n        int256 rewardPriceFeed;\n        uint8 priceFeedDecimals;\n        uint8 rewardTokenDecimals;\n    }\n\n    function getReservesIncentivesData(\n        IPoolAddressesProvider provider\n    ) external view returns (AggregatedReserveIncentiveData[] memory);\n\n    function getUserReservesIncentivesData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view returns (UserReserveIncentiveData[] memory);\n\n    // generic method with full data\n    function getFullReservesIncentiveData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view returns (AggregatedReserveIncentiveData[] memory, UserReserveIncentiveData[] memory);\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IUiPoolDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPoolAddressesProvider } from \"contracts/dlend/core/interfaces/IPoolAddressesProvider.sol\";\n\ninterface IUiPoolDataProviderV3 {\n    struct InterestRates {\n        uint256 variableRateSlope1;\n        uint256 variableRateSlope2;\n        uint256 stableRateSlope1;\n        uint256 stableRateSlope2;\n        uint256 baseStableBorrowRate;\n        uint256 baseVariableBorrowRate;\n        uint256 optimalUsageRatio;\n    }\n\n    struct AggregatedReserveData {\n        address underlyingAsset;\n        string name;\n        string symbol;\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 reserveLiquidationThreshold;\n        uint256 reserveLiquidationBonus;\n        uint256 reserveFactor;\n        bool usageAsCollateralEnabled;\n        bool borrowingEnabled;\n        bool stableBorrowRateEnabled;\n        bool isActive;\n        bool isFrozen;\n        // base data\n        uint128 liquidityIndex;\n        uint128 variableBorrowIndex;\n        uint128 liquidityRate;\n        uint128 variableBorrowRate;\n        uint128 stableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        address interestRateStrategyAddress;\n        //\n        uint256 availableLiquidity;\n        uint256 totalPrincipalStableDebt;\n        uint256 averageStableRate;\n        uint256 stableDebtLastUpdateTimestamp;\n        uint256 totalScaledVariableDebt;\n        uint256 priceInMarketReferenceCurrency;\n        address priceOracle;\n        uint256 variableRateSlope1;\n        uint256 variableRateSlope2;\n        uint256 stableRateSlope1;\n        uint256 stableRateSlope2;\n        uint256 baseStableBorrowRate;\n        uint256 baseVariableBorrowRate;\n        uint256 optimalUsageRatio;\n        // v3 only\n        bool isPaused;\n        bool isSiloedBorrowing;\n        uint128 accruedToTreasury;\n        uint128 unbacked;\n        uint128 isolationModeTotalDebt;\n        bool flashLoanEnabled;\n        //\n        uint256 debtCeiling;\n        uint256 debtCeilingDecimals;\n        uint8 eModeCategoryId;\n        uint256 borrowCap;\n        uint256 supplyCap;\n        // eMode\n        uint16 eModeLtv;\n        uint16 eModeLiquidationThreshold;\n        uint16 eModeLiquidationBonus;\n        address eModePriceSource;\n        string eModeLabel;\n        bool borrowableInIsolation;\n    }\n\n    struct UserReserveData {\n        address underlyingAsset;\n        uint256 scaledATokenBalance;\n        bool usageAsCollateralEnabledOnUser;\n        uint256 stableBorrowRate;\n        uint256 scaledVariableDebt;\n        uint256 principalStableDebt;\n        uint256 stableBorrowLastUpdateTimestamp;\n    }\n\n    struct BaseCurrencyInfo {\n        uint256 marketReferenceCurrencyUnit;\n        int256 marketReferenceCurrencyPriceInUsd;\n        int256 networkBaseTokenPriceInUsd;\n        uint8 networkBaseTokenPriceDecimals;\n    }\n\n    function getReservesList(IPoolAddressesProvider provider) external view returns (address[] memory);\n\n    function getReservesData(\n        IPoolAddressesProvider provider\n    ) external view returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory);\n\n    function getUserReservesData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view returns (UserReserveData[] memory, uint8);\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/dlend/periphery/misc/interfaces/IWrappedTokenGatewayV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IWrappedTokenGatewayV3 {\n    function depositETH(address pool, address onBehalfOf, uint16 referralCode) external payable;\n\n    function withdrawETH(address pool, uint256 amount, address onBehalfOf) external;\n\n    function repayETH(address pool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable;\n\n    function borrowETH(address pool, uint256 amount, uint256 interestRateMode, uint16 referralCode) external;\n\n    function withdrawETHWithPermit(\n        address pool,\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n}\n"
    },
    "contracts/dlend/periphery/misc/UiIncentiveDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20Detailed } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { IPoolAddressesProvider } from \"contracts/dlend/core/interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IncentivizedERC20 } from \"contracts/dlend/core/protocol/tokenization/base/IncentivizedERC20.sol\";\nimport { UserConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/UserConfiguration.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\nimport { IRewardsController } from \"../rewards/interfaces/IRewardsController.sol\";\nimport { IUiIncentiveDataProviderV3 } from \"./interfaces/IUiIncentiveDataProviderV3.sol\";\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\n\ncontract UiIncentiveDataProviderV3 is IUiIncentiveDataProviderV3 {\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    function getFullReservesIncentiveData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view override returns (AggregatedReserveIncentiveData[] memory, UserReserveIncentiveData[] memory) {\n        return (_getReservesIncentivesData(provider), _getUserReservesIncentivesData(provider, user));\n    }\n\n    function getReservesIncentivesData(\n        IPoolAddressesProvider provider\n    ) external view override returns (AggregatedReserveIncentiveData[] memory) {\n        return _getReservesIncentivesData(provider);\n    }\n\n    function _getReservesIncentivesData(\n        IPoolAddressesProvider provider\n    ) private view returns (AggregatedReserveIncentiveData[] memory) {\n        IPool pool = IPool(provider.getPool());\n        address[] memory reserves = pool.getReservesList();\n        AggregatedReserveIncentiveData[] memory reservesIncentiveData = new AggregatedReserveIncentiveData[](\n            reserves.length\n        );\n        // Iterate through the reserves to get all the information from the (a/s/v) Tokens\n        for (uint256 i = 0; i < reserves.length; i++) {\n            AggregatedReserveIncentiveData memory reserveIncentiveData = reservesIncentiveData[i];\n            reserveIncentiveData.underlyingAsset = reserves[i];\n\n            DataTypes.ReserveData memory baseData = pool.getReserveData(reserves[i]);\n\n            // Get aTokens rewards information\n            // TODO: check that this is deployed correctly on contract and remove casting\n            IRewardsController aTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.aTokenAddress).getIncentivesController())\n            );\n            RewardInfo[] memory aRewardsInformation;\n            if (address(aTokenIncentiveController) != address(0)) {\n                address[] memory aTokenRewardAddresses = aTokenIncentiveController.getRewardsByAsset(\n                    baseData.aTokenAddress\n                );\n\n                aRewardsInformation = new RewardInfo[](aTokenRewardAddresses.length);\n                for (uint256 j = 0; j < aTokenRewardAddresses.length; ++j) {\n                    RewardInfo memory rewardInformation;\n                    rewardInformation.rewardTokenAddress = aTokenRewardAddresses[j];\n\n                    (\n                        rewardInformation.tokenIncentivesIndex,\n                        rewardInformation.emissionPerSecond,\n                        rewardInformation.incentivesLastUpdateTimestamp,\n                        rewardInformation.emissionEndTimestamp\n                    ) = aTokenIncentiveController.getRewardsData(\n                        baseData.aTokenAddress,\n                        rewardInformation.rewardTokenAddress\n                    );\n\n                    rewardInformation.precision = aTokenIncentiveController.getAssetDecimals(baseData.aTokenAddress);\n                    rewardInformation.rewardTokenDecimals = IERC20Detailed(rewardInformation.rewardTokenAddress)\n                        .decimals();\n                    rewardInformation.rewardTokenSymbol = IERC20Detailed(rewardInformation.rewardTokenAddress).symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    rewardInformation.rewardOracleAddress = aTokenIncentiveController.getRewardOracle(\n                        rewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(rewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    rewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(baseCurrency);\n                    rewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(rewardInformation.rewardOracleAddress).getAssetPrice(\n                            rewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    aRewardsInformation[j] = rewardInformation;\n                }\n            }\n\n            reserveIncentiveData.aIncentiveData = IncentiveData(\n                baseData.aTokenAddress,\n                address(aTokenIncentiveController),\n                aRewardsInformation\n            );\n\n            // Get vTokens rewards information\n            IRewardsController vTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.variableDebtTokenAddress).getIncentivesController())\n            );\n            RewardInfo[] memory vRewardsInformation;\n            if (address(vTokenIncentiveController) != address(0)) {\n                address[] memory vTokenRewardAddresses = vTokenIncentiveController.getRewardsByAsset(\n                    baseData.variableDebtTokenAddress\n                );\n                vRewardsInformation = new RewardInfo[](vTokenRewardAddresses.length);\n                for (uint256 j = 0; j < vTokenRewardAddresses.length; ++j) {\n                    RewardInfo memory rewardInformation;\n                    rewardInformation.rewardTokenAddress = vTokenRewardAddresses[j];\n\n                    (\n                        rewardInformation.tokenIncentivesIndex,\n                        rewardInformation.emissionPerSecond,\n                        rewardInformation.incentivesLastUpdateTimestamp,\n                        rewardInformation.emissionEndTimestamp\n                    ) = vTokenIncentiveController.getRewardsData(\n                        baseData.variableDebtTokenAddress,\n                        rewardInformation.rewardTokenAddress\n                    );\n\n                    rewardInformation.precision = vTokenIncentiveController.getAssetDecimals(\n                        baseData.variableDebtTokenAddress\n                    );\n                    rewardInformation.rewardTokenDecimals = IERC20Detailed(rewardInformation.rewardTokenAddress)\n                        .decimals();\n                    rewardInformation.rewardTokenSymbol = IERC20Detailed(rewardInformation.rewardTokenAddress).symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    rewardInformation.rewardOracleAddress = vTokenIncentiveController.getRewardOracle(\n                        rewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(rewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    rewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(baseCurrency);\n                    rewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(rewardInformation.rewardOracleAddress).getAssetPrice(\n                            rewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    vRewardsInformation[j] = rewardInformation;\n                }\n            }\n\n            reserveIncentiveData.vIncentiveData = IncentiveData(\n                baseData.variableDebtTokenAddress,\n                address(vTokenIncentiveController),\n                vRewardsInformation\n            );\n\n            // Get sTokens rewards information\n            IRewardsController sTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.stableDebtTokenAddress).getIncentivesController())\n            );\n            RewardInfo[] memory sRewardsInformation;\n            if (address(sTokenIncentiveController) != address(0)) {\n                address[] memory sTokenRewardAddresses = sTokenIncentiveController.getRewardsByAsset(\n                    baseData.stableDebtTokenAddress\n                );\n                sRewardsInformation = new RewardInfo[](sTokenRewardAddresses.length);\n                for (uint256 j = 0; j < sTokenRewardAddresses.length; ++j) {\n                    RewardInfo memory rewardInformation;\n                    rewardInformation.rewardTokenAddress = sTokenRewardAddresses[j];\n\n                    (\n                        rewardInformation.tokenIncentivesIndex,\n                        rewardInformation.emissionPerSecond,\n                        rewardInformation.incentivesLastUpdateTimestamp,\n                        rewardInformation.emissionEndTimestamp\n                    ) = sTokenIncentiveController.getRewardsData(\n                        baseData.stableDebtTokenAddress,\n                        rewardInformation.rewardTokenAddress\n                    );\n\n                    rewardInformation.precision = sTokenIncentiveController.getAssetDecimals(\n                        baseData.stableDebtTokenAddress\n                    );\n                    rewardInformation.rewardTokenDecimals = IERC20Detailed(rewardInformation.rewardTokenAddress)\n                        .decimals();\n                    rewardInformation.rewardTokenSymbol = IERC20Detailed(rewardInformation.rewardTokenAddress).symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    rewardInformation.rewardOracleAddress = sTokenIncentiveController.getRewardOracle(\n                        rewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(rewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    rewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(baseCurrency);\n                    rewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(rewardInformation.rewardOracleAddress).getAssetPrice(\n                            rewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    sRewardsInformation[j] = rewardInformation;\n                }\n            }\n\n            reserveIncentiveData.sIncentiveData = IncentiveData(\n                baseData.stableDebtTokenAddress,\n                address(sTokenIncentiveController),\n                sRewardsInformation\n            );\n        }\n\n        return (reservesIncentiveData);\n    }\n\n    function getUserReservesIncentivesData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view override returns (UserReserveIncentiveData[] memory) {\n        return _getUserReservesIncentivesData(provider, user);\n    }\n\n    function _extractDecimalsValueFromBaseCurrencyUnitPrice(address baseCurrencyUnit) private pure returns (uint8) {\n        require(baseCurrencyUnit == address(0), \"Base currency unit must be USD\");\n\n        // All V3 markets use USD based oracles which return values with 8 decimals\n        return 8;\n    }\n\n    function _getUserReservesIncentivesData(\n        IPoolAddressesProvider provider,\n        address user\n    ) private view returns (UserReserveIncentiveData[] memory) {\n        IPool pool = IPool(provider.getPool());\n        address[] memory reserves = pool.getReservesList();\n\n        UserReserveIncentiveData[] memory userReservesIncentivesData = new UserReserveIncentiveData[](\n            user != address(0) ? reserves.length : 0\n        );\n\n        for (uint256 i = 0; i < reserves.length; i++) {\n            DataTypes.ReserveData memory baseData = pool.getReserveData(reserves[i]);\n\n            // user reserve data\n            userReservesIncentivesData[i].underlyingAsset = reserves[i];\n\n            IRewardsController aTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.aTokenAddress).getIncentivesController())\n            );\n            if (address(aTokenIncentiveController) != address(0)) {\n                // get all rewards information from the asset\n                address[] memory aTokenRewardAddresses = aTokenIncentiveController.getRewardsByAsset(\n                    baseData.aTokenAddress\n                );\n                UserRewardInfo[] memory aUserRewardsInformation = new UserRewardInfo[](aTokenRewardAddresses.length);\n                for (uint256 j = 0; j < aTokenRewardAddresses.length; ++j) {\n                    UserRewardInfo memory userRewardInformation;\n                    userRewardInformation.rewardTokenAddress = aTokenRewardAddresses[j];\n\n                    userRewardInformation.tokenIncentivesUserIndex = aTokenIncentiveController.getUserAssetIndex(\n                        user,\n                        baseData.aTokenAddress,\n                        userRewardInformation.rewardTokenAddress\n                    );\n\n                    userRewardInformation.userUnclaimedRewards = aTokenIncentiveController.getUserAccruedRewards(\n                        user,\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    userRewardInformation.rewardTokenDecimals = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .decimals();\n                    userRewardInformation.rewardTokenSymbol = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    userRewardInformation.rewardOracleAddress = aTokenIncentiveController.getRewardOracle(\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(userRewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    userRewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(\n                        baseCurrency\n                    );\n                    userRewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(userRewardInformation.rewardOracleAddress).getAssetPrice(\n                            userRewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    aUserRewardsInformation[j] = userRewardInformation;\n                }\n\n                userReservesIncentivesData[i].aTokenIncentivesUserData = UserIncentiveData(\n                    baseData.aTokenAddress,\n                    address(aTokenIncentiveController),\n                    aUserRewardsInformation\n                );\n            }\n\n            // variable debt token\n            IRewardsController vTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.variableDebtTokenAddress).getIncentivesController())\n            );\n            if (address(vTokenIncentiveController) != address(0)) {\n                // get all rewards information from the asset\n                address[] memory vTokenRewardAddresses = vTokenIncentiveController.getRewardsByAsset(\n                    baseData.variableDebtTokenAddress\n                );\n                UserRewardInfo[] memory vUserRewardsInformation = new UserRewardInfo[](vTokenRewardAddresses.length);\n                for (uint256 j = 0; j < vTokenRewardAddresses.length; ++j) {\n                    UserRewardInfo memory userRewardInformation;\n                    userRewardInformation.rewardTokenAddress = vTokenRewardAddresses[j];\n\n                    userRewardInformation.tokenIncentivesUserIndex = vTokenIncentiveController.getUserAssetIndex(\n                        user,\n                        baseData.variableDebtTokenAddress,\n                        userRewardInformation.rewardTokenAddress\n                    );\n\n                    userRewardInformation.userUnclaimedRewards = vTokenIncentiveController.getUserAccruedRewards(\n                        user,\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    userRewardInformation.rewardTokenDecimals = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .decimals();\n                    userRewardInformation.rewardTokenSymbol = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    userRewardInformation.rewardOracleAddress = vTokenIncentiveController.getRewardOracle(\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(userRewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    userRewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(\n                        baseCurrency\n                    );\n                    userRewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(userRewardInformation.rewardOracleAddress).getAssetPrice(\n                            userRewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    vUserRewardsInformation[j] = userRewardInformation;\n                }\n\n                userReservesIncentivesData[i].vTokenIncentivesUserData = UserIncentiveData(\n                    baseData.variableDebtTokenAddress,\n                    address(vTokenIncentiveController),\n                    vUserRewardsInformation\n                );\n            }\n\n            // stable debt token\n            IRewardsController sTokenIncentiveController = IRewardsController(\n                address(IncentivizedERC20(baseData.stableDebtTokenAddress).getIncentivesController())\n            );\n            if (address(sTokenIncentiveController) != address(0)) {\n                // get all rewards information from the asset\n                address[] memory sTokenRewardAddresses = sTokenIncentiveController.getRewardsByAsset(\n                    baseData.stableDebtTokenAddress\n                );\n                UserRewardInfo[] memory sUserRewardsInformation = new UserRewardInfo[](sTokenRewardAddresses.length);\n                for (uint256 j = 0; j < sTokenRewardAddresses.length; ++j) {\n                    UserRewardInfo memory userRewardInformation;\n                    userRewardInformation.rewardTokenAddress = sTokenRewardAddresses[j];\n\n                    userRewardInformation.tokenIncentivesUserIndex = sTokenIncentiveController.getUserAssetIndex(\n                        user,\n                        baseData.stableDebtTokenAddress,\n                        userRewardInformation.rewardTokenAddress\n                    );\n\n                    userRewardInformation.userUnclaimedRewards = sTokenIncentiveController.getUserAccruedRewards(\n                        user,\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    userRewardInformation.rewardTokenDecimals = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .decimals();\n                    userRewardInformation.rewardTokenSymbol = IERC20Detailed(userRewardInformation.rewardTokenAddress)\n                        .symbol();\n\n                    // Get price of reward token from Chainlink Proxy Oracle\n                    userRewardInformation.rewardOracleAddress = sTokenIncentiveController.getRewardOracle(\n                        userRewardInformation.rewardTokenAddress\n                    );\n                    address baseCurrency = IAaveOracle(userRewardInformation.rewardOracleAddress).BASE_CURRENCY();\n                    userRewardInformation.priceFeedDecimals = _extractDecimalsValueFromBaseCurrencyUnitPrice(\n                        baseCurrency\n                    );\n                    userRewardInformation.rewardPriceFeed = int256(\n                        IAaveOracle(userRewardInformation.rewardOracleAddress).getAssetPrice(\n                            userRewardInformation.rewardTokenAddress\n                        )\n                    );\n\n                    sUserRewardsInformation[j] = userRewardInformation;\n                }\n\n                userReservesIncentivesData[i].sTokenIncentivesUserData = UserIncentiveData(\n                    baseData.stableDebtTokenAddress,\n                    address(sTokenIncentiveController),\n                    sUserRewardsInformation\n                );\n            }\n        }\n\n        return (userReservesIncentivesData);\n    }\n}\n"
    },
    "contracts/dlend/periphery/misc/UiPoolDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20Detailed } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { IPoolAddressesProvider } from \"contracts/dlend/core/interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { IAToken } from \"contracts/dlend/core/interfaces/IAToken.sol\";\nimport { IVariableDebtToken } from \"contracts/dlend/core/interfaces/IVariableDebtToken.sol\";\nimport { IStableDebtToken } from \"contracts/dlend/core/interfaces/IStableDebtToken.sol\";\nimport { DefaultReserveInterestRateStrategy } from \"contracts/dlend/core/protocol/pool/DefaultReserveInterestRateStrategy.sol\";\nimport { AaveProtocolDataProvider } from \"contracts/dlend/core/misc/AaveProtocolDataProvider.sol\";\nimport { WadRayMath } from \"contracts/dlend/core/protocol/libraries/math/WadRayMath.sol\";\nimport { ReserveConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/UserConfiguration.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\nimport { IERC20DetailedBytes } from \"./interfaces/IERC20DetailedBytes.sol\";\nimport { IUiPoolDataProviderV3 } from \"./interfaces/IUiPoolDataProviderV3.sol\";\n\ncontract UiPoolDataProviderV3 is IUiPoolDataProviderV3 {\n    using WadRayMath for uint256;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    IAaveOracle public immutable priceOracle;\n    address public immutable wethAddress;\n    uint256 public constant ETH_CURRENCY_UNIT = 1 ether;\n\n    constructor(IAaveOracle _priceOracle, address _wethAddress) {\n        priceOracle = _priceOracle;\n        wethAddress = _wethAddress;\n    }\n\n    function getReservesList(IPoolAddressesProvider provider) public view override returns (address[] memory) {\n        IPool pool = IPool(provider.getPool());\n        return pool.getReservesList();\n    }\n\n    function getReservesData(\n        IPoolAddressesProvider provider\n    ) public view override returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory) {\n        IAaveOracle oracle = IAaveOracle(provider.getPriceOracle());\n        IPool pool = IPool(provider.getPool());\n        AaveProtocolDataProvider poolDataProvider = AaveProtocolDataProvider(provider.getPoolDataProvider());\n\n        address[] memory reserves = pool.getReservesList();\n        AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\n        for (uint256 i = 0; i < reserves.length; i++) {\n            AggregatedReserveData memory reserveData = reservesData[i];\n            reserveData.underlyingAsset = reserves[i];\n\n            // reserve current state\n            DataTypes.ReserveData memory baseData = pool.getReserveData(reserveData.underlyingAsset);\n            //the liquidity index. Expressed in ray\n            reserveData.liquidityIndex = baseData.liquidityIndex;\n            //variable borrow index. Expressed in ray\n            reserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n            //the current supply rate. Expressed in ray\n            reserveData.liquidityRate = baseData.currentLiquidityRate;\n            //the current variable borrow rate. Expressed in ray\n            reserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n            //the current stable borrow rate. Expressed in ray\n            reserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n            reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n            reserveData.aTokenAddress = baseData.aTokenAddress;\n            reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n            reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n            //address of the interest rate strategy\n            reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n\n            reserveData.priceInMarketReferenceCurrency = oracle.getAssetPrice(reserveData.underlyingAsset);\n            reserveData.priceOracle = oracle.getSourceOfAsset(reserveData.underlyingAsset);\n            reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf(\n                reserveData.aTokenAddress\n            );\n            (\n                reserveData.totalPrincipalStableDebt,\n                ,\n                reserveData.averageStableRate,\n                reserveData.stableDebtLastUpdateTimestamp\n            ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n            reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n                .scaledTotalSupply();\n\n            reserveData.symbol = IERC20Detailed(reserveData.underlyingAsset).symbol();\n            reserveData.name = IERC20Detailed(reserveData.underlyingAsset).name();\n\n            //stores the reserve configuration\n            DataTypes.ReserveConfigurationMap memory reserveConfigurationMap = baseData.configuration;\n            uint256 eModeCategoryId;\n            (\n                reserveData.baseLTVasCollateral,\n                reserveData.reserveLiquidationThreshold,\n                reserveData.reserveLiquidationBonus,\n                reserveData.decimals,\n                reserveData.reserveFactor,\n                eModeCategoryId\n            ) = reserveConfigurationMap.getParams();\n            reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n\n            (\n                reserveData.isActive,\n                reserveData.isFrozen,\n                reserveData.borrowingEnabled,\n                reserveData.stableBorrowRateEnabled,\n                reserveData.isPaused\n            ) = reserveConfigurationMap.getFlags();\n\n            // interest rates\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getVariableRateSlope1()\n            returns (uint256 res) {\n                reserveData.variableRateSlope1 = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getVariableRateSlope2()\n            returns (uint256 res) {\n                reserveData.variableRateSlope2 = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getStableRateSlope1()\n            returns (uint256 res) {\n                reserveData.stableRateSlope1 = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getStableRateSlope2()\n            returns (uint256 res) {\n                reserveData.stableRateSlope2 = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getBaseStableBorrowRate()\n            returns (uint256 res) {\n                reserveData.baseStableBorrowRate = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).getBaseVariableBorrowRate()\n            returns (uint256 res) {\n                reserveData.baseVariableBorrowRate = res;\n            } catch {}\n            try\n                DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).OPTIMAL_USAGE_RATIO()\n            returns (uint256 res) {\n                reserveData.optimalUsageRatio = res;\n            } catch {}\n\n            // v3 only\n            reserveData.eModeCategoryId = uint8(eModeCategoryId);\n            reserveData.debtCeiling = reserveConfigurationMap.getDebtCeiling();\n            reserveData.debtCeilingDecimals = poolDataProvider.getDebtCeilingDecimals();\n            (reserveData.borrowCap, reserveData.supplyCap) = reserveConfigurationMap.getCaps();\n\n            try poolDataProvider.getFlashLoanEnabled(reserveData.underlyingAsset) returns (bool flashLoanEnabled) {\n                reserveData.flashLoanEnabled = flashLoanEnabled;\n            } catch (bytes memory) {\n                reserveData.flashLoanEnabled = true;\n            }\n\n            reserveData.isSiloedBorrowing = reserveConfigurationMap.getSiloedBorrowing();\n            reserveData.unbacked = baseData.unbacked;\n            reserveData.isolationModeTotalDebt = baseData.isolationModeTotalDebt;\n            reserveData.accruedToTreasury = baseData.accruedToTreasury;\n\n            DataTypes.EModeCategory memory categoryData = pool.getEModeCategoryData(reserveData.eModeCategoryId);\n            reserveData.eModeLtv = categoryData.ltv;\n            reserveData.eModeLiquidationThreshold = categoryData.liquidationThreshold;\n            reserveData.eModeLiquidationBonus = categoryData.liquidationBonus;\n            // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n            reserveData.eModePriceSource = categoryData.priceSource;\n            reserveData.eModeLabel = categoryData.label;\n\n            reserveData.borrowableInIsolation = reserveConfigurationMap.getBorrowableInIsolation();\n        }\n\n        BaseCurrencyInfo memory baseCurrencyInfo;\n\n        // Get networkBaseToken (the gas token) price in USD\n        baseCurrencyInfo.networkBaseTokenPriceInUsd = int256(priceOracle.getAssetPrice(wethAddress));\n\n        // Set decimals (The Aave ecosystem uses 8 decimals for the base currency)\n        baseCurrencyInfo.networkBaseTokenPriceDecimals = 8;\n\n        try oracle.BASE_CURRENCY_UNIT() returns (uint256 baseCurrencyUnit) {\n            baseCurrencyInfo.marketReferenceCurrencyUnit = baseCurrencyUnit;\n            baseCurrencyInfo.marketReferenceCurrencyPriceInUsd = int256(baseCurrencyUnit);\n        } catch {\n            baseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n\n            // Get marketReferenceCurrency price in USD (same as networkBaseToken price since they're the same)\n            baseCurrencyInfo.marketReferenceCurrencyPriceInUsd = int256(priceOracle.getAssetPrice(wethAddress));\n        }\n\n        return (reservesData, baseCurrencyInfo);\n    }\n\n    function getUserReservesData(\n        IPoolAddressesProvider provider,\n        address user\n    ) external view override returns (UserReserveData[] memory, uint8) {\n        IPool pool = IPool(provider.getPool());\n        address[] memory reserves = pool.getReservesList();\n        DataTypes.UserConfigurationMap memory userConfig = pool.getUserConfiguration(user);\n\n        uint8 userEmodeCategoryId = uint8(pool.getUserEMode(user));\n\n        UserReserveData[] memory userReservesData = new UserReserveData[](user != address(0) ? reserves.length : 0);\n\n        for (uint256 i = 0; i < reserves.length; i++) {\n            DataTypes.ReserveData memory baseData = pool.getReserveData(reserves[i]);\n\n            // user reserve data\n            userReservesData[i].underlyingAsset = reserves[i];\n            userReservesData[i].scaledATokenBalance = IAToken(baseData.aTokenAddress).scaledBalanceOf(user);\n            userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n            if (userConfig.isBorrowing(i)) {\n                userReservesData[i].scaledVariableDebt = IVariableDebtToken(baseData.variableDebtTokenAddress)\n                    .scaledBalanceOf(user);\n                userReservesData[i].principalStableDebt = IStableDebtToken(baseData.stableDebtTokenAddress)\n                    .principalBalanceOf(user);\n                if (userReservesData[i].principalStableDebt != 0) {\n                    userReservesData[i].stableBorrowRate = IStableDebtToken(baseData.stableDebtTokenAddress)\n                        .getUserStableRate(user);\n                    userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n                        baseData.stableDebtTokenAddress\n                    ).getUserLastUpdated(user);\n                }\n            }\n        }\n\n        return (userReservesData, userEmodeCategoryId);\n    }\n\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while (i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n}\n"
    },
    "contracts/dlend/periphery/misc/WalletBalanceProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Address } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/Address.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\nimport { IPoolAddressesProvider } from \"contracts/dlend/core/interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { GPv2SafeERC20 } from \"contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { ReserveConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title WalletBalanceProvider contract\n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\n * @notice Implements a logic of getting multiple tokens balance for one user address\n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\n * towards the blockchain from the Aave backend.\n **/\ncontract WalletBalanceProvider {\n    using Address for address payable;\n    using Address for address;\n    using GPv2SafeERC20 for IERC20;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n    @dev Fallback function, don't accept any ETH\n    **/\n    receive() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), \"22\");\n    }\n\n    /**\n    @dev Check the token balance of a wallet in a token contract\n\n    Returns the balance of the token for user. Avoids possible errors:\n      - return 0 on non-contract address\n    **/\n    function balanceOf(address user, address token) public view returns (uint256) {\n        if (token == MOCK_ETH_ADDRESS) {\n            return user.balance; // ETH balance\n            // check if token is actually a contract\n        } else if (token.isContract()) {\n            return IERC20(token).balanceOf(user);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    /**\n     * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n     * @param users The list of users\n     * @param tokens The list of tokens\n     * @return And array with the concatenation of, for each user, his/her balances\n     **/\n    function batchBalanceOf(\n        address[] calldata users,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](users.length * tokens.length);\n\n        for (uint256 i = 0; i < users.length; i++) {\n            for (uint256 j = 0; j < tokens.length; j++) {\n                balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]);\n            }\n        }\n\n        return balances;\n    }\n\n    /**\n    @dev provides balances of user wallet for all reserves available on the pool\n    */\n    function getUserWalletBalances(\n        address provider,\n        address user\n    ) external view returns (address[] memory, uint256[] memory) {\n        IPool pool = IPool(IPoolAddressesProvider(provider).getPool());\n\n        address[] memory reserves = pool.getReservesList();\n        address[] memory reservesWithEth = new address[](reserves.length + 1);\n        for (uint256 i = 0; i < reserves.length; i++) {\n            reservesWithEth[i] = reserves[i];\n        }\n        reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS;\n\n        uint256[] memory balances = new uint256[](reservesWithEth.length);\n\n        for (uint256 j = 0; j < reserves.length; j++) {\n            DataTypes.ReserveConfigurationMap memory configuration = pool.getConfiguration(reservesWithEth[j]);\n\n            (bool isActive, , , , ) = configuration.getFlags();\n\n            if (!isActive) {\n                balances[j] = 0;\n                continue;\n            }\n            balances[j] = balanceOf(user, reservesWithEth[j]);\n        }\n        balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS);\n\n        return (reservesWithEth, balances);\n    }\n}\n"
    },
    "contracts/dlend/periphery/misc/WrappedTokenGatewayV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { GPv2SafeERC20 } from \"contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IWETH } from \"contracts/dlend/core/misc/interfaces/IWETH.sol\";\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IAToken } from \"contracts/dlend/core/interfaces/IAToken.sol\";\nimport { ReserveConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { UserConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/UserConfiguration.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\nimport { IWrappedTokenGatewayV3 } from \"./interfaces/IWrappedTokenGatewayV3.sol\";\nimport { DataTypesHelper } from \"../libraries/DataTypesHelper.sol\";\n\n/**\n * @dev This contract is an upgrade of the WrappedTokenGatewayV3 contract, with immutable pool address.\n * This contract keeps the same interface of the deprecated WrappedTokenGatewayV3 contract.\n */\ncontract WrappedTokenGatewayV3 is IWrappedTokenGatewayV3, Ownable {\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using GPv2SafeERC20 for IERC20;\n\n    IWETH internal immutable WETH;\n    IPool internal immutable POOL;\n\n    /**\n     * @dev Sets the WETH address and the PoolAddressesProvider address. Infinite approves pool.\n     * @param weth Address of the Wrapped Ether contract\n     * @param owner Address of the owner of this contract\n     **/\n    constructor(address weth, address owner, IPool pool) {\n        WETH = IWETH(weth);\n        POOL = pool;\n        transferOwnership(owner);\n        IWETH(weth).approve(address(pool), type(uint256).max);\n    }\n\n    /**\n     * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\n     * is minted.\n     * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n     **/\n    function depositETH(address, address onBehalfOf, uint16 referralCode) external payable override {\n        WETH.deposit{ value: msg.value }();\n        POOL.deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n    }\n\n    /**\n     * @dev withdraws the WETH _reserves of msg.sender.\n     * @param amount amount of aWETH to withdraw and receive native ETH\n     * @param to address of the user who will receive native ETH\n     */\n    function withdrawETH(address, uint256 amount, address to) external override {\n        IAToken aWETH = IAToken(POOL.getReserveData(address(WETH)).aTokenAddress);\n        uint256 userBalance = aWETH.balanceOf(msg.sender);\n        uint256 amountToWithdraw = amount;\n\n        // if amount is equal to uint(-1), the user wants to redeem everything\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n        aWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n        POOL.withdraw(address(WETH), amountToWithdraw, address(this));\n        WETH.withdraw(amountToWithdraw);\n        _safeTransferETH(to, amountToWithdraw);\n    }\n\n    /**\n     * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n     * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n     * @param rateMode the rate mode to repay\n     * @param onBehalfOf the address for which msg.sender is repaying\n     */\n    function repayETH(address, uint256 amount, uint256 rateMode, address onBehalfOf) external payable override {\n        (uint256 stableDebt, uint256 variableDebt) = DataTypesHelper.getUserCurrentDebt(\n            onBehalfOf,\n            POOL.getReserveData(address(WETH))\n        );\n\n        uint256 paybackAmount = DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE\n            ? stableDebt\n            : variableDebt;\n\n        if (amount < paybackAmount) {\n            paybackAmount = amount;\n        }\n        require(msg.value >= paybackAmount, \"msg.value is less than repayment amount\");\n        WETH.deposit{ value: paybackAmount }();\n        POOL.repay(address(WETH), msg.value, rateMode, onBehalfOf);\n\n        // refund remaining dust eth\n        if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount);\n    }\n\n    /**\n     * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `Pool.borrow`.\n     * @param amount the amount of ETH to borrow\n     * @param interestRateMode the interest rate mode\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n     */\n    function borrowETH(address, uint256 amount, uint256 interestRateMode, uint16 referralCode) external override {\n        POOL.borrow(address(WETH), amount, interestRateMode, referralCode, msg.sender);\n        WETH.withdraw(amount);\n        _safeTransferETH(msg.sender, amount);\n    }\n\n    /**\n     * @dev withdraws the WETH _reserves of msg.sender.\n     * @param amount amount of aWETH to withdraw and receive native ETH\n     * @param to address of the user who will receive native ETH\n     * @param deadline validity deadline of permit and so depositWithPermit signature\n     * @param permitV V parameter of ERC712 permit sig\n     * @param permitR R parameter of ERC712 permit sig\n     * @param permitS S parameter of ERC712 permit sig\n     */\n    function withdrawETHWithPermit(\n        address,\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external override {\n        IAToken aWETH = IAToken(POOL.getReserveData(address(WETH)).aTokenAddress);\n        uint256 userBalance = aWETH.balanceOf(msg.sender);\n        uint256 amountToWithdraw = amount;\n\n        // if amount is equal to type(uint256).max, the user wants to redeem everything\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n        // permit `amount` rather than `amountToWithdraw` to make it easier for front-ends and integrators\n        aWETH.permit(msg.sender, address(this), amount, deadline, permitV, permitR, permitS);\n        aWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n        POOL.withdraw(address(WETH), amountToWithdraw, address(this));\n        WETH.withdraw(amountToWithdraw);\n        _safeTransferETH(to, amountToWithdraw);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n     * direct transfers to the contract address.\n     * @param token token to transfer\n     * @param to recipient of the transfer\n     * @param amount amount to send\n     */\n    function emergencyTokenTransfer(address token, address to, uint256 amount) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n     * due to selfdestructs or ether transfers to the pre-computed contract address before deployment.\n     * @param to recipient of the transfer\n     * @param amount amount to send\n     */\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\n        _safeTransferETH(to, amount);\n    }\n\n    /**\n     * @dev Get WETH address used by WrappedTokenGatewayV3\n     */\n    function getWETHAddress() external view returns (address) {\n        return address(WETH);\n    }\n\n    /**\n     * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n     */\n    receive() external payable {\n        require(msg.sender == address(WETH), \"Receive not allowed\");\n    }\n\n    /**\n     * @dev Revert fallback calls\n     */\n    fallback() external payable {\n        revert(\"Fallback not allowed\");\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/EmissionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { Ownable } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { IEmissionManager } from \"./interfaces/IEmissionManager.sol\";\nimport { ITransferStrategyBase } from \"./interfaces/ITransferStrategyBase.sol\";\nimport { IRewardsController } from \"./interfaces/IRewardsController.sol\";\nimport { RewardsDataTypes } from \"./libraries/RewardsDataTypes.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title EmissionManager\n * @author Aave\n * @notice It manages the list of admins of reward emissions and provides functions to control reward emissions.\n */\ncontract EmissionManager is Ownable, IEmissionManager {\n    // reward => emissionAdmin\n    mapping(address => address) internal _emissionAdmins;\n\n    IRewardsController internal _rewardsController;\n\n    /**\n     * @dev Only emission admin of the given reward can call functions marked by this modifier.\n     **/\n    modifier onlyEmissionAdmin(address reward) {\n        require(msg.sender == _emissionAdmins[reward], \"ONLY_EMISSION_ADMIN\");\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param owner The address of the owner\n     */\n    constructor(address owner) {\n        transferOwnership(owner);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external override {\n        for (uint256 i = 0; i < config.length; i++) {\n            require(_emissionAdmins[config[i].reward] == msg.sender, \"ONLY_EMISSION_ADMIN\");\n        }\n        _rewardsController.configureAssets(config);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setTransferStrategy(\n        address reward,\n        ITransferStrategyBase transferStrategy\n    ) external override onlyEmissionAdmin(reward) {\n        _rewardsController.setTransferStrategy(reward, transferStrategy);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external override onlyEmissionAdmin(reward) {\n        _rewardsController.setRewardOracle(reward, rewardOracle);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setDistributionEnd(\n        address asset,\n        address reward,\n        uint32 newDistributionEnd\n    ) external override onlyEmissionAdmin(reward) {\n        _rewardsController.setDistributionEnd(asset, reward, newDistributionEnd);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external override {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            require(_emissionAdmins[rewards[i]] == msg.sender, \"ONLY_EMISSION_ADMIN\");\n        }\n        _rewardsController.setEmissionPerSecond(asset, rewards, newEmissionsPerSecond);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setClaimer(address user, address claimer) external override onlyOwner {\n        _rewardsController.setClaimer(user, claimer);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setEmissionAdmin(address reward, address admin) external override onlyOwner {\n        address oldAdmin = _emissionAdmins[reward];\n        _emissionAdmins[reward] = admin;\n        emit EmissionAdminUpdated(reward, oldAdmin, admin);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function setRewardsController(address controller) external override onlyOwner {\n        _rewardsController = IRewardsController(controller);\n    }\n\n    /// @inheritdoc IEmissionManager\n    function getRewardsController() external view override returns (IRewardsController) {\n        return _rewardsController;\n    }\n\n    /// @inheritdoc IEmissionManager\n    function getEmissionAdmin(address reward) external view override returns (address) {\n        return _emissionAdmins[reward];\n    }\n\n    /// @inheritdoc IEmissionManager\n    function depositReward(address reward, uint256 amount) external {\n        require(amount > 0, \"ZERO_AMOUNT\");\n        _rewardsController.depositRewardFrom(reward, amount, msg.sender);\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IEmissionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { RewardsDataTypes } from \"../libraries/RewardsDataTypes.sol\";\nimport { ITransferStrategyBase } from \"./ITransferStrategyBase.sol\";\nimport { IRewardsController } from \"./IRewardsController.sol\";\n\n/**\n * @title IEmissionManager\n * @author Aave\n * @notice Defines the basic interface for the Emission Manager\n */\ninterface IEmissionManager {\n    /**\n     * @dev Emitted when the admin of a reward emission is updated.\n     * @param reward The address of the rewarding token\n     * @param oldAdmin The address of the old emission admin\n     * @param newAdmin The address of the new emission admin\n     */\n    event EmissionAdminUpdated(address indexed reward, address indexed oldAdmin, address indexed newAdmin);\n\n    /**\n     * @dev Configure assets to incentivize with an emission of rewards per second until the end of distribution.\n     * @dev Only callable by the emission admin of the given rewards\n     * @param config The assets configuration input, the list of structs contains the following fields:\n     *   uint104 emissionPerSecond: The emission per second following rewards unit decimals.\n     *   uint256 totalSupply: The total supply of the asset to incentivize\n     *   uint40 distributionEnd: The end of the distribution of the incentives for an asset\n     *   address asset: The asset address to incentivize\n     *   address reward: The reward token address\n     *   ITransferStrategy transferStrategy: The TransferStrategy address with the install hook and claim logic.\n     *   IAaveOracle rewardOracle: The Price Oracle of a reward to visualize the incentives at the UI Frontend.\n     */\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external;\n\n    /**\n     * @dev Sets a TransferStrategy logic contract that determines the logic of the rewards transfer\n     * @dev Only callable by the emission admin of the given reward\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the TransferStrategy logic contract\n     */\n    function setTransferStrategy(address reward, ITransferStrategyBase transferStrategy) external;\n\n    /**\n     * @dev Sets an Aave Oracle contract to enforce rewards with a source of value.\n     * @dev Only callable by the emission admin of the given reward\n     * @notice At the moment of reward configuration, the Incentives Controller performs\n     * a check to see if the reward asset oracle is compatible with IAaveOracle interface.\n     * This check is enforced for integrators to be able to show incentives at\n     * the current Aave UI without the need to setup an external price registry\n     * @param reward The address of the reward to set the price aggregator\n     * @param rewardOracle The address of price aggregator that follows IAaveOracle interface\n     */\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external;\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @dev Only callable by the emission admin of the given reward\n     * @param asset The asset to incentivize\n     * @param reward The reward token that incentives the asset\n     * @param newDistributionEnd The end date of the incentivization, in unix time format\n     **/\n    function setDistributionEnd(address asset, address reward, uint32 newDistributionEnd) external;\n\n    /**\n     * @dev Sets the emission per second of a set of reward distributions\n     * @param asset The asset is being incentivized\n     * @param rewards List of reward addresses are being distributed\n     * @param newEmissionsPerSecond List of new reward emissions per second\n     */\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @dev Only callable by the owner of the EmissionManager\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Updates the admin of the reward emission\n     * @dev Only callable by the owner of the EmissionManager\n     * @param reward The address of the reward token\n     * @param admin The address of the new admin of the emission\n     */\n    function setEmissionAdmin(address reward, address admin) external;\n\n    /**\n     * @dev Updates the address of the rewards controller\n     * @dev Only callable by the owner of the EmissionManager\n     * @param controller the address of the RewardsController contract\n     */\n    function setRewardsController(address controller) external;\n\n    /**\n     * @dev Returns the rewards controller address\n     * @return The address of the RewardsController contract\n     */\n    function getRewardsController() external view returns (IRewardsController);\n\n    /**\n     * @dev Returns the admin of the given reward emission\n     * @param reward The address of the reward token\n     * @return The address of the emission admin\n     */\n    function getEmissionAdmin(address reward) external view returns (address);\n\n    /**\n     * @dev Recieve more fund from the user to existing reward\n     * @param reward The reward address is being distributed\n     * @param amount The token amount is being funded\n     */\n    function depositReward(address reward, uint256 amount) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IPullRewardsTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { ITransferStrategyBase } from \"./ITransferStrategyBase.sol\";\n\n/**\n * @title IPullRewardsTransferStrategy\n * @author Aave\n **/\ninterface IPullRewardsTransferStrategy is ITransferStrategyBase {\n    /**\n     * @return Address of the rewards vault\n     */\n    function getRewardsVault() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { IRewardsDistributor } from \"./IRewardsDistributor.sol\";\nimport { ITransferStrategyBase } from \"./ITransferStrategyBase.sol\";\nimport { RewardsDataTypes } from \"../libraries/RewardsDataTypes.sol\";\n\n/**\n * @title IRewardsController\n * @author Aave\n * @notice Defines the basic interface for a Rewards Controller.\n */\ninterface IRewardsController is IRewardsDistributor {\n    /**\n     * @dev Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @dev Emitted when rewards are claimed\n     * @param user The address of the user rewards has been claimed on behalf of\n     * @param reward The address of the token reward is claimed\n     * @param to The address of the receiver of the rewards\n     * @param claimer The address of the claimer\n     * @param amount The amount of rewards claimed\n     */\n    event RewardsClaimed(\n        address indexed user,\n        address indexed reward,\n        address indexed to,\n        address claimer,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a transfer strategy is installed for the reward distribution\n     * @param reward The address of the token reward\n     * @param transferStrategy The address of TransferStrategy contract\n     */\n    event TransferStrategyInstalled(address indexed reward, address indexed transferStrategy);\n\n    /**\n     * @dev Emitted when the reward oracle is updated\n     * @param reward The address of the token reward\n     * @param rewardOracle The address of oracle\n     */\n    event RewardOracleUpdated(address indexed reward, address indexed rewardOracle);\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Sets a TransferStrategy logic contract that determines the logic of the rewards transfer\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the TransferStrategy logic contract\n     */\n    function setTransferStrategy(address reward, ITransferStrategyBase transferStrategy) external;\n\n    /**\n     * @dev Sets an Aave Oracle contract to enforce rewards with a source of value.\n     * @notice At the moment of reward configuration, the Incentives Controller performs\n     * a check to see if the reward asset oracle is compatible with IAaveOracle interface.\n     * This check is enforced for integrators to be able to show incentives at\n     * the current Aave UI without the need to setup an external price registry\n     * @param reward The address of the reward to set the price aggregator\n     * @param rewardOracle The address of price aggregator that follows IAaveOracle interface\n     */\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external;\n\n    /**\n     * @dev Get the price aggregator oracle address\n     * @param reward The address of the reward\n     * @return The price oracle of the reward\n     */\n    function getRewardOracle(address reward) external view returns (address);\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Returns the Transfer Strategy implementation contract address being used for a reward address\n     * @param reward The address of the reward\n     * @return The address of the TransferStrategy contract\n     */\n    function getTransferStrategy(address reward) external view returns (address);\n\n    /**\n     * @dev Configure assets to incentivize with an emission of rewards per second until the end of distribution.\n     * @param config The assets configuration input, the list of structs contains the following fields:\n     *   uint104 emissionPerSecond: The emission per second following rewards unit decimals.\n     *   uint256 totalSupply: The total supply of the asset to incentivize\n     *   uint40 distributionEnd: The end of the distribution of the incentives for an asset\n     *   address asset: The asset address to incentivize\n     *   address reward: The reward token address\n     *   ITransferStrategy transferStrategy: The TransferStrategy address with the install hook and claim logic.\n     *   IAaveOracle rewardOracle: The Price Oracle of a reward to visualize the incentives at the UI Frontend.\n     */\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external;\n\n    /**\n     * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n     * @dev The units of `totalSupply` and `userBalance` should be the same.\n     * @param user The address of the user whose asset balance has changed\n     * @param totalSupply The total supply of the asset prior to user balance change\n     * @param userBalance The previous user balance prior to balance change\n     **/\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n\n    /**\n     * @dev Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The\n     * caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsToSelf(address[] calldata assets, uint256 amount, address reward) external returns (uint256);\n\n    /**\n     * @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardList\"\n     **/\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Recieve more fund from the user to existing reward\n     * @param reward The reward address is being distributed\n     * @param amount The token amount is being funded\n     * @param from The address of the one who funds the rewards\n     */\n    function depositRewardFrom(address reward, uint256 amount, address from) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IRewardsDistributor\n * @author Aave\n * @notice Defines the basic interface for a Rewards Distributor.\n */\ninterface IRewardsDistributor {\n    /**\n     * @dev Emitted when the configuration of the rewards of an asset is updated.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param oldEmission The old emissions per second value of the reward distribution\n     * @param newEmission The new emissions per second value of the reward distribution\n     * @param oldDistributionEnd The old end timestamp of the reward distribution\n     * @param newDistributionEnd The new end timestamp of the reward distribution\n     * @param assetIndex The index of the asset distribution\n     */\n    event AssetConfigUpdated(\n        address indexed asset,\n        address indexed reward,\n        uint256 oldEmission,\n        uint256 newEmission,\n        uint256 oldDistributionEnd,\n        uint256 newDistributionEnd,\n        uint256 assetIndex\n    );\n\n    /**\n     * @dev Emitted when rewards of an asset are accrued on behalf of a user.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param user The address of the user that rewards are accrued on behalf of\n     * @param assetIndex The index of the asset distribution\n     * @param userIndex The index of the asset distribution on behalf of the user\n     * @param rewardsAccrued The amount of rewards accrued\n     */\n    event Accrued(\n        address indexed asset,\n        address indexed reward,\n        address indexed user,\n        uint256 assetIndex,\n        uint256 userIndex,\n        uint256 rewardsAccrued\n    );\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param asset The asset to incentivize\n     * @param reward The reward token that incentives the asset\n     * @param newDistributionEnd The end date of the incentivization, in unix time format\n     **/\n    function setDistributionEnd(address asset, address reward, uint32 newDistributionEnd) external;\n\n    /**\n     * @dev Sets the emission per second of a set of reward distributions\n     * @param asset The asset is being incentivized\n     * @param rewards List of reward addresses are being distributed\n     * @param newEmissionsPerSecond List of new reward emissions per second\n     */\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Gets the end date for the distribution\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The timestamp with the end of the distribution, in unix time format\n     **/\n    function getDistributionEnd(address asset, address reward) external view returns (uint256);\n\n    /**\n     * @dev Returns the index of a user on a reward distribution\n     * @param user Address of the user\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The current user asset index, not including new distributions\n     **/\n    function getUserAssetIndex(address user, address asset, address reward) external view returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution reward for a certain asset\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The index of the asset distribution\n     * @return The emission per second of the reward distribution\n     * @return The timestamp of the last update of the index\n     * @return The timestamp of the distribution end\n     **/\n    function getRewardsData(address asset, address reward) external view returns (uint256, uint256, uint256, uint256);\n\n    /**\n     * @dev Calculates the next value of an specific distribution index, with validations.\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The old index of the asset distribution\n     * @return The new index of the asset distribution\n     **/\n    function getAssetIndex(address asset, address reward) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the list of available reward token addresses of an incentivized asset\n     * @param asset The incentivized asset\n     * @return List of rewards addresses of the input asset\n     **/\n    function getRewardsByAsset(address asset) external view returns (address[] memory);\n\n    /**\n     * @dev Returns the list of available reward addresses\n     * @return List of rewards supported in this contract\n     **/\n    function getRewardsList() external view returns (address[] memory);\n\n    /**\n     * @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return Unclaimed rewards, not including new distributions\n     **/\n    function getUserAccruedRewards(address user, address reward) external view returns (uint256);\n\n    /**\n     * @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return The rewards amount\n     **/\n    function getUserRewards(address[] calldata assets, address user, address reward) external view returns (uint256);\n\n    /**\n     * @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @return The list of reward addresses\n     * @return The list of unclaimed amount of rewards\n     **/\n    function getAllUserRewards(\n        address[] calldata assets,\n        address user\n    ) external view returns (address[] memory, uint256[] memory);\n\n    /**\n     * @dev Returns the decimals of an asset to calculate the distribution delta\n     * @param asset The address to retrieve decimals\n     * @return The decimals of an underlying asset\n     */\n    function getAssetDecimals(address asset) external view returns (uint8);\n\n    /**\n     * @dev Returns the address of the emission manager\n     * @return The address of the EmissionManager\n     */\n    function EMISSION_MANAGER() external view returns (address);\n\n    /**\n     * @dev Returns the address of the emission manager.\n     * Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.\n     * @return The address of the EmissionManager\n     */\n    function getEmissionManager() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IStakedToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IStakedToken {\n    function STAKED_TOKEN() external view returns (address);\n\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IStakedTokenTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IStakedToken } from \"../interfaces/IStakedToken.sol\";\nimport { ITransferStrategyBase } from \"./ITransferStrategyBase.sol\";\n\n/**\n * @title IStakedTokenTransferStrategy\n * @author Aave\n **/\ninterface IStakedTokenTransferStrategy is ITransferStrategyBase {\n    /**\n     * @dev Perform a MAX_UINT approval of AAVE to the Staked Aave contract.\n     */\n    function renewApproval() external;\n\n    /**\n     * @dev Drop approval of AAVE to the Staked Aave contract in case of emergency.\n     */\n    function dropApproval() external;\n\n    /**\n     * @return Staked Token contract address\n     */\n    function getStakeContract() external view returns (address);\n\n    /**\n     * @return Underlying token address from the stake contract\n     */\n    function getUnderlyingToken() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/ITransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface ITransferStrategyBase {\n    event EmergencyWithdrawal(address indexed caller, address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @param to Account to transfer rewards\n     * @param reward Address of the reward token\n     * @param amount Amount to transfer to the \"to\" address parameter\n     * @return Returns true bool if transfer logic succeeds\n     */\n    function performTransfer(address to, address reward, uint256 amount) external returns (bool);\n\n    /**\n     * @return Returns the address of the Incentives Controller\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @return Returns the address of the Rewards admin\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /**\n     * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/libraries/RewardsDataTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { ITransferStrategyBase } from \"../interfaces/ITransferStrategyBase.sol\";\n\nlibrary RewardsDataTypes {\n    struct RewardsConfigInput {\n        uint88 emissionPerSecond;\n        uint256 totalSupply;\n        uint32 distributionEnd;\n        address asset;\n        address reward;\n        ITransferStrategyBase transferStrategy;\n        IAaveOracle rewardOracle;\n    }\n\n    struct UserAssetBalance {\n        address asset;\n        uint256 userBalance;\n        uint256 totalSupply;\n    }\n\n    struct UserData {\n        // Liquidity index of the reward distribution for the user\n        uint104 index;\n        // Amount of accrued rewards for the user since last user index update\n        uint128 accrued;\n    }\n\n    struct RewardData {\n        // Liquidity index of the reward distribution\n        uint104 index;\n        // Amount of reward tokens distributed per second\n        uint88 emissionPerSecond;\n        // Timestamp of the last reward index update\n        uint32 lastUpdateTimestamp;\n        // The end of the distribution of rewards (in seconds)\n        uint32 distributionEnd;\n        // Map of user addresses and their rewards data (userAddress => userData)\n        mapping(address => UserData) usersData;\n    }\n\n    struct AssetData {\n        // Map of reward token addresses and their data (rewardTokenAddress => rewardData)\n        mapping(address => RewardData) rewards;\n        // List of reward token addresses for the asset\n        mapping(uint128 => address) availableRewards;\n        // Count of reward tokens for the asset\n        uint128 availableRewardsCount;\n        // Number of decimals of the asset\n        uint8 decimals;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/RewardsController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { VersionedInitializable } from \"contracts/dlend/core/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { SafeCast } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IAaveOracle } from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport { IScaledBalanceToken } from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport { RewardsDistributor } from \"./RewardsDistributor.sol\";\nimport { IRewardsController } from \"./interfaces/IRewardsController.sol\";\nimport { ITransferStrategyBase } from \"./interfaces/ITransferStrategyBase.sol\";\nimport { IPullRewardsTransferStrategy } from \"./interfaces/IPullRewardsTransferStrategy.sol\";\nimport { RewardsDataTypes } from \"./libraries/RewardsDataTypes.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { SafeERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeERC20.sol\";\n\n/**\n * @title RewardsController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\ncontract RewardsController is RewardsDistributor, VersionedInitializable, IRewardsController {\n    using SafeCast for uint256;\n\n    // Increment this value when deploying a new implementation\n    // Current testnet implementation: 4\n    uint256 public constant REVISION = 2;\n\n    // This mapping allows whitelisted addresses to claim on behalf of others\n    // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n    mapping(address => address) internal _authorizedClaimers;\n\n    // reward => transfer strategy implementation contract\n    // The TransferStrategy contract abstracts the logic regarding\n    // the source of the reward and how to transfer it to the user.\n    mapping(address => ITransferStrategyBase) internal _transferStrategy;\n\n    // This mapping contains the price oracle per reward.\n    // A price oracle is enforced for integrators to be able to show incentives at\n    // the current Aave UI without the need to setup an external price registry\n    // At the moment of reward configuration, the Incentives Controller performs\n    // a check to see if the provided reward oracle contains `getAssetPrice`.\n    mapping(address => IAaveOracle) internal _rewardOracle;\n\n    modifier onlyAuthorizedClaimers(address claimer, address user) {\n        require(_authorizedClaimers[user] == claimer, \"CLAIMER_UNAUTHORIZED\");\n        _;\n    }\n\n    constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n    /**\n     * @dev Initialize for RewardsController\n     * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n     **/\n    function initialize(address) external initializer {}\n\n    /// @inheritdoc IRewardsController\n    function getClaimer(address user) external view override returns (address) {\n        return _authorizedClaimers[user];\n    }\n\n    /**\n     * @dev Returns the revision of the implementation contract\n     * @return uint256, current revision version\n     */\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /// @inheritdoc IRewardsController\n    function getRewardOracle(address reward) external view override returns (address) {\n        return address(_rewardOracle[reward]);\n    }\n\n    /// @inheritdoc IRewardsController\n    function getTransferStrategy(address reward) external view override returns (address) {\n        return address(_transferStrategy[reward]);\n    }\n\n    /// @inheritdoc IRewardsController\n    function configureAssets(\n        RewardsDataTypes.RewardsConfigInput[] memory config\n    ) external override onlyEmissionManager {\n        for (uint256 i = 0; i < config.length; i++) {\n            // Get the current Scaled Total Supply of AToken or Debt token\n            config[i].totalSupply = IScaledBalanceToken(config[i].asset).scaledTotalSupply();\n\n            // Install TransferStrategy logic at IncentivesController\n            _installTransferStrategy(config[i].reward, config[i].transferStrategy);\n\n            // Set reward oracle, enforces input oracle to have latestPrice function\n            _setRewardOracle(config[i].reward, config[i].rewardOracle);\n        }\n        _configureAssets(config);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setTransferStrategy(address reward, ITransferStrategyBase transferStrategy) external onlyEmissionManager {\n        _installTransferStrategy(reward, transferStrategy);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external onlyEmissionManager {\n        _setRewardOracle(reward, rewardOracle);\n    }\n\n    /// @inheritdoc IRewardsController\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override {\n        _updateData(msg.sender, user, userBalance, totalSupply);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external override returns (uint256) {\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimRewards(assets, amount, msg.sender, msg.sender, to, reward);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n        require(user != address(0), \"INVALID_USER_ADDRESS\");\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimRewards(assets, amount, msg.sender, user, to, reward);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward\n    ) external override returns (uint256) {\n        return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimAllRewards(assets, msg.sender, msg.sender, to);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    )\n        external\n        override\n        onlyAuthorizedClaimers(msg.sender, user)\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        require(user != address(0), \"INVALID_USER_ADDRESS\");\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimAllRewards(assets, msg.sender, user, to);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n        return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setClaimer(address user, address caller) external override onlyEmissionManager {\n        _authorizedClaimers[user] = caller;\n        emit ClaimerSet(user, caller);\n    }\n\n    /// @inheritdoc IRewardsController\n    function depositRewardFrom(address reward, uint256 amount, address from) external onlyEmissionManager {\n        require(_isRewardEnabled[reward] == true, \"ONLY_ALLOW_DEPOSIT_TO_ENABLED_REWARD\");\n        address transferStrategyAddress = address(_transferStrategy[reward]);\n\n        try IPullRewardsTransferStrategy(transferStrategyAddress).getRewardsVault() returns (address vault) {\n            uint256 beforeTotalRewardSupply = IERC20(reward).balanceOf(vault);\n            uint256 expectAfterTotalRewardSupply = beforeTotalRewardSupply + amount;\n            SafeERC20.safeTransferFrom(IERC20(reward), from, vault, amount);\n            uint256 afterTotalRewardSupplyAfterDeposit = IERC20(reward).balanceOf(vault);\n            require(\n                afterTotalRewardSupplyAfterDeposit == expectAfterTotalRewardSupply,\n                \"INVALID_REWARD_DEPOSIT_AMOUNT\"\n            );\n        } catch {\n            revert(\"ONLY_ALLOW_DEPOSIT_TO_PULL_REWARDS_TRANSFER_STRATEGY\");\n        }\n    }\n\n    /**\n     * @dev Get user balances and total supply of all the assets specified by the assets parameter\n     * @param assets List of assets to retrieve user balance and total supply\n     * @param user Address of the user\n     * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n     */\n    function _getUserAssetBalances(\n        address[] calldata assets,\n        address user\n    ) internal view override returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances) {\n        userAssetBalances = new RewardsDataTypes.UserAssetBalance[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            userAssetBalances[i].asset = assets[i];\n            (userAssetBalances[i].userBalance, userAssetBalances[i].totalSupply) = IScaledBalanceToken(assets[i])\n                .getScaledUserBalanceAndSupply(user);\n        }\n        return userAssetBalances;\n    }\n\n    /**\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount Amount of rewards to claim\n     * @param claimer Address of the claimer who claims rewards on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @param reward Address of the reward token\n     * @return Rewards claimed\n     **/\n    function _claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address claimer,\n        address user,\n        address to,\n        address reward\n    ) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 totalRewards;\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            totalRewards += _assets[asset].rewards[reward].usersData[user].accrued;\n\n            if (totalRewards <= amount) {\n                _assets[asset].rewards[reward].usersData[user].accrued = 0;\n            } else {\n                uint256 difference = totalRewards - amount;\n                totalRewards -= difference;\n                _assets[asset].rewards[reward].usersData[user].accrued = difference.toUint128();\n                break;\n            }\n        }\n\n        if (totalRewards == 0) {\n            return 0;\n        }\n\n        _transferRewards(to, reward, totalRewards);\n        emit RewardsClaimed(user, reward, to, claimer, totalRewards);\n\n        return totalRewards;\n    }\n\n    /**\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param claimer Address of the claimer on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return\n     *   rewardsList List of reward addresses\n     *   claimedAmount List of claimed amounts, follows \"rewardsList\" items order\n     **/\n    function _claimAllRewards(\n        address[] calldata assets,\n        address claimer,\n        address user,\n        address to\n    ) internal returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n        uint256 rewardsListLength = _rewardsList.length;\n        rewardsList = new address[](rewardsListLength);\n        claimedAmounts = new uint256[](rewardsListLength);\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            for (uint256 j = 0; j < rewardsListLength; j++) {\n                if (rewardsList[j] == address(0)) {\n                    rewardsList[j] = _rewardsList[j];\n                }\n                uint256 rewardAmount = _assets[asset].rewards[rewardsList[j]].usersData[user].accrued;\n                if (rewardAmount != 0) {\n                    claimedAmounts[j] += rewardAmount;\n                    _assets[asset].rewards[rewardsList[j]].usersData[user].accrued = 0;\n                }\n            }\n        }\n        for (uint256 i = 0; i < rewardsListLength; i++) {\n            _transferRewards(to, rewardsList[i], claimedAmounts[i]);\n            emit RewardsClaimed(user, rewardsList[i], to, claimer, claimedAmounts[i]);\n        }\n        return (rewardsList, claimedAmounts);\n    }\n\n    /**\n     * @dev Function to transfer rewards to the desired account using delegatecall and\n     * @param to Account address to send the rewards\n     * @param reward Address of the reward token\n     * @param amount Amount of rewards to transfer\n     */\n    function _transferRewards(address to, address reward, uint256 amount) internal {\n        ITransferStrategyBase transferStrategy = _transferStrategy[reward];\n\n        bool success = transferStrategy.performTransfer(to, reward, amount);\n\n        require(success == true, \"TRANSFER_ERROR\");\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     * @param account The address of the account\n     * @return bool, true if contract, false otherwise\n     */\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Internal function to call the optional install hook at the TransferStrategy\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the reward TransferStrategy\n     */\n    function _installTransferStrategy(address reward, ITransferStrategyBase transferStrategy) internal {\n        require(address(transferStrategy) != address(0), \"STRATEGY_CAN_NOT_BE_ZERO\");\n        require(_isContract(address(transferStrategy)) == true, \"STRATEGY_MUST_BE_CONTRACT\");\n\n        _transferStrategy[reward] = transferStrategy;\n\n        emit TransferStrategyInstalled(reward, address(transferStrategy));\n    }\n\n    /**\n     * @dev Update the Price Oracle of a reward token. The Price Oracle must follow IAaveOracle interface.\n     * @notice The Price Oracle of a reward is used for displaying correct data about the incentives at the UI frontend.\n     * @param reward The address of the reward token\n     * @param rewardOracle The address of the price oracle\n     */\n\n    function _setRewardOracle(address reward, IAaveOracle rewardOracle) internal {\n        require(rewardOracle.getAssetPrice(rewardOracle.BASE_CURRENCY()) > 0, \"ORACLE_MUST_RETURN_PRICE\");\n        _rewardOracle[reward] = rewardOracle;\n        emit RewardOracleUpdated(reward, address(rewardOracle));\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/RewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IScaledBalanceToken } from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport { IERC20Detailed } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { SafeCast } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { IRewardsDistributor } from \"./interfaces/IRewardsDistributor.sol\";\nimport { RewardsDataTypes } from \"./libraries/RewardsDataTypes.sol\";\n\n/**\n * @title RewardsDistributor\n * @notice Accounting contract to manage multiple staking distributions with multiple rewards\n * @author Aave\n **/\nabstract contract RewardsDistributor is IRewardsDistributor {\n    using SafeCast for uint256;\n\n    // Manager of incentives\n    address public immutable EMISSION_MANAGER;\n    // Deprecated: This storage slot is kept for backwards compatibility purposes.\n    address internal _emissionManager;\n\n    // Map of rewarded asset addresses and their data (assetAddress => assetData)\n    mapping(address => RewardsDataTypes.AssetData) internal _assets;\n\n    // Map of reward assets (rewardAddress => enabled)\n    mapping(address => bool) internal _isRewardEnabled;\n\n    // Rewards list\n    address[] internal _rewardsList;\n\n    // Assets list\n    address[] internal _assetsList;\n\n    modifier onlyEmissionManager() {\n        require(msg.sender == EMISSION_MANAGER, \"ONLY_EMISSION_MANAGER\");\n        _;\n    }\n\n    constructor(address emissionManager) {\n        EMISSION_MANAGER = emissionManager;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsData(\n        address asset,\n        address reward\n    ) public view override returns (uint256, uint256, uint256, uint256) {\n        return (\n            _assets[asset].rewards[reward].index,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            _assets[asset].rewards[reward].lastUpdateTimestamp,\n            _assets[asset].rewards[reward].distributionEnd\n        );\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getAssetIndex(address asset, address reward) external view override returns (uint256, uint256) {\n        RewardsDataTypes.RewardData storage rewardData = _assets[asset].rewards[reward];\n        return\n            _getAssetIndex(rewardData, IScaledBalanceToken(asset).scaledTotalSupply(), 10 ** _assets[asset].decimals);\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getDistributionEnd(address asset, address reward) external view override returns (uint256) {\n        return _assets[asset].rewards[reward].distributionEnd;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsByAsset(address asset) external view override returns (address[] memory) {\n        uint128 rewardsCount = _assets[asset].availableRewardsCount;\n        address[] memory availableRewards = new address[](rewardsCount);\n\n        for (uint128 i = 0; i < rewardsCount; i++) {\n            availableRewards[i] = _assets[asset].availableRewards[i];\n        }\n        return availableRewards;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsList() external view override returns (address[] memory) {\n        return _rewardsList;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserAssetIndex(address user, address asset, address reward) public view override returns (uint256) {\n        return _assets[asset].rewards[reward].usersData[user].index;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserAccruedRewards(address user, address reward) external view override returns (uint256) {\n        uint256 totalAccrued;\n        for (uint256 i = 0; i < _assetsList.length; i++) {\n            totalAccrued += _assets[_assetsList[i]].rewards[reward].usersData[user].accrued;\n        }\n\n        return totalAccrued;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserRewards(\n        address[] calldata assets,\n        address user,\n        address reward\n    ) external view override returns (uint256) {\n        return _getUserReward(user, reward, _getUserAssetBalances(assets, user));\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getAllUserRewards(\n        address[] calldata assets,\n        address user\n    ) external view override returns (address[] memory rewardsList, uint256[] memory unclaimedAmounts) {\n        RewardsDataTypes.UserAssetBalance[] memory userAssetBalances = _getUserAssetBalances(assets, user);\n        rewardsList = new address[](_rewardsList.length);\n        unclaimedAmounts = new uint256[](rewardsList.length);\n\n        // Add unrealized rewards from user to unclaimedRewards\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            for (uint256 r = 0; r < rewardsList.length; r++) {\n                rewardsList[r] = _rewardsList[r];\n                unclaimedAmounts[r] += _assets[userAssetBalances[i].asset]\n                    .rewards[rewardsList[r]]\n                    .usersData[user]\n                    .accrued;\n\n                if (userAssetBalances[i].userBalance == 0) {\n                    continue;\n                }\n                unclaimedAmounts[r] += _getPendingRewards(user, rewardsList[r], userAssetBalances[i]);\n            }\n        }\n        return (rewardsList, unclaimedAmounts);\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function setDistributionEnd(\n        address asset,\n        address reward,\n        uint32 newDistributionEnd\n    ) external override onlyEmissionManager {\n        uint256 oldDistributionEnd = _assets[asset].rewards[reward].distributionEnd;\n        _assets[asset].rewards[reward].distributionEnd = newDistributionEnd;\n\n        emit AssetConfigUpdated(\n            asset,\n            reward,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            oldDistributionEnd,\n            newDistributionEnd,\n            _assets[asset].rewards[reward].index\n        );\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external override onlyEmissionManager {\n        require(rewards.length == newEmissionsPerSecond.length, \"INVALID_INPUT\");\n        _setEmissionPerSecond(asset, rewards, newEmissionsPerSecond);\n    }\n\n    function _setEmissionPerSecond(\n        address asset,\n        // use memory instead of calldata because this function will be used for other internal function\n        address[] memory rewards,\n        uint88[] memory newEmissionsPerSecond\n    ) internal {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            RewardsDataTypes.AssetData storage assetConfig = _assets[asset];\n            RewardsDataTypes.RewardData storage rewardConfig = _assets[asset].rewards[rewards[i]];\n            uint256 decimals = assetConfig.decimals;\n            require(decimals != 0 && rewardConfig.lastUpdateTimestamp != 0, \"DISTRIBUTION_DOES_NOT_EXIST\");\n\n            (uint256 newIndex, ) = _updateRewardData(\n                rewardConfig,\n                IScaledBalanceToken(asset).scaledTotalSupply(),\n                10 ** decimals\n            );\n\n            uint256 oldEmissionPerSecond = rewardConfig.emissionPerSecond;\n            rewardConfig.emissionPerSecond = newEmissionsPerSecond[i];\n\n            emit AssetConfigUpdated(\n                asset,\n                rewards[i],\n                oldEmissionPerSecond,\n                newEmissionsPerSecond[i],\n                rewardConfig.distributionEnd,\n                rewardConfig.distributionEnd,\n                newIndex\n            );\n        }\n    }\n\n    /**\n     * @dev Configure the _assets for a specific emission\n     * @param rewardsInput The array of each asset configuration\n     **/\n    function _configureAssets(RewardsDataTypes.RewardsConfigInput[] memory rewardsInput) internal {\n        for (uint256 i = 0; i < rewardsInput.length; i++) {\n            if (_assets[rewardsInput[i].asset].decimals == 0) {\n                //never initialized before, adding to the list of assets\n                _assetsList.push(rewardsInput[i].asset);\n            }\n\n            uint256 decimals = _assets[rewardsInput[i].asset].decimals = IERC20Detailed(rewardsInput[i].asset)\n                .decimals();\n\n            RewardsDataTypes.RewardData storage rewardConfig = _assets[rewardsInput[i].asset].rewards[\n                rewardsInput[i].reward\n            ];\n\n            // Add reward address to asset available rewards if latestUpdateTimestamp is zero\n            if (rewardConfig.lastUpdateTimestamp == 0) {\n                _assets[rewardsInput[i].asset].availableRewards[\n                    _assets[rewardsInput[i].asset].availableRewardsCount\n                ] = rewardsInput[i].reward;\n                _assets[rewardsInput[i].asset].availableRewardsCount++;\n            }\n\n            // Add reward address to global rewards list if still not enabled\n            if (_isRewardEnabled[rewardsInput[i].reward] == false) {\n                _isRewardEnabled[rewardsInput[i].reward] = true;\n                _rewardsList.push(rewardsInput[i].reward);\n            }\n\n            // Due emissions is still zero, updates only latestUpdateTimestamp\n            (uint256 newIndex, ) = _updateRewardData(rewardConfig, rewardsInput[i].totalSupply, 10 ** decimals);\n\n            // Configure emission and distribution end of the reward per asset\n            uint88 oldEmissionsPerSecond = rewardConfig.emissionPerSecond;\n            uint32 oldDistributionEnd = rewardConfig.distributionEnd;\n            rewardConfig.emissionPerSecond = rewardsInput[i].emissionPerSecond;\n            rewardConfig.distributionEnd = rewardsInput[i].distributionEnd;\n\n            emit AssetConfigUpdated(\n                rewardsInput[i].asset,\n                rewardsInput[i].reward,\n                oldEmissionsPerSecond,\n                rewardsInput[i].emissionPerSecond,\n                oldDistributionEnd,\n                rewardsInput[i].distributionEnd,\n                newIndex\n            );\n        }\n    }\n\n    /**\n     * @dev Updates the state of the distribution for the specified reward\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param totalSupply Current total of underlying assets for this distribution\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The new distribution index\n     * @return True if the index was updated, false otherwise\n     **/\n    function _updateRewardData(\n        RewardsDataTypes.RewardData storage rewardData,\n        uint256 totalSupply,\n        uint256 assetUnit\n    ) internal returns (uint256, bool) {\n        (uint256 oldIndex, uint256 newIndex) = _getAssetIndex(rewardData, totalSupply, assetUnit);\n        bool indexUpdated;\n        if (newIndex != oldIndex) {\n            require(newIndex <= type(uint104).max, \"INDEX_OVERFLOW\");\n            indexUpdated = true;\n\n            //optimization: storing one after another saves one SSTORE\n            rewardData.index = uint104(newIndex);\n            rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n        } else {\n            rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n        }\n\n        return (newIndex, indexUpdated);\n    }\n\n    /**\n     * @dev Updates the state of the distribution for the specific user\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param user The address of the user\n     * @param userBalance The user balance of the asset\n     * @param newAssetIndex The new index of the asset distribution\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The rewards accrued since the last update\n     **/\n    function _updateUserData(\n        RewardsDataTypes.RewardData storage rewardData,\n        address user,\n        uint256 userBalance,\n        uint256 newAssetIndex,\n        uint256 assetUnit\n    ) internal returns (uint256, bool) {\n        uint256 userIndex = rewardData.usersData[user].index;\n        uint256 rewardsAccrued;\n        bool dataUpdated;\n        if ((dataUpdated = userIndex != newAssetIndex)) {\n            // already checked for overflow in _updateRewardData\n            rewardData.usersData[user].index = uint104(newAssetIndex);\n            if (userBalance != 0) {\n                rewardsAccrued = _getRewards(userBalance, newAssetIndex, userIndex, assetUnit);\n\n                rewardData.usersData[user].accrued += rewardsAccrued.toUint128();\n            }\n        }\n        return (rewardsAccrued, dataUpdated);\n    }\n\n    /**\n     * @dev Iterates and accrues all the rewards for asset of the specific user\n     * @param asset The address of the reference asset of the distribution\n     * @param user The user address\n     * @param userBalance The current user asset balance\n     * @param totalSupply Total supply of the asset\n     **/\n    function _updateData(address asset, address user, uint256 userBalance, uint256 totalSupply) internal {\n        uint256 assetUnit;\n        uint256 numAvailableRewards = _assets[asset].availableRewardsCount;\n        unchecked {\n            assetUnit = 10 ** _assets[asset].decimals;\n        }\n\n        if (numAvailableRewards == 0) {\n            return;\n        }\n        unchecked {\n            for (uint128 r = 0; r < numAvailableRewards; r++) {\n                address reward = _assets[asset].availableRewards[r];\n                RewardsDataTypes.RewardData storage rewardData = _assets[asset].rewards[reward];\n\n                (uint256 newAssetIndex, bool rewardDataUpdated) = _updateRewardData(rewardData, totalSupply, assetUnit);\n\n                (uint256 rewardsAccrued, bool userDataUpdated) = _updateUserData(\n                    rewardData,\n                    user,\n                    userBalance,\n                    newAssetIndex,\n                    assetUnit\n                );\n\n                if (rewardDataUpdated || userDataUpdated) {\n                    emit Accrued(asset, reward, user, newAssetIndex, newAssetIndex, rewardsAccrued);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Accrues all the rewards of the assets specified in the userAssetBalances list\n     * @param user The address of the user\n     * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n     **/\n    function _updateDataMultiple(address user, RewardsDataTypes.UserAssetBalance[] memory userAssetBalances) internal {\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            _updateData(\n                userAssetBalances[i].asset,\n                user,\n                userAssetBalances[i].userBalance,\n                userAssetBalances[i].totalSupply\n            );\n        }\n    }\n\n    /**\n     * @dev Return the accrued unclaimed amount of a reward from a user over a list of distribution\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n     * @return unclaimedRewards The accrued rewards for the user until the moment\n     **/\n    function _getUserReward(\n        address user,\n        address reward,\n        RewardsDataTypes.UserAssetBalance[] memory userAssetBalances\n    ) internal view returns (uint256 unclaimedRewards) {\n        // Add unrealized rewards\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            if (userAssetBalances[i].userBalance == 0) {\n                unclaimedRewards += _assets[userAssetBalances[i].asset].rewards[reward].usersData[user].accrued;\n            } else {\n                unclaimedRewards +=\n                    _getPendingRewards(user, reward, userAssetBalances[i]) +\n                    _assets[userAssetBalances[i].asset].rewards[reward].usersData[user].accrued;\n            }\n        }\n\n        return unclaimedRewards;\n    }\n\n    /**\n     * @dev Calculates the pending (not yet accrued) rewards since the last user action\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @param userAssetBalance struct with the user balance and total supply of the incentivized asset\n     * @return The pending rewards for the user since the last user action\n     **/\n    function _getPendingRewards(\n        address user,\n        address reward,\n        RewardsDataTypes.UserAssetBalance memory userAssetBalance\n    ) internal view returns (uint256) {\n        RewardsDataTypes.RewardData storage rewardData = _assets[userAssetBalance.asset].rewards[reward];\n        uint256 assetUnit = 10 ** _assets[userAssetBalance.asset].decimals;\n        (, uint256 nextIndex) = _getAssetIndex(rewardData, userAssetBalance.totalSupply, assetUnit);\n\n        return _getRewards(userAssetBalance.userBalance, nextIndex, rewardData.usersData[user].index, assetUnit);\n    }\n\n    /**\n     * @dev Internal function for the calculation of user's rewards on a distribution\n     * @param userBalance Balance of the user asset on a distribution\n     * @param reserveIndex Current index of the distribution\n     * @param userIndex Index stored for the user, representation his staking moment\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The rewards\n     **/\n    function _getRewards(\n        uint256 userBalance,\n        uint256 reserveIndex,\n        uint256 userIndex,\n        uint256 assetUnit\n    ) internal pure returns (uint256) {\n        uint256 result = userBalance * (reserveIndex - userIndex);\n        assembly {\n            result := div(result, assetUnit)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Calculates the next value of an specific distribution index, with validations\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param totalSupply of the asset being rewarded\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The new index.\n     **/\n    function _getAssetIndex(\n        RewardsDataTypes.RewardData storage rewardData,\n        uint256 totalSupply,\n        uint256 assetUnit\n    ) internal view returns (uint256, uint256) {\n        uint256 oldIndex = rewardData.index;\n        uint256 distributionEnd = rewardData.distributionEnd;\n        uint256 emissionPerSecond = rewardData.emissionPerSecond;\n        uint256 lastUpdateTimestamp = rewardData.lastUpdateTimestamp;\n\n        if (\n            emissionPerSecond == 0 ||\n            totalSupply == 0 ||\n            lastUpdateTimestamp == block.timestamp ||\n            lastUpdateTimestamp >= distributionEnd\n        ) {\n            return (oldIndex, oldIndex);\n        }\n\n        uint256 currentTimestamp = block.timestamp > distributionEnd ? distributionEnd : block.timestamp;\n        uint256 timeDelta = currentTimestamp - lastUpdateTimestamp;\n        uint256 firstTerm = emissionPerSecond * timeDelta * assetUnit;\n        assembly {\n            firstTerm := div(firstTerm, totalSupply)\n        }\n        return (oldIndex, (firstTerm + oldIndex));\n    }\n\n    /**\n     * @dev Get user balances and total supply of all the assets specified by the assets parameter\n     * @param assets List of assets to retrieve user balance and total supply\n     * @param user Address of the user\n     * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n     */\n    function _getUserAssetBalances(\n        address[] calldata assets,\n        address user\n    ) internal view virtual returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances);\n\n    /// @inheritdoc IRewardsDistributor\n    function getAssetDecimals(address asset) external view returns (uint8) {\n        return _assets[asset].decimals;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getEmissionManager() external view returns (address) {\n        return EMISSION_MANAGER;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/transfer-strategies/PullRewardsTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPullRewardsTransferStrategy } from \"../interfaces/IPullRewardsTransferStrategy.sol\";\nimport { ITransferStrategyBase } from \"../interfaces/ITransferStrategyBase.sol\";\nimport { TransferStrategyBase } from \"./TransferStrategyBase.sol\";\nimport { GPv2SafeERC20 } from \"contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title PullRewardsTransferStrategy\n * @notice Transfer strategy that pulls ERC20 rewards from an external account to the user address.\n * The external account could be a smart contract or EOA that must approve to the PullRewardsTransferStrategy contract address.\n * @author Aave\n **/\ncontract PullRewardsTransferStrategy is TransferStrategyBase, IPullRewardsTransferStrategy {\n    using GPv2SafeERC20 for IERC20;\n\n    address internal immutable REWARDS_VAULT;\n\n    constructor(\n        address incentivesController,\n        address rewardsAdmin,\n        address rewardsVault\n    ) TransferStrategyBase(incentivesController, rewardsAdmin) {\n        REWARDS_VAULT = rewardsVault;\n    }\n\n    /// @inheritdoc TransferStrategyBase\n    function performTransfer(\n        address to,\n        address reward,\n        uint256 amount\n    ) external override(TransferStrategyBase, ITransferStrategyBase) onlyIncentivesController returns (bool) {\n        IERC20(reward).safeTransferFrom(REWARDS_VAULT, to, amount);\n\n        return true;\n    }\n\n    /// @inheritdoc IPullRewardsTransferStrategy\n    function getRewardsVault() external view returns (address) {\n        return REWARDS_VAULT;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/transfer-strategies/StakedTokenTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IStakedToken } from \"../interfaces/IStakedToken.sol\";\nimport { IStakedTokenTransferStrategy } from \"../interfaces/IStakedTokenTransferStrategy.sol\";\nimport { ITransferStrategyBase } from \"../interfaces/ITransferStrategyBase.sol\";\nimport { TransferStrategyBase } from \"./TransferStrategyBase.sol\";\nimport { GPv2SafeERC20 } from \"contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title StakedTokenTransferStrategy\n * @notice Transfer strategy that stakes the rewards into a staking contract and transfers the staking contract token.\n * The underlying token must be transferred to this contract to be able to stake it on demand.\n * @author Aave\n **/\ncontract StakedTokenTransferStrategy is TransferStrategyBase, IStakedTokenTransferStrategy {\n    using GPv2SafeERC20 for IERC20;\n\n    IStakedToken internal immutable STAKE_CONTRACT;\n    address internal immutable UNDERLYING_TOKEN;\n\n    constructor(\n        address incentivesController,\n        address rewardsAdmin,\n        IStakedToken stakeToken\n    ) TransferStrategyBase(incentivesController, rewardsAdmin) {\n        STAKE_CONTRACT = stakeToken;\n        UNDERLYING_TOKEN = STAKE_CONTRACT.STAKED_TOKEN();\n\n        IERC20(UNDERLYING_TOKEN).approve(address(STAKE_CONTRACT), type(uint256).max);\n    }\n\n    /// @inheritdoc TransferStrategyBase\n    function performTransfer(\n        address to,\n        address reward,\n        uint256 amount\n    ) external override(TransferStrategyBase, ITransferStrategyBase) onlyIncentivesController returns (bool) {\n        require(reward == address(STAKE_CONTRACT), \"REWARD_TOKEN_NOT_STAKE_CONTRACT\");\n\n        STAKE_CONTRACT.stake(to, amount);\n\n        return true;\n    }\n\n    /// @inheritdoc IStakedTokenTransferStrategy\n    function renewApproval() external onlyRewardsAdmin {\n        IERC20(UNDERLYING_TOKEN).approve(address(STAKE_CONTRACT), type(uint256).max);\n    }\n\n    /// @inheritdoc IStakedTokenTransferStrategy\n    function dropApproval() external onlyRewardsAdmin {\n        IERC20(UNDERLYING_TOKEN).approve(address(STAKE_CONTRACT), 0);\n    }\n\n    /// @inheritdoc IStakedTokenTransferStrategy\n    function getStakeContract() external view returns (address) {\n        return address(STAKE_CONTRACT);\n    }\n\n    /// @inheritdoc IStakedTokenTransferStrategy\n    function getUnderlyingToken() external view returns (address) {\n        return UNDERLYING_TOKEN;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/transfer-strategies/TransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { ITransferStrategyBase } from \"../interfaces/ITransferStrategyBase.sol\";\nimport { GPv2SafeERC20 } from \"contracts/dlend/core/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title TransferStrategyStorage\n * @author Aave\n **/\nabstract contract TransferStrategyBase is ITransferStrategyBase {\n    using GPv2SafeERC20 for IERC20;\n\n    address internal immutable INCENTIVES_CONTROLLER;\n    address internal immutable REWARDS_ADMIN;\n\n    constructor(address incentivesController, address rewardsAdmin) {\n        INCENTIVES_CONTROLLER = incentivesController;\n        REWARDS_ADMIN = rewardsAdmin;\n    }\n\n    /**\n     * @dev Modifier for incentives controller only functions\n     */\n    modifier onlyIncentivesController() {\n        require(INCENTIVES_CONTROLLER == msg.sender, \"CALLER_NOT_INCENTIVES_CONTROLLER\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for reward admin only functions\n     */\n    modifier onlyRewardsAdmin() {\n        require(msg.sender == REWARDS_ADMIN, \"ONLY_REWARDS_ADMIN\");\n        _;\n    }\n\n    /// @inheritdoc ITransferStrategyBase\n    function getIncentivesController() external view override returns (address) {\n        return INCENTIVES_CONTROLLER;\n    }\n\n    /// @inheritdoc ITransferStrategyBase\n    function getRewardsAdmin() external view override returns (address) {\n        return REWARDS_ADMIN;\n    }\n\n    /// @inheritdoc ITransferStrategyBase\n    function performTransfer(address to, address reward, uint256 amount) external virtual returns (bool);\n\n    /// @inheritdoc ITransferStrategyBase\n    function emergencyWithdrawal(address token, address to, uint256 amount) external onlyRewardsAdmin {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit EmergencyWithdrawal(msg.sender, token, to, amount);\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/AaveEcosystemReserveController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { IStreamable } from \"./interfaces/IStreamable.sol\";\nimport { IAdminControlledEcosystemReserve } from \"./interfaces/IAdminControlledEcosystemReserve.sol\";\nimport { IAaveEcosystemReserveController } from \"./interfaces/IAaveEcosystemReserveController.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\ncontract AaveEcosystemReserveController is Ownable, IAaveEcosystemReserveController {\n    /**\n     * @notice Constructor.\n     * @param aaveGovShortTimelock The address of the Aave's governance executor, owning this contract\n     */\n    constructor(address aaveGovShortTimelock) {\n        transferOwnership(aaveGovShortTimelock);\n    }\n\n    /// @inheritdoc IAaveEcosystemReserveController\n    function approve(address collector, IERC20 token, address recipient, uint256 amount) external onlyOwner {\n        IAdminControlledEcosystemReserve(collector).approve(token, recipient, amount);\n    }\n\n    /// @inheritdoc IAaveEcosystemReserveController\n    function transfer(address collector, IERC20 token, address recipient, uint256 amount) external onlyOwner {\n        IAdminControlledEcosystemReserve(collector).transfer(token, recipient, amount);\n    }\n\n    /// @inheritdoc IAaveEcosystemReserveController\n    function createStream(\n        address collector,\n        address recipient,\n        uint256 deposit,\n        IERC20 tokenAddress,\n        uint256 startTime,\n        uint256 stopTime\n    ) external onlyOwner returns (uint256) {\n        return IStreamable(collector).createStream(recipient, deposit, address(tokenAddress), startTime, stopTime);\n    }\n\n    /// @inheritdoc IAaveEcosystemReserveController\n    function withdrawFromStream(address collector, uint256 streamId, uint256 funds) external onlyOwner returns (bool) {\n        return IStreamable(collector).withdrawFromStream(streamId, funds);\n    }\n\n    /// @inheritdoc IAaveEcosystemReserveController\n    function cancelStream(address collector, uint256 streamId) external onlyOwner returns (bool) {\n        return IStreamable(collector).cancelStream(streamId);\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/AaveEcosystemReserveV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IStreamable } from \"./interfaces/IStreamable.sol\";\nimport { AdminControlledEcosystemReserve } from \"./AdminControlledEcosystemReserve.sol\";\nimport { ReentrancyGuard } from \"./libs/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"./libs/SafeERC20.sol\";\n\n/**\n * @title AaveEcosystemReserve v2\n * @notice Stores ERC20 tokens of an ecosystem reserve, adding streaming capabilities.\n * Modification of Sablier https://github.com/sablierhq/sablier/blob/develop/packages/protocol/contracts/Sablier.sol\n * Original can be found also deployed on https://etherscan.io/address/0xCD18eAa163733Da39c232722cBC4E8940b1D8888\n * Modifications:\n * - Sablier \"pulls\" the funds from the creator of the stream at creation. In the Aave case, we already have the funds.\n * - Anybody can create streams on Sablier. Here, only the funds admin (Aave governance via controller) can\n * - Adapted codebase to Solidity 0.8.11, mainly removing SafeMath and CarefulMath to use native safe math\n * - Same as with creation, on Sablier the `sender` and `recipient` can cancel a stream. Here, only fund admin and recipient\n * @author BGD Labs\n **/\ncontract AaveEcosystemReserveV2 is AdminControlledEcosystemReserve, ReentrancyGuard, IStreamable {\n    using SafeERC20 for IERC20;\n\n    /*** Storage Properties ***/\n\n    /**\n     * @notice Counter for new stream ids.\n     */\n    uint256 private _nextStreamId;\n\n    /**\n     * @notice The stream objects identifiable by their unsigned integer ids.\n     */\n    mapping(uint256 => Stream) private _streams;\n\n    /*** Modifiers ***/\n\n    /**\n     * @dev Throws if the caller is not the funds admin of the recipient of the stream.\n     */\n    modifier onlyAdminOrRecipient(uint256 streamId) {\n        require(\n            msg.sender == _fundsAdmin || msg.sender == _streams[streamId].recipient,\n            \"caller is not the funds admin or the recipient of the stream\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if the provided id does not point to a valid stream.\n     */\n    modifier streamExists(uint256 streamId) {\n        require(_streams[streamId].isEntity, \"stream does not exist\");\n        _;\n    }\n\n    /*** Contract Logic Starts Here */\n\n    function initialize(address fundsAdmin) external initializer {\n        _nextStreamId = 100000;\n        _setFundsAdmin(fundsAdmin);\n    }\n\n    /*** View Functions ***/\n\n    /**\n     * @notice Returns the next available stream id\n     * @notice Returns the stream id.\n     */\n    function getNextStreamId() external view returns (uint256) {\n        return _nextStreamId;\n    }\n\n    /**\n     * @notice Returns the stream with all its properties.\n     * @dev Throws if the id does not point to a valid stream.\n     * @param streamId The id of the stream to query.\n     * @notice Returns the stream object.\n     */\n    function getStream(\n        uint256 streamId\n    )\n        external\n        view\n        streamExists(streamId)\n        returns (\n            address sender,\n            address recipient,\n            uint256 deposit,\n            address tokenAddress,\n            uint256 startTime,\n            uint256 stopTime,\n            uint256 remainingBalance,\n            uint256 ratePerSecond\n        )\n    {\n        sender = _streams[streamId].sender;\n        recipient = _streams[streamId].recipient;\n        deposit = _streams[streamId].deposit;\n        tokenAddress = _streams[streamId].tokenAddress;\n        startTime = _streams[streamId].startTime;\n        stopTime = _streams[streamId].stopTime;\n        remainingBalance = _streams[streamId].remainingBalance;\n        ratePerSecond = _streams[streamId].ratePerSecond;\n    }\n\n    /**\n     * @notice Returns either the delta in seconds between `block.timestamp` and `startTime` or\n     *  between `stopTime` and `startTime, whichever is smaller. If `block.timestamp` is before\n     *  `startTime`, it returns 0.\n     * @dev Throws if the id does not point to a valid stream.\n     * @param streamId The id of the stream for which to query the delta.\n     * @notice Returns the time delta in seconds.\n     */\n    function deltaOf(uint256 streamId) public view streamExists(streamId) returns (uint256 delta) {\n        Stream memory stream = _streams[streamId];\n        if (block.timestamp <= stream.startTime) return 0;\n        if (block.timestamp < stream.stopTime) return block.timestamp - stream.startTime;\n        return stream.stopTime - stream.startTime;\n    }\n\n    struct BalanceOfLocalVars {\n        uint256 recipientBalance;\n        uint256 withdrawalAmount;\n        uint256 senderBalance;\n    }\n\n    /**\n     * @notice Returns the available funds for the given stream id and address.\n     * @dev Throws if the id does not point to a valid stream.\n     * @param streamId The id of the stream for which to query the balance.\n     * @param who The address for which to query the balance.\n     * @notice Returns the total funds allocated to `who` as uint256.\n     */\n    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\n        Stream memory stream = _streams[streamId];\n        BalanceOfLocalVars memory vars;\n\n        uint256 delta = deltaOf(streamId);\n        vars.recipientBalance = delta * stream.ratePerSecond;\n\n        /*\n         * If the stream `balance` does not equal `deposit`, it means there have been withdrawals.\n         * We have to subtract the total amount withdrawn from the amount of money that has been\n         * streamed until now.\n         */\n        if (stream.deposit > stream.remainingBalance) {\n            vars.withdrawalAmount = stream.deposit - stream.remainingBalance;\n            vars.recipientBalance = vars.recipientBalance - vars.withdrawalAmount;\n        }\n\n        if (who == stream.recipient) return vars.recipientBalance;\n        if (who == stream.sender) {\n            vars.senderBalance = stream.remainingBalance - vars.recipientBalance;\n            return vars.senderBalance;\n        }\n        return 0;\n    }\n\n    /*** Public Effects & Interactions Functions ***/\n\n    struct CreateStreamLocalVars {\n        uint256 duration;\n        uint256 ratePerSecond;\n    }\n\n    /**\n     * @notice Creates a new stream funded by this contracts itself and paid towards `recipient`.\n     * @dev Throws if the recipient is the zero address, the contract itself or the caller.\n     *  Throws if the deposit is 0.\n     *  Throws if the start time is before `block.timestamp`.\n     *  Throws if the stop time is before the start time.\n     *  Throws if the duration calculation has a math error.\n     *  Throws if the deposit is smaller than the duration.\n     *  Throws if the deposit is not a multiple of the duration.\n     *  Throws if the rate calculation has a math error.\n     *  Throws if the next stream id calculation has a math error.\n     *  Throws if the contract is not allowed to transfer enough tokens.\n     *  Throws if there is a token transfer failure.\n     * @param recipient The address towards which the money is streamed.\n     * @param deposit The amount of money to be streamed.\n     * @param tokenAddress The ERC20 token to use as streaming currency.\n     * @param startTime The unix timestamp for when the stream starts.\n     * @param stopTime The unix timestamp for when the stream stops.\n     * @notice Returns the uint256 id of the newly created stream.\n     */\n    function createStream(\n        address recipient,\n        uint256 deposit,\n        address tokenAddress,\n        uint256 startTime,\n        uint256 stopTime\n    ) external onlyFundsAdmin returns (uint256) {\n        require(recipient != address(0), \"stream to the zero address\");\n        require(recipient != address(this), \"stream to the contract itself\");\n        require(recipient != msg.sender, \"stream to the caller\");\n        require(deposit > 0, \"deposit is zero\");\n        require(startTime >= block.timestamp, \"start time before block.timestamp\");\n        require(stopTime > startTime, \"stop time before the start time\");\n\n        CreateStreamLocalVars memory vars;\n        vars.duration = stopTime - startTime;\n\n        /* Without this, the rate per second would be zero. */\n        require(deposit >= vars.duration, \"deposit smaller than time delta\");\n\n        /* This condition avoids dealing with remainders */\n        require(deposit % vars.duration == 0, \"deposit not multiple of time delta\");\n\n        vars.ratePerSecond = deposit / vars.duration;\n\n        /* Create and store the stream object. */\n        uint256 streamId = _nextStreamId;\n        _streams[streamId] = Stream({\n            remainingBalance: deposit,\n            deposit: deposit,\n            isEntity: true,\n            ratePerSecond: vars.ratePerSecond,\n            recipient: recipient,\n            sender: address(this),\n            startTime: startTime,\n            stopTime: stopTime,\n            tokenAddress: tokenAddress\n        });\n\n        /* Increment the next stream id. */\n        _nextStreamId++;\n\n        emit CreateStream(streamId, address(this), recipient, deposit, tokenAddress, startTime, stopTime);\n        return streamId;\n    }\n\n    /**\n     * @notice Withdraws from the contract to the recipient's account.\n     * @dev Throws if the id does not point to a valid stream.\n     *  Throws if the caller is not the funds admin or the recipient of the stream.\n     *  Throws if the amount exceeds the available balance.\n     *  Throws if there is a token transfer failure.\n     * @param streamId The id of the stream to withdraw tokens from.\n     * @param amount The amount of tokens to withdraw.\n     */\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 amount\n    ) external nonReentrant streamExists(streamId) onlyAdminOrRecipient(streamId) returns (bool) {\n        require(amount > 0, \"amount is zero\");\n        Stream memory stream = _streams[streamId];\n\n        uint256 balance = balanceOf(streamId, stream.recipient);\n        require(balance >= amount, \"amount exceeds the available balance\");\n\n        _streams[streamId].remainingBalance = stream.remainingBalance - amount;\n\n        if (_streams[streamId].remainingBalance == 0) delete _streams[streamId];\n\n        IERC20(stream.tokenAddress).safeTransfer(stream.recipient, amount);\n        emit WithdrawFromStream(streamId, stream.recipient, amount);\n        return true;\n    }\n\n    /**\n     * @notice Cancels the stream and transfers the tokens back on a pro rata basis.\n     * @dev Throws if the id does not point to a valid stream.\n     *  Throws if the caller is not the funds admin or the recipient of the stream.\n     *  Throws if there is a token transfer failure.\n     * @param streamId The id of the stream to cancel.\n     * @notice Returns bool true=success, otherwise false.\n     */\n    function cancelStream(\n        uint256 streamId\n    ) external nonReentrant streamExists(streamId) onlyAdminOrRecipient(streamId) returns (bool) {\n        Stream memory stream = _streams[streamId];\n        uint256 senderBalance = balanceOf(streamId, stream.sender);\n        uint256 recipientBalance = balanceOf(streamId, stream.recipient);\n\n        delete _streams[streamId];\n\n        IERC20 token = IERC20(stream.tokenAddress);\n        if (recipientBalance > 0) token.safeTransfer(stream.recipient, recipientBalance);\n\n        emit CancelStream(streamId, stream.sender, stream.recipient, senderBalance, recipientBalance);\n        return true;\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/AdminControlledEcosystemReserve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { IAdminControlledEcosystemReserve } from \"./interfaces/IAdminControlledEcosystemReserve.sol\";\nimport { VersionedInitializable } from \"./libs/VersionedInitializable.sol\";\nimport { SafeERC20 } from \"./libs/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"./libs/ReentrancyGuard.sol\";\nimport { Address } from \"./libs/Address.sol\";\n\n/**\n * @title AdminControlledEcosystemReserve\n * @notice Stores ERC20 tokens, and allows to dispose of them via approval or transfer dynamics\n * Adapted to be an implementation of a transparent proxy\n * @dev Done abstract to add an `initialize()` function on the child, with `initializer` modifier\n * @author BGD Labs\n **/\nabstract contract AdminControlledEcosystemReserve is VersionedInitializable, IAdminControlledEcosystemReserve {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    address internal _fundsAdmin;\n\n    uint256 public constant REVISION = 1;\n\n    /// @inheritdoc IAdminControlledEcosystemReserve\n    address public constant ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    modifier onlyFundsAdmin() {\n        require(msg.sender == _fundsAdmin, \"ONLY_BY_FUNDS_ADMIN\");\n        _;\n    }\n\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /// @inheritdoc IAdminControlledEcosystemReserve\n    function getFundsAdmin() external view returns (address) {\n        return _fundsAdmin;\n    }\n\n    /// @inheritdoc IAdminControlledEcosystemReserve\n    function approve(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {\n        token.safeApprove(recipient, amount);\n    }\n\n    /// @inheritdoc IAdminControlledEcosystemReserve\n    function transfer(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {\n        require(recipient != address(0), \"INVALID_0X_RECIPIENT\");\n\n        if (address(token) == ETH_MOCK_ADDRESS) {\n            payable(recipient).sendValue(amount);\n        } else {\n            token.safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @dev needed in order to receive ETH from the Aave v1 ecosystem reserve\n    receive() external payable {}\n\n    function _setFundsAdmin(address admin) internal {\n        _fundsAdmin = admin;\n        emit NewFundsAdmin(admin);\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/Collector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { VersionedInitializable } from \"contracts/dlend/core/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { ICollector } from \"./interfaces/ICollector.sol\";\n\n/**\n * @title Collector\n * @notice Stores the fees collected by the protocol and allows the fund administrator\n *         to approve or transfer the collected ERC20 tokens.\n * @dev Implementation contract that must be initialized using transparent proxy pattern.\n * @author Aave\n **/\ncontract Collector is VersionedInitializable, ICollector {\n    // Store the current funds administrator address\n    address internal _fundsAdmin;\n\n    // Revision version of this implementation contract\n    uint256 public constant REVISION = 1;\n\n    /**\n     * @dev Allow only the funds administrator address to call functions marked by this modifier\n     */\n    modifier onlyFundsAdmin() {\n        require(msg.sender == _fundsAdmin, \"ONLY_BY_FUNDS_ADMIN\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the transparent proxy with the admin of the Collector\n     * @param reserveController The address of the admin that controls Collector\n     */\n    function initialize(address reserveController) external initializer {\n        _setFundsAdmin(reserveController);\n    }\n\n    /// @inheritdoc VersionedInitializable\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /// @inheritdoc ICollector\n    function getFundsAdmin() external view returns (address) {\n        return _fundsAdmin;\n    }\n\n    /// @inheritdoc ICollector\n    function approve(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {\n        token.approve(recipient, amount);\n    }\n\n    /// @inheritdoc ICollector\n    function transfer(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {\n        token.transfer(recipient, amount);\n    }\n\n    /// @inheritdoc ICollector\n    function setFundsAdmin(address admin) external onlyFundsAdmin {\n        _setFundsAdmin(admin);\n    }\n\n    /**\n     * @dev Transfer the ownership of the funds administrator role.\n     * @param admin The address of the new funds administrator\n     */\n    function _setFundsAdmin(address admin) internal {\n        _fundsAdmin = admin;\n        emit NewFundsAdmin(admin);\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/CollectorController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/Ownable.sol\";\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { ICollector } from \"./interfaces/ICollector.sol\";\n\n/**\n * @title CollectorController\n * @notice The CollectorController contracts allows the owner of the contract\n           to approve or transfer tokens from the specified collector proxy contract.\n           The admin of the Collector proxy can't be the same as the fundsAdmin address.\n           This is needed due the usage of transparent proxy pattern.\n * @author Aave\n **/\ncontract CollectorController is Ownable {\n    /**\n     * @dev Constructor setups the ownership of the contract\n     * @param owner The address of the owner of the CollectorController\n     */\n    constructor(address owner) {\n        transferOwnership(owner);\n    }\n\n    /**\n     * @dev Transfer an amount of tokens to the recipient.\n     * @param collector The address of the collector contract\n     * @param token The address of the asset\n     * @param recipient The address of the entity to transfer the tokens.\n     * @param amount The amount to be transferred.\n     */\n    function approve(address collector, IERC20 token, address recipient, uint256 amount) external onlyOwner {\n        ICollector(collector).approve(token, recipient, amount);\n    }\n\n    /**\n     * @dev Transfer an amount of tokens to the recipient.\n     * @param collector The address of the collector contract to retrieve funds from (e.g. Aave ecosystem reserve)\n     * @param token The address of the asset\n     * @param recipient The address of the entity to transfer the tokens.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address collector, IERC20 token, address recipient, uint256 amount) external onlyOwner {\n        ICollector(collector).transfer(token, recipient, amount);\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/interfaces/IAaveEcosystemReserveController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IAaveEcosystemReserveController {\n    /**\n     * @notice Proxy function for ERC20's approve(), pointing to a specific collector contract\n     * @param collector The collector contract with funds (Aave ecosystem reserve)\n     * @param token The asset address\n     * @param recipient Allowance's recipient\n     * @param amount Allowance to approve\n     **/\n    function approve(address collector, IERC20 token, address recipient, uint256 amount) external;\n\n    /**\n     * @notice Proxy function for ERC20's transfer(), pointing to a specific collector contract\n     * @param collector The collector contract with funds (Aave ecosystem reserve)\n     * @param token The asset address\n     * @param recipient Transfer's recipient\n     * @param amount Amount to transfer\n     **/\n    function transfer(address collector, IERC20 token, address recipient, uint256 amount) external;\n\n    /**\n     * @notice Proxy function to create a stream of token on a specific collector contract\n     * @param collector The collector contract with funds (Aave ecosystem reserve)\n     * @param recipient The recipient of the stream of token\n     * @param deposit Total amount to be streamed\n     * @param tokenAddress The ERC20 token to use as streaming asset\n     * @param startTime The unix timestamp for when the stream starts\n     * @param stopTime The unix timestamp for when the stream stops\n     * @return uint256 The stream id created\n     **/\n    function createStream(\n        address collector,\n        address recipient,\n        uint256 deposit,\n        IERC20 tokenAddress,\n        uint256 startTime,\n        uint256 stopTime\n    ) external returns (uint256);\n\n    /**\n     * @notice Proxy function to withdraw from a stream of token on a specific collector contract\n     * @param collector The collector contract with funds (Aave ecosystem reserve)\n     * @param streamId The id of the stream to withdraw tokens from\n     * @param funds Amount to withdraw\n     * @return bool If the withdrawal finished properly\n     **/\n    function withdrawFromStream(address collector, uint256 streamId, uint256 funds) external returns (bool);\n\n    /**\n     * @notice Proxy function to cancel a stream of token on a specific collector contract\n     * @param collector The collector contract with funds (Aave ecosystem reserve)\n     * @param streamId The id of the stream to cancel\n     * @return bool If the cancellation happened correctly\n     **/\n    function cancelStream(address collector, uint256 streamId) external returns (bool);\n}\n"
    },
    "contracts/dlend/periphery/treasury/interfaces/IAdminControlledEcosystemReserve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IAdminControlledEcosystemReserve {\n    /** @notice Emitted when the funds admin changes\n     * @param fundsAdmin The new funds admin\n     **/\n    event NewFundsAdmin(address indexed fundsAdmin);\n\n    /** @notice Returns the mock ETH reference address\n     * @return address The address\n     **/\n    function ETH_MOCK_ADDRESS() external pure returns (address);\n\n    /**\n     * @notice Return the funds admin, only entity to be able to interact with this contract (controller of reserve)\n     * @return address The address of the funds admin\n     **/\n    function getFundsAdmin() external view returns (address);\n\n    /**\n     * @dev Function for the funds admin to give ERC20 allowance to other parties\n     * @param token The address of the token to give allowance from\n     * @param recipient Allowance's recipient\n     * @param amount Allowance to approve\n     **/\n    function approve(IERC20 token, address recipient, uint256 amount) external;\n\n    /**\n     * @notice Function for the funds admin to transfer ERC20 tokens to other parties\n     * @param token The address of the token to transfer\n     * @param recipient Transfer's recipient\n     * @param amount Amount to transfer\n     **/\n    function transfer(IERC20 token, address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/dlend/periphery/treasury/interfaces/ICollector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title ICollector\n * @notice Defines the interface of the Collector contract\n * @author Aave\n **/\ninterface ICollector {\n    /**\n     * @dev Emitted during the transfer of ownership of the funds administrator address\n     * @param fundsAdmin The new funds administrator address\n     **/\n    event NewFundsAdmin(address indexed fundsAdmin);\n\n    /**\n     * @dev Retrieve the current implementation Revision of the proxy\n     * @return The revision version\n     */\n    function REVISION() external view returns (uint256);\n\n    /**\n     * @dev Retrieve the current funds administrator\n     * @return The address of the funds administrator\n     */\n    function getFundsAdmin() external view returns (address);\n\n    /**\n     * @dev Approve an amount of tokens to be pulled by the recipient.\n     * @param token The address of the asset\n     * @param recipient The address of the entity allowed to pull tokens\n     * @param amount The amount allowed to be pulled. If zero it will revoke the approval.\n     */\n    function approve(IERC20 token, address recipient, uint256 amount) external;\n\n    /**\n     * @dev Transfer an amount of tokens to the recipient.\n     * @param token The address of the asset\n     * @param recipient The address of the entity to transfer the tokens.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(IERC20 token, address recipient, uint256 amount) external;\n\n    /**\n   * @dev Transfer the ownership of the funds administrator role.\n          This function should only be callable by the current funds administrator.\n   * @param admin The address of the new funds administrator\n   */\n    function setFundsAdmin(address admin) external;\n}\n"
    },
    "contracts/dlend/periphery/treasury/interfaces/IStreamable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IStreamable {\n    struct Stream {\n        uint256 deposit;\n        uint256 ratePerSecond;\n        uint256 remainingBalance;\n        uint256 startTime;\n        uint256 stopTime;\n        address recipient;\n        address sender;\n        address tokenAddress;\n        bool isEntity;\n    }\n\n    event CreateStream(\n        uint256 indexed streamId,\n        address indexed sender,\n        address indexed recipient,\n        uint256 deposit,\n        address tokenAddress,\n        uint256 startTime,\n        uint256 stopTime\n    );\n\n    event WithdrawFromStream(uint256 indexed streamId, address indexed recipient, uint256 amount);\n\n    event CancelStream(\n        uint256 indexed streamId,\n        address indexed sender,\n        address indexed recipient,\n        uint256 senderBalance,\n        uint256 recipientBalance\n    );\n\n    function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\n\n    function getStream(\n        uint256 streamId\n    )\n        external\n        view\n        returns (\n            address sender,\n            address recipient,\n            uint256 deposit,\n            address token,\n            uint256 startTime,\n            uint256 stopTime,\n            uint256 remainingBalance,\n            uint256 ratePerSecond\n        );\n\n    function createStream(\n        address recipient,\n        uint256 deposit,\n        address tokenAddress,\n        uint256 startTime,\n        uint256 stopTime\n    ) external returns (uint256 streamId);\n\n    function withdrawFromStream(uint256 streamId, uint256 funds) external returns (bool);\n\n    function cancelStream(uint256 streamId) external returns (bool);\n\n    function initialize(address fundsAdmin) external;\n}\n"
    },
    "contracts/dlend/periphery/treasury/libs/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/libs/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport { Address } from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/dlend/periphery/treasury/libs/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 internal lastInitializedRevision = 0;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(revision > lastInitializedRevision, \"Contract instance has already been initialized\");\n\n        lastInitializedRevision = revision;\n\n        _;\n    }\n\n    /// @dev returns the revision number of the contract.\n    /// Needs to be defined in the inherited class as a constant.\n    function getRevision() internal pure virtual returns (uint256);\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dstable/AmoManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./CollateralVault.sol\";\nimport \"./OracleAware.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// Forward declaration interface for AmoVault instead of importing the full contract\ninterface IAmoVault {\n    function totalValue() external view returns (uint256);\n\n    function totalDstableValue() external view returns (uint256);\n\n    function totalCollateralValue() external view returns (uint256);\n\n    function withdrawTo(address recipient, uint256 amount, address asset) external;\n\n    function assetValueFromAmount(uint256 amount, address asset) external view returns (uint256);\n}\n\n/**\n * @title AmoManager\n * @dev Manages AMOs for dStable\n * Handles allocation, deallocation, collateral management, and profit management for AMO vaults.\n */\ncontract AmoManager is AccessControl, OracleAware, ReentrancyGuard {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /* Core state */\n\n    EnumerableMap.AddressToUintMap private _amoVaults;\n    // Separate map to track whether a vault is considered active. This decouples\n    // allocation bookkeeping (which may change when moving collateral) from the\n    // governancecontrolled active status of a vault.\n    mapping(address => bool) private _isAmoActive;\n    uint256 public totalAllocated;\n    IMintableERC20 public dstable;\n    CollateralVault public collateralHolderVault;\n\n    /* Events */\n\n    event AmoVaultSet(address indexed amoVault, bool isActive);\n    event AmoAllocated(address indexed amoVault, uint256 dstableAmount);\n    event AmoDeallocated(address indexed amoVault, uint256 dstableAmount);\n    event ProfitsWithdrawn(address indexed amoVault, uint256 amount);\n    event AllocationSurplus(address indexed amoVault, uint256 surplusInDstable);\n\n    /* Roles */\n\n    bytes32 public constant AMO_ALLOCATOR_ROLE = keccak256(\"AMO_ALLOCATOR_ROLE\");\n    bytes32 public constant FEE_COLLECTOR_ROLE = keccak256(\"FEE_COLLECTOR_ROLE\");\n\n    /* Errors */\n\n    error InactiveAmoVault(address amoVault);\n    error AmoSupplyInvariantViolation(uint256 startingSupply, uint256 endingSupply);\n    error AmoVaultAlreadyEnabled(address amoVault);\n    error CannotTransferDStable();\n    error InsufficientProfits(uint256 takeProfitValueInBase, int256 availableProfitInBase);\n    error InsufficientAllocation(uint256 requested, uint256 available);\n\n    /**\n     * @notice Initializes the AmoManager contract.\n     * @param _dstable The address of the dStable stablecoin.\n     * @param _collateralHolderVault The address of the collateral holder vault.\n     * @param _oracle The oracle for price feeds.\n     */\n    constructor(\n        address _dstable,\n        address _collateralHolderVault,\n        IPriceOracleGetter _oracle\n    ) OracleAware(_oracle, _oracle.BASE_CURRENCY_UNIT()) {\n        dstable = IMintableERC20(_dstable);\n        collateralHolderVault = CollateralVault(_collateralHolderVault);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        grantRole(AMO_ALLOCATOR_ROLE, msg.sender);\n        grantRole(FEE_COLLECTOR_ROLE, msg.sender);\n    }\n\n    /* AMO */\n\n    /**\n     * @notice Allocates AMO tokens to an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param dstableAmount The amount of dStable to allocate.\n     */\n    function allocateAmo(address amoVault, uint256 dstableAmount) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        uint256 startingAmoSupply = totalAmoSupply();\n\n        // Make sure the vault is active\n        if (!isAmoActive(amoVault)) {\n            revert InactiveAmoVault(amoVault);\n        }\n\n        // Update the allocation for this vault\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation + dstableAmount);\n\n        // Make the deposit\n        totalAllocated += dstableAmount;\n        dstable.transfer(amoVault, dstableAmount);\n\n        // Check invariants\n        uint256 endingAmoSupply = totalAmoSupply();\n        if (endingAmoSupply != startingAmoSupply) {\n            revert AmoSupplyInvariantViolation(startingAmoSupply, endingAmoSupply);\n        }\n\n        emit AmoAllocated(amoVault, dstableAmount);\n    }\n\n    /**\n     * @notice Deallocates AMO tokens from an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param dstableAmount The amount of dStable to deallocate.\n     */\n    function deallocateAmo(address amoVault, uint256 dstableAmount) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        uint256 startingAmoSupply = totalAmoSupply();\n\n        // We don't require that the vault is active or has allocation, since we want to allow withdrawing from inactive vaults\n\n        // If the vault is still active, make sure it has enough allocation and decrease it\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n\n        // Ensure we do not deallocate more than the vault's recorded allocation\n        if (dstableAmount > currentAllocation) {\n            revert InsufficientAllocation(dstableAmount, currentAllocation);\n        }\n\n        // Update the allocation for this vault (safe: dstableAmount <= currentAllocation)\n        _amoVaults.set(amoVault, currentAllocation - dstableAmount);\n\n        // Make the withdrawal and update global counter\n        totalAllocated -= dstableAmount;\n        dstable.transferFrom(amoVault, address(this), dstableAmount);\n\n        // Check invariants\n        uint256 endingAmoSupply = totalAmoSupply();\n        if (endingAmoSupply != startingAmoSupply) {\n            revert AmoSupplyInvariantViolation(startingAmoSupply, endingAmoSupply);\n        }\n\n        emit AmoDeallocated(amoVault, dstableAmount);\n    }\n\n    /**\n     * @notice Returns the total AMO supply.\n     * @return The total AMO supply.\n     */\n    function totalAmoSupply() public view returns (uint256) {\n        uint256 freeBalance = dstable.balanceOf(address(this));\n        return freeBalance + totalAllocated;\n    }\n\n    /**\n     * @notice Decreases the AMO supply by burning dStable.\n     * @param dstableAmount The amount of dStable to burn.\n     */\n    function decreaseAmoSupply(uint256 dstableAmount) public onlyRole(AMO_ALLOCATOR_ROLE) {\n        dstable.burn(dstableAmount);\n    }\n\n    /**\n     * @notice Checks if an AMO vault is active.\n     * @param amoVault The address of the AMO vault to check.\n     * @return True if the AMO vault is active, false otherwise.\n     */\n    function isAmoActive(address amoVault) public view returns (bool) {\n        return _isAmoActive[amoVault];\n    }\n\n    /**\n     * @notice Returns the allocation for a specific AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @return The current allocation for the vault.\n     */\n    function amoVaultAllocation(address amoVault) public view returns (uint256) {\n        (bool exists, uint256 allocation) = _amoVaults.tryGet(amoVault);\n        return exists ? allocation : 0;\n    }\n\n    /**\n     * @notice Returns the list of all AMO vaults.\n     * @return The list of AMO vault addresses.\n     */\n    function amoVaults() public view returns (address[] memory) {\n        return _amoVaults.keys();\n    }\n\n    /**\n     * @notice Enables an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     */\n    function enableAmoVault(address amoVault) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_isAmoActive[amoVault]) {\n            revert AmoVaultAlreadyEnabled(amoVault);\n        }\n        // Ensure the vault is tracked in the allocation map (initial allocation may be zero)\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation);\n        _isAmoActive[amoVault] = true;\n        emit AmoVaultSet(amoVault, true);\n    }\n\n    /**\n     * @notice Disables an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     */\n    function disableAmoVault(address amoVault) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (!_isAmoActive[amoVault]) {\n            revert InactiveAmoVault(amoVault);\n        }\n        _isAmoActive[amoVault] = false;\n        emit AmoVaultSet(amoVault, false);\n    }\n\n    /* Collateral Management */\n\n    /**\n     * @notice Returns the total collateral value of all active AMO vaults.\n     * @return The total collateral value in base value.\n     */\n    function totalCollateralValue() public view returns (uint256) {\n        uint256 totalBaseValue = 0;\n        for (uint256 i = 0; i < _amoVaults.length(); i++) {\n            (address vaultAddress, ) = _amoVaults.at(i);\n            if (isAmoActive(vaultAddress)) {\n                totalBaseValue += IAmoVault(vaultAddress).totalCollateralValue();\n            }\n        }\n        return totalBaseValue;\n    }\n\n    /**\n     * @notice Transfers collateral from an AMO vault to the holding vault.\n     * @param amoVault The address of the AMO vault.\n     * @param token The address of the collateral token to transfer.\n     * @param amount The amount of collateral to transfer.\n     */\n    function transferFromAmoVaultToHoldingVault(\n        address amoVault,\n        address token,\n        uint256 amount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        if (token == address(dstable)) {\n            revert CannotTransferDStable();\n        }\n\n        // Update allocation\n        // A note on why we modify AMO allocation when we withdraw collateral:\n        // 1. When dStable AMO enters the AMO vault, the dStable is initially unbacked\n        // 2. Over time the AMO vault accrues collateral in exchange for distributing dStable\n        // 3. We may be able to make better use of that collateral in a different collateral vault\n        // 4. So we transfer the collateral out of the AMO vault, but at that point the dStable that\n        //    converted to that collateral is now free-floating and fully backed\n        // 5. Thus we decrement the AMO allocation to reflect the fact that the dStable is no longer\n        //    unbacked, but is actually fully backed and circulating\n        uint256 collateralBaseValue = collateralHolderVault.assetValueFromAmount(amount, token);\n        uint256 collateralInDstable = baseValueToDstableAmount(collateralBaseValue);\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n\n        uint256 adjustmentAmount = collateralInDstable;\n        if (collateralInDstable > currentAllocation) {\n            // Emit event to explicitly record the surplus that improves backing\n            uint256 surplus = collateralInDstable - currentAllocation;\n            emit AllocationSurplus(amoVault, surplus);\n\n            // Cap the adjustment to the current allocation to prevent underflow\n            adjustmentAmount = currentAllocation;\n        }\n\n        // Bookkeeping: adjust the vault's allocation. This does NOT change the vault's active status.\n        _amoVaults.set(amoVault, currentAllocation - adjustmentAmount);\n        totalAllocated -= adjustmentAmount;\n\n        // Transfer the collateral\n        IAmoVault(amoVault).withdrawTo(address(collateralHolderVault), amount, token);\n    }\n\n    /**\n     * @notice Transfers collateral from the holding vault to an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param token The address of the collateral token to transfer.\n     * @param amount The amount of collateral to transfer.\n     */\n    function transferFromHoldingVaultToAmoVault(\n        address amoVault,\n        address token,\n        uint256 amount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        if (token == address(dstable)) {\n            revert CannotTransferDStable();\n        }\n        if (!_isAmoActive[amoVault]) {\n            revert InactiveAmoVault(amoVault);\n        }\n\n        // Update allocation\n        // A note on why we modify AMO allocation when we deposit collateral:\n        // 1. When we deposit collateral, it can be used to buy back dStable\n        // 2. When we buy back dStable, the dStable is now unbacked (a redemption)\n        // 3. Thus any collateral deposited to an AMO vault can create unbacked dStable,\n        //    which means the AMO allocation for that vault must be increased to reflect this\n        uint256 collateralBaseValue = collateralHolderVault.assetValueFromAmount(amount, token);\n        uint256 collateralInDstable = baseValueToDstableAmount(collateralBaseValue);\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation + collateralInDstable);\n        totalAllocated += collateralInDstable;\n\n        // Transfer the collateral\n        collateralHolderVault.withdrawTo(amoVault, amount, token);\n    }\n\n    /* Profit Management */\n\n    /**\n     * @notice Returns the available profit for a specific vault in base value (e.g., the underlying).\n     * @param vaultAddress The address of the AMO vault to check.\n     * @return The available profit in base (can be negative).\n     */\n    function availableVaultProfitsInBase(address vaultAddress) public view returns (int256) {\n        uint256 totalVaultValueInBase = IAmoVault(vaultAddress).totalValue();\n        uint256 allocatedDstable = amoVaultAllocation(vaultAddress);\n        uint256 allocatedValueInBase = dstableAmountToBaseValue(allocatedDstable);\n\n        return int256(totalVaultValueInBase) - int256(allocatedValueInBase);\n    }\n\n    /**\n     * @notice Withdraws profits from an AMO vault to a recipient.\n     * @param amoVault The AMO vault from which to withdraw profits.\n     * @param recipient The address to receive the profits.\n     * @param takeProfitToken The collateral token to withdraw.\n     * @param takeProfitAmount The amount of collateral to withdraw.\n     * @return takeProfitValueInBase The value of the withdrawn profits in base.\n     */\n    function withdrawProfits(\n        IAmoVault amoVault,\n        address recipient,\n        address takeProfitToken,\n        uint256 takeProfitAmount\n    ) public onlyRole(FEE_COLLECTOR_ROLE) nonReentrant returns (uint256 takeProfitValueInBase) {\n        // Leave open the possibility of withdrawing profits from inactive vaults\n\n        takeProfitValueInBase = amoVault.assetValueFromAmount(takeProfitAmount, takeProfitToken);\n\n        int256 _availableProfitInBase = availableVaultProfitsInBase(address(amoVault));\n\n        // Make sure we are withdrawing less than the available profit\n        //\n        // TECHNICAL NOTE:\n        // `takeProfitValueInBase` is a `uint256` while `_availableProfitInBase` is an `int256`.\n        // The explicit cast below will wrap if `takeProfitValueInBase` exceeds\n        // `type(int256).max` ( 5.8e76), causing the comparison to evaluate to `false`.\n        // Such a value is unachievable on-chain and the function is restricted to the\n        // trusted `FEE_COLLECTOR_ROLE`, so the edge-case is not considered a practical\n        // risk.\n        if (_availableProfitInBase <= 0 || int256(takeProfitValueInBase) > _availableProfitInBase) {\n            revert InsufficientProfits(takeProfitValueInBase, _availableProfitInBase);\n        }\n\n        // Withdraw profits from the vault\n        amoVault.withdrawTo(recipient, takeProfitAmount, takeProfitToken);\n\n        emit ProfitsWithdrawn(address(amoVault), takeProfitValueInBase);\n\n        return takeProfitValueInBase;\n    }\n\n    /**\n     * @notice Returns the total available profit across all AMO vaults in base.\n     * @return The total available profit in base.\n     */\n    function availableProfitInBase() public view returns (int256) {\n        int256 totalProfit = 0;\n\n        // Iterate through all AMO vaults\n        for (uint256 i = 0; i < _amoVaults.length(); i++) {\n            (address vaultAddress, ) = _amoVaults.at(i);\n\n            if (isAmoActive(vaultAddress)) {\n                totalProfit += availableVaultProfitsInBase(vaultAddress);\n            }\n        }\n\n        return totalProfit;\n    }\n\n    /* Utility */\n\n    /**\n     * @notice Converts a base value to an equivalent amount of dStable tokens.\n     * @param baseValue The amount of base value to convert.\n     * @return The equivalent amount of dStable tokens.\n     */\n    function baseValueToDstableAmount(uint256 baseValue) public view returns (uint256) {\n        uint8 dstableDecimals = dstable.decimals();\n        // Align valuation with Issuer/Redeemer: assume 1 dStable == baseCurrencyUnit\n        return Math.mulDiv(baseValue, 10 ** dstableDecimals, baseCurrencyUnit);\n    }\n\n    /**\n     * @notice Converts an amount of dStable tokens to an equivalent base value.\n     * @param dstableAmount The amount of dStable tokens to convert.\n     * @return The equivalent amount of base value.\n     */\n    function dstableAmountToBaseValue(uint256 dstableAmount) public view returns (uint256) {\n        uint8 dstableDecimals = dstable.decimals();\n        // Align valuation with Issuer/Redeemer: assume 1 dStable == baseCurrencyUnit\n        return Math.mulDiv(dstableAmount, baseCurrencyUnit, 10 ** dstableDecimals);\n    }\n\n    /* Admin */\n\n    /**\n     * @notice Sets the collateral vault address\n     * @param _collateralVault The address of the new collateral vault\n     */\n    function setCollateralVault(address _collateralVault) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        collateralHolderVault = CollateralVault(_collateralVault);\n    }\n}\n\n/**\n * @title ICollateralSum\n * @dev Interface for contracts that can provide total collateral value.\n */\ninterface ICollateralSum {\n    /**\n     * @notice Returns the total collateral value of the implementing contract.\n     * @return The total collateral value in base value.\n     */\n    function totalCollateralValue() external view returns (uint256);\n}\n"
    },
    "contracts/dstable/AmoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./AmoManager.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"contracts/dstable/CollateralVault.sol\";\n\ninterface IRecoverable {\n    function recoverERC20(address token, address to, uint256 amount) external;\n\n    function recoverETH(address to, uint256 amount) external;\n}\n\n/**\n * @title AmoVault\n * @notice Base contract for AMO (Algorithmic Market Operations) vaults that manage dStable and collateral assets\n */\nabstract contract AmoVault is CollateralVault, IRecoverable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /* Core state */\n\n    IMintableERC20 public immutable dstable;\n    uint8 public immutable dstableDecimals;\n    AmoManager public amoManager;\n\n    /* Roles */\n\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    /* Errors */\n\n    error CannotRecoverVaultToken(address token);\n    error InvalidAmoManager();\n\n    constructor(\n        address _dstable,\n        address _amoManager,\n        address _admin,\n        address _collateralWithdrawer,\n        address _recoverer,\n        IPriceOracleGetter _oracle\n    ) CollateralVault(_oracle) {\n        dstable = IMintableERC20(_dstable);\n        dstableDecimals = IERC20Metadata(_dstable).decimals();\n        amoManager = AmoManager(_amoManager);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        grantRole(COLLATERAL_WITHDRAWER_ROLE, _collateralWithdrawer);\n        grantRole(RECOVERER_ROLE, _recoverer);\n        // Use standard approve for trusted protocol token (dStable) and trusted protocol contract (AmoManager)\n        dstable.approve(address(amoManager), type(uint256).max);\n    }\n\n    /**\n     * @notice Approves the AmoManager to spend dStable on behalf of this contract\n     * @dev Only callable by the contract owner or an account with the DEFAULT_ADMIN_ROLE\n     */\n    function approveAmoManager() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Use standard approve for trusted protocol token (dStable) and trusted protocol contract (AmoManager)\n        dstable.approve(address(amoManager), type(uint256).max);\n    }\n\n    /**\n     * @notice Updates the dStable allowance granted to the current AmoManager\n     * @dev Resets the existing allowance to 0 first to accommodate non-standard ERC20 tokens that require\n     *      the allowance to be set to zero before changing it.\n     * @param amount The new allowance amount to grant.\n     */\n    function setAmoManagerApproval(uint256 amount) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Reset to zero first for safety with tokens that enforce the ERC20 race-condition mitigation\n        // Use standard approve for trusted protocol token (dStable) and trusted protocol contract (AmoManager)\n        dstable.approve(address(amoManager), 0);\n        dstable.approve(address(amoManager), amount);\n    }\n\n    /**\n     * @notice Sets a new AmoManager address\n     * @param _newAmoManager The address of the new AmoManager\n     * @dev Only callable by an account with the DEFAULT_ADMIN_ROLE\n     */\n    function setAmoManager(address _newAmoManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newAmoManager == address(0)) revert InvalidAmoManager();\n\n        // Revoke allowance from the previous AmoManager to prevent it from spending vault funds\n        // Use standard approve for trusted protocol token (dStable) and trusted protocol contract (AmoManager)\n        dstable.approve(address(amoManager), 0);\n\n        // Set new AMO manager\n        amoManager = AmoManager(_newAmoManager);\n\n        // Approve new AMO manager\n        approveAmoManager();\n    }\n\n    /* Recovery */\n\n    /**\n     * @notice Recovers ERC20 tokens accidentally sent to the contract\n     * @param token The address of the token to recover\n     * @param to The address to send the tokens to\n     * @param amount The amount of tokens to recover\n     */\n    function recoverERC20(address token, address to, uint256 amount) external onlyRole(RECOVERER_ROLE) nonReentrant {\n        if (token == address(dstable) || isCollateralSupported(token)) {\n            revert CannotRecoverVaultToken(token);\n        }\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Recovers ETH accidentally sent to the contract\n     * @param to The address to send the ETH to\n     * @param amount The amount of ETH to recover\n     */\n    function recoverETH(address to, uint256 amount) external onlyRole(RECOVERER_ROLE) {\n        payable(to).sendValue(amount);\n    }\n\n    /* Virtual functions */\n\n    /**\n     * @notice Calculates the total value of non-dStable collateral assets in the vault\n     * @return The total value of collateral assets denominated in the base currency\n     * @dev Must be implemented by derived contracts\n     */\n    function totalCollateralValue() public view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the total value of dStable holdings in the vault\n     * @return The total value of dStable holdings denominated in the base currency\n     * @dev Must be implemented by derived contracts\n     */\n    function totalDstableValue() public view virtual returns (uint256);\n}\n"
    },
    "contracts/dstable/CollateralHolderVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./CollateralVault.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title CollateralHolderVault\n * @notice Implementation of CollateralVault for only holding tokens\n */\ncontract CollateralHolderVault is CollateralVault {\n    using SafeERC20 for IERC20Metadata;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* Errors */\n    error CannotWithdrawMoreValueThanDeposited(uint256 requestedAmount, uint256 maxAmount);\n    error ToCollateralAmountBelowMin(uint256 toCollateralAmount, uint256 toMinCollateral);\n\n    constructor(IPriceOracleGetter oracle) CollateralVault(oracle) {}\n\n    /**\n     * @notice Exchanges one type of collateral for another\n     * @param fromCollateralAmount Amount of collateral to exchange from\n     * @param fromCollateral Address of the source collateral token\n     * @param toCollateralAmount Amount of collateral to receive\n     * @param toCollateral Address of the destination collateral token\n     * @dev Ensures the exchange maintains equivalent value using oracle prices\n     */\n    function exchangeCollateral(\n        uint256 fromCollateralAmount,\n        address fromCollateral,\n        uint256 toCollateralAmount,\n        address toCollateral\n    ) public onlyRole(COLLATERAL_STRATEGY_ROLE) {\n        // The collateral being received by the vault (fromCollateral) must still be supported\n        // `toCollateral` may have been de-listed (disallowed) in order to let the vault gradually\n        // swap it out, so we intentionally do NOT enforce the check on `toCollateral`.\n        require(_supportedCollaterals.contains(fromCollateral), \"Unsupported collateral\");\n        uint256 maxAmount = maxExchangeAmount(fromCollateralAmount, fromCollateral, toCollateral);\n        if (toCollateralAmount > maxAmount) {\n            revert CannotWithdrawMoreValueThanDeposited(toCollateralAmount, maxAmount);\n        }\n\n        IERC20Metadata(fromCollateral).safeTransferFrom(msg.sender, address(this), fromCollateralAmount);\n        IERC20Metadata(toCollateral).safeTransfer(msg.sender, toCollateralAmount);\n    }\n\n    /**\n     * @notice Exchanges collateral for the maximum possible amount of another collateral\n     * @param fromCollateralAmount Amount of collateral to exchange from\n     * @param fromCollateral Address of the source collateral token\n     * @param toCollateral Address of the destination collateral token\n     * @param toMinCollateral Minimum amount of destination collateral to receive\n     * @dev Calculates and executes the maximum possible exchange while respecting minimum amount\n     */\n    function exchangeMaxCollateral(\n        uint256 fromCollateralAmount,\n        address fromCollateral,\n        address toCollateral,\n        uint256 toMinCollateral\n    ) public onlyRole(COLLATERAL_STRATEGY_ROLE) {\n        uint256 toCollateralAmount = maxExchangeAmount(fromCollateralAmount, fromCollateral, toCollateral);\n        if (toCollateralAmount < toMinCollateral) {\n            revert ToCollateralAmountBelowMin(toCollateralAmount, toMinCollateral);\n        }\n        exchangeCollateral(fromCollateralAmount, fromCollateral, toCollateralAmount, toCollateral);\n    }\n\n    /**\n     * @notice Calculates the maximum amount of destination collateral that can be received\n     * @param fromCollateralAmount Amount of source collateral\n     * @param fromCollateral Address of the source collateral token\n     * @param toCollateral Address of the destination collateral token\n     * @return toCollateralAmount The maximum amount of destination collateral that can be received\n     * @dev Uses oracle prices and token decimals to maintain equivalent value\n     */\n    function maxExchangeAmount(\n        uint256 fromCollateralAmount,\n        address fromCollateral,\n        address toCollateral\n    ) public view returns (uint256 toCollateralAmount) {\n        uint256 fromCollateralPrice = oracle.getAssetPrice(fromCollateral);\n        uint256 toCollateralPrice = oracle.getAssetPrice(toCollateral);\n\n        uint8 fromCollateralDecimals = IERC20Metadata(fromCollateral).decimals();\n        uint8 toCollateralDecimals = IERC20Metadata(toCollateral).decimals();\n\n        uint256 fromCollateralBaseValue = Math.mulDiv(\n            fromCollateralPrice,\n            fromCollateralAmount,\n            10 ** fromCollateralDecimals\n        );\n\n        toCollateralAmount = Math.mulDiv(fromCollateralBaseValue, 10 ** toCollateralDecimals, toCollateralPrice);\n\n        return toCollateralAmount;\n    }\n\n    /**\n     * @notice Calculates the total value of all collateral in the vault\n     * @return baseValue The total value of all collateral in base\n     */\n    function totalValue() public view override returns (uint256 baseValue) {\n        return _totalValueOfSupportedCollaterals();\n    }\n}\n"
    },
    "contracts/dstable/CollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"contracts/common/IAaveOracle.sol\";\nimport \"./OracleAware.sol\";\n\n/**\n * @title CollateralVault\n * @notice Abstract contract for any contract that manages collateral assets\n\\ */\nabstract contract CollateralVault is AccessControl, OracleAware {\n    using SafeERC20 for IERC20Metadata;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* Core state */\n\n    EnumerableSet.AddressSet internal _supportedCollaterals;\n\n    /* Events */\n\n    event CollateralAllowed(address indexed collateralAsset);\n    event CollateralDisallowed(address indexed collateralAsset);\n\n    /* Roles */\n\n    bytes32 public constant COLLATERAL_MANAGER_ROLE = keccak256(\"COLLATERAL_MANAGER_ROLE\");\n    bytes32 public constant COLLATERAL_STRATEGY_ROLE = keccak256(\"COLLATERAL_STRATEGY_ROLE\");\n    bytes32 public constant COLLATERAL_WITHDRAWER_ROLE = keccak256(\"COLLATERAL_WITHDRAWER_ROLE\");\n\n    /* Errors */\n    error UnsupportedCollateral(address collateralAsset);\n    error CollateralAlreadyAllowed(address collateralAsset);\n    error NoOracleSupport(address collateralAsset);\n    error FailedToAddCollateral(address collateralAsset);\n    error CollateralNotSupported(address collateralAsset);\n    error MustSupportAtLeastOneCollateral();\n    error FailedToRemoveCollateral(address collateralAsset);\n\n    /**\n     * @notice Initializes the vault with an oracle and sets up initial roles\n     * @dev Grants all roles to the contract deployer initially\n     * @param oracle The price oracle to use for collateral valuation\n     */\n    constructor(IPriceOracleGetter oracle) OracleAware(oracle, oracle.BASE_CURRENCY_UNIT()) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // This is the super admin\n        grantRole(COLLATERAL_MANAGER_ROLE, msg.sender);\n        grantRole(COLLATERAL_WITHDRAWER_ROLE, msg.sender);\n        grantRole(COLLATERAL_STRATEGY_ROLE, msg.sender);\n    }\n\n    /* Deposit */\n\n    /**\n     * @notice Deposit collateral into the vault\n     * @param collateralAmount The amount of collateral to deposit\n     * @param collateralAsset The address of the collateral asset\n     */\n    function deposit(uint256 collateralAmount, address collateralAsset) public {\n        if (!_supportedCollaterals.contains(collateralAsset)) {\n            revert UnsupportedCollateral(collateralAsset);\n        }\n\n        IERC20Metadata(collateralAsset).safeTransferFrom(msg.sender, address(this), collateralAmount);\n    }\n\n    /* Withdrawal */\n\n    /**\n     * @notice Withdraws collateral from the vault\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function withdraw(uint256 collateralAmount, address collateralAsset) public onlyRole(COLLATERAL_WITHDRAWER_ROLE) {\n        return _withdraw(msg.sender, collateralAmount, collateralAsset);\n    }\n\n    /**\n     * @notice Withdraws collateral from the vault to a specific address\n     * @param recipient The address receiving the collateral\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function withdrawTo(\n        address recipient,\n        uint256 collateralAmount,\n        address collateralAsset\n    ) public onlyRole(COLLATERAL_WITHDRAWER_ROLE) {\n        return _withdraw(recipient, collateralAmount, collateralAsset);\n    }\n\n    /**\n     * @notice Internal function to withdraw collateral from the vault\n     * @param withdrawer The address withdrawing the collateral\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function _withdraw(address withdrawer, uint256 collateralAmount, address collateralAsset) internal {\n        IERC20Metadata(collateralAsset).safeTransfer(withdrawer, collateralAmount);\n    }\n\n    /* Collateral Info */\n\n    /**\n     * @notice Calculates the total value of all assets in the vault\n     * @return baseValue The total value of all assets in base\n     */\n    function totalValue() public view virtual returns (uint256 baseValue);\n\n    /**\n     * @notice Calculates the base value of a given amount of an asset\n     * @param assetAmount The amount of the asset\n     * @param asset The address of the asset\n     * @return baseValue The base value of the asset\n     */\n    function assetValueFromAmount(uint256 assetAmount, address asset) public view returns (uint256 baseValue) {\n        uint256 assetPrice = oracle.getAssetPrice(asset);\n        uint8 assetDecimals = IERC20Metadata(asset).decimals();\n        return Math.mulDiv(assetPrice, assetAmount, 10 ** assetDecimals);\n    }\n\n    /**\n     * @notice Calculates the amount of an asset that corresponds to a given base value\n     * @param baseValue The base value\n     * @param asset The address of the asset\n     * @return assetAmount The amount of the asset\n     */\n    function assetAmountFromValue(uint256 baseValue, address asset) public view returns (uint256 assetAmount) {\n        uint256 assetPrice = oracle.getAssetPrice(asset);\n        uint8 assetDecimals = IERC20Metadata(asset).decimals();\n        return Math.mulDiv(baseValue, 10 ** assetDecimals, assetPrice);\n    }\n\n    /* Collateral management */\n\n    /**\n     * @notice Allows a new collateral asset\n     * @param collateralAsset The address of the collateral asset\n     */\n    function allowCollateral(address collateralAsset) public onlyRole(COLLATERAL_MANAGER_ROLE) {\n        if (_supportedCollaterals.contains(collateralAsset)) {\n            revert CollateralAlreadyAllowed(collateralAsset);\n        }\n        if (oracle.getAssetPrice(collateralAsset) == 0) {\n            revert NoOracleSupport(collateralAsset);\n        }\n        if (!_supportedCollaterals.add(collateralAsset)) {\n            revert FailedToAddCollateral(collateralAsset);\n        }\n        emit CollateralAllowed(collateralAsset);\n    }\n\n    /**\n     * @notice Disallows a previously supported collateral asset\n     * @dev Requires at least one collateral asset to remain supported\n     * @param collateralAsset The address of the collateral asset to disallow\n     */\n    function disallowCollateral(address collateralAsset) public onlyRole(COLLATERAL_MANAGER_ROLE) {\n        if (!_supportedCollaterals.contains(collateralAsset)) {\n            revert CollateralNotSupported(collateralAsset);\n        }\n        if (_supportedCollaterals.length() <= 1) {\n            revert MustSupportAtLeastOneCollateral();\n        }\n        if (!_supportedCollaterals.remove(collateralAsset)) {\n            revert FailedToRemoveCollateral(collateralAsset);\n        }\n\n        emit CollateralDisallowed(collateralAsset);\n    }\n\n    /**\n     * @notice Checks if a given asset is supported as collateral\n     * @param collateralAsset The address of the collateral asset to check\n     * @return bool True if the asset is supported, false otherwise\n     */\n    function isCollateralSupported(address collateralAsset) public view returns (bool) {\n        return _supportedCollaterals.contains(collateralAsset);\n    }\n\n    /**\n     * @notice Returns a list of all supported collateral assets\n     * @return address[] Array of collateral asset addresses\n     */\n    function listCollateral() public view returns (address[] memory) {\n        return _supportedCollaterals.values();\n    }\n\n    /**\n     * @notice Calculates the total base value of all supported collateral assets in the vault\n     * @dev Iterates through all supported collaterals and sums their base values\n     * @return uint256 The total value in base\n     */\n    function _totalValueOfSupportedCollaterals() internal view returns (uint256) {\n        uint256 totalBaseValue = 0;\n        for (uint256 i = 0; i < _supportedCollaterals.length(); i++) {\n            address collateral = _supportedCollaterals.at(i);\n            uint256 collateralPrice = oracle.getAssetPrice(collateral);\n            uint8 collateralDecimals = IERC20Metadata(collateral).decimals();\n            uint256 collateralValue = Math.mulDiv(\n                collateralPrice,\n                IERC20Metadata(collateral).balanceOf(address(this)),\n                10 ** collateralDecimals\n            );\n            totalBaseValue += collateralValue;\n        }\n        return totalBaseValue;\n    }\n}\n"
    },
    "contracts/dstable/ERC20StablecoinUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\\\"\\_\\ \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract ERC20StablecoinUpgradeable is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PausableUpgradeable,\n    AccessControlUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20FlashMintUpgradeable\n{\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    string private _tokenName;\n    string private _tokenSymbol;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(string memory initialName, string memory initialSymbol) public initializer {\n        __ERC20_init(initialName, initialSymbol);\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __AccessControl_init();\n        __ERC20Permit_init(initialName);\n        __ERC20FlashMint_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PAUSER_ROLE, msg.sender);\n\n        _tokenName = initialName;\n        _tokenSymbol = initialSymbol;\n    }\n\n    // By convention all dStable tokens have 18 decimals on all chains\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function pause() public onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    function unpause() public onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override(ERC20Upgradeable, ERC20PausableUpgradeable) whenNotPaused {\n        super._update(from, to, value);\n    }\n\n    function setNameAndSymbol(string memory newName, string memory newSymbol) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _tokenName = newName;\n        _tokenSymbol = newSymbol;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _tokenName;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _tokenSymbol;\n    }\n\n    // Ensure EIP712 domain uses the latest name\n    function _EIP712Name() internal view override returns (string memory) {\n        return _tokenName;\n    }\n}\n"
    },
    "contracts/dstable/mocks/MockAmoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"contracts/dstable/AmoVault.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract MockAmoVault is AmoVault {\n    using SafeERC20 for IERC20;\n\n    uint256 private fakeDeFiCollateralValue;\n\n    constructor(\n        address _dstable,\n        address _amoManager,\n        address _admin,\n        address _collateralWithdrawer,\n        address _recoverer,\n        IPriceOracleGetter _oracle\n    ) AmoVault(_dstable, _amoManager, _admin, _collateralWithdrawer, _recoverer, _oracle) {}\n\n    // Override totalCollateralValue to return the sum of all simulated values\n    function totalCollateralValue() public view override returns (uint256) {\n        return _totalValueOfSupportedCollaterals() + fakeDeFiCollateralValue;\n    }\n\n    // Override totalDstableValue to return the sum of all simulated values\n    function totalDstableValue() public view override returns (uint256) {\n        uint256 dstableBalance = dstable.balanceOf(address(this));\n        uint256 dstablePrice = oracle.getAssetPrice(address(dstable));\n        uint256 dstableValue = (dstableBalance * dstablePrice) / (10 ** dstableDecimals);\n\n        return dstableValue;\n    }\n\n    function totalValue() public view override returns (uint256) {\n        return totalCollateralValue() + totalDstableValue();\n    }\n\n    // Simulate AmoVault losing some value\n    function mockRemoveAsset(address asset, uint256 amount) external {\n        IERC20(asset).safeTransfer(\n            address(0x000000000000000000000000000000000000dEaD), // Arbitrary black hole address\n            amount\n        );\n    }\n\n    // Simulate fake DeFi returns\n    function getFakeDeFiCollateralValue() external view returns (uint256) {\n        return fakeDeFiCollateralValue;\n    }\n\n    // Set fake DeFi collateral value\n    function setFakeDeFiCollateralValue(uint256 value) external {\n        fakeDeFiCollateralValue = value;\n    }\n}\n"
    },
    "contracts/dstable/OracleAware.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"contracts/common/IAaveOracle.sol\";\n\n/**\n * @title OracleAware\n * @notice Abstract contract that provides oracle functionality to other contracts\n */\nabstract contract OracleAware is AccessControl {\n    /* Core state */\n\n    IPriceOracleGetter public oracle;\n    uint256 public baseCurrencyUnit;\n\n    /* Events */\n\n    event OracleSet(address indexed newOracle);\n\n    /* Errors */\n\n    error IncorrectBaseCurrencyUnit(uint256 baseCurrencyUnit);\n\n    /**\n     * @notice Initializes the contract with an oracle and base currency unit\n     * @param initialOracle The initial oracle to use for price feeds\n     * @param _baseCurrencyUnit The base currency unit for price calculations\n     * @dev Sets up the initial oracle and base currency unit values\n     */\n    constructor(IPriceOracleGetter initialOracle, uint256 _baseCurrencyUnit) {\n        oracle = initialOracle;\n        baseCurrencyUnit = _baseCurrencyUnit;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Sets the oracle to use for collateral valuation\n     * @param newOracle The new oracle to use\n     */\n    function setOracle(IPriceOracleGetter newOracle) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newOracle.BASE_CURRENCY_UNIT() != baseCurrencyUnit) {\n            revert IncorrectBaseCurrencyUnit(baseCurrencyUnit);\n        }\n\n        oracle = newOracle;\n\n        emit OracleSet(address(newOracle));\n    }\n\n    /**\n     * @notice Updates the base currency unit used for price calculations\n     * @param _newBaseCurrencyUnit The new base currency unit to set\n     * @dev Only used if the oracle's base currency unit changes\n     */\n    function setBaseCurrencyUnit(uint256 _newBaseCurrencyUnit) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        baseCurrencyUnit = _newBaseCurrencyUnit;\n    }\n}\n"
    },
    "contracts/mocks/MockAdapterPositiveSlippage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDStableConversionAdapter } from \"../vaults/dstake/interfaces/IDStableConversionAdapter.sol\";\nimport { MockERC4626Simple } from \"./MockERC4626Simple.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\ncontract MockAdapterPositiveSlippage is IDStableConversionAdapter {\n    address public immutable dStable;\n    MockERC4626Simple public immutable vaultToken;\n    address public immutable collateralVault;\n\n    constructor(address _dStable, address _collateralVault) {\n        dStable = _dStable;\n        collateralVault = _collateralVault;\n        vaultToken = new MockERC4626Simple(IERC20(_dStable));\n    }\n\n    function convertToVaultAsset(\n        uint256 dStableAmount\n    ) external override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        IERC20(dStable).transferFrom(msg.sender, address(this), dStableAmount);\n        // Mock contract: Use standard approve for testing purposes\n        IERC20(dStable).approve(address(vaultToken), dStableAmount);\n        vaultAssetAmount = vaultToken.deposit(dStableAmount, collateralVault);\n        return (address(vaultToken), vaultAssetAmount);\n    }\n\n    function convertFromVaultAsset(uint256 vaultAssetAmount) external override returns (uint256 dStableAmount) {\n        // pull vault tokens\n        IERC20(address(vaultToken)).transferFrom(msg.sender, address(this), vaultAssetAmount);\n        IERC20(address(vaultToken)).approve(address(vaultToken), vaultAssetAmount);\n        dStableAmount = vaultToken.redeem(vaultAssetAmount, msg.sender, address(this));\n    }\n\n    function previewConvertToVaultAsset(\n        uint256 dStableAmount\n    ) external view override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        return (address(vaultToken), dStableAmount);\n    }\n\n    function previewConvertFromVaultAsset(\n        uint256 vaultAssetAmount\n    ) external view override returns (uint256 dStableAmount) {\n        return vaultToken.previewRedeem(vaultAssetAmount);\n    }\n\n    function assetValueInDStable(\n        address _vaultAsset,\n        uint256 vaultAssetAmount\n    ) external view override returns (uint256 dStableValue) {\n        require(_vaultAsset == address(vaultToken), \"Wrong asset\");\n        return vaultToken.previewRedeem(vaultAssetAmount);\n    }\n\n    function vaultAsset() external view override returns (address) {\n        return address(vaultToken);\n    }\n}\n"
    },
    "contracts/mocks/MockAdapterSmallDepositRevert.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockERC4626Simple } from \"./MockERC4626Simple.sol\";\nimport { IDStableConversionAdapter } from \"../vaults/dstake/interfaces/IDStableConversionAdapter.sol\";\n\n/**\n * @title MockAdapterSmallDepositRevert\n * @notice Test-only adapter that intentionally reverts when `convertToVaultAsset`\n *         is called with < 2 wei of dSTABLE.  Used to reproduce the dStakeRouter\n *         surplus-rounding DoS in unit tests.\n */\ncontract MockAdapterSmallDepositRevert is IDStableConversionAdapter {\n    // --- Errors ---\n    error ZeroAddress();\n    error DepositTooSmall(uint256 amount);\n\n    // --- Constants ---\n    uint256 private constant MIN_DEPOSIT = 2; // Wei of dSTABLE required for a successful deposit\n\n    // --- State ---\n    IERC20 public immutable dStable; // underlying stablecoin\n    MockERC4626Simple public immutable vaultAssetToken; // mock wrapped asset\n    address public immutable collateralVault; // DStakeCollateralVault address (receiver of minted shares)\n\n    constructor(address _dStable, address _collateralVault) {\n        if (_dStable == address(0) || _collateralVault == address(0)) {\n            revert ZeroAddress();\n        }\n        dStable = IERC20(_dStable);\n        collateralVault = _collateralVault;\n        // Deploy the simple ERC4626 vault token (1:1 deposit)\n        vaultAssetToken = new MockERC4626Simple(IERC20(_dStable));\n    }\n\n    // ---------------- IDStableConversionAdapter ----------------\n\n    function convertToVaultAsset(\n        uint256 dStableAmount\n    ) external override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        if (dStableAmount < MIN_DEPOSIT) revert DepositTooSmall(dStableAmount);\n\n        // Pull dStable from caller (Router)\n        dStable.transferFrom(msg.sender, address(this), dStableAmount);\n\n        // Deposit dStable into the ERC4626 mock, minting shares to the vault\n        IERC20(address(dStable)).approve(address(vaultAssetToken), dStableAmount);\n        vaultAssetToken.deposit(dStableAmount, collateralVault);\n\n        _vaultAsset = address(vaultAssetToken);\n        vaultAssetAmount = dStableAmount;\n    }\n\n    function convertFromVaultAsset(uint256 vaultAssetAmount) external override returns (uint256 dStableAmount) {\n        // Pull shares from caller (Router)\n        IERC20(address(vaultAssetToken)).transferFrom(msg.sender, address(this), vaultAssetAmount);\n\n        // Redeem shares for dStable, sending the dStable directly to the router (msg.sender)\n        dStableAmount = vaultAssetToken.redeem(vaultAssetAmount, msg.sender, address(this));\n    }\n\n    function previewConvertToVaultAsset(\n        uint256 dStableAmount\n    ) external view override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        _vaultAsset = address(vaultAssetToken);\n        vaultAssetAmount = dStableAmount;\n    }\n\n    function previewConvertFromVaultAsset(\n        uint256 vaultAssetAmount\n    ) external pure override returns (uint256 dStableAmount) {\n        return (vaultAssetAmount * 11000) / 10000; // 1.1x like MockERC4626Simple\n    }\n\n    function assetValueInDStable(\n        address _vaultAsset,\n        uint256 vaultAssetAmount\n    ) external pure override returns (uint256 dStableValue) {\n        require(_vaultAsset == address(0) || _vaultAsset != address(0), \"NOP\"); // dummy check to silence linter\n        return (vaultAssetAmount * 11000) / 10000;\n    }\n\n    function vaultAsset() external view override returns (address) {\n        return address(vaultAssetToken);\n    }\n}\n"
    },
    "contracts/mocks/MockERC4626Simple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title MockERC4626Simple\n * @dev Very small ERC-4626 vault used only in tests. Behaves 1:1 on deposits,\n *      but on redeem / withdraw returns 10 % more dStable than theoretical\n *      book value to simulate positive slippage / yield.\n */\ncontract MockERC4626Simple is ERC4626 {\n    uint256 private constant BONUS_BPS = 11_000; // 110 % (10000 = 100 %)\n    uint256 private constant BASIS_POINTS = 10_000;\n\n    constructor(IERC20 _asset) ERC20(\"Mock Vault Token\", \"mVT\") ERC4626(_asset) {}\n\n    // ---------- Deposit path (1:1) ---------- //\n    // The default ERC4626 implementation already mints shares == assets when\n    // totalSupply() == 0, so no override is necessary.\n\n    // ---------- Redemption path (adds 10 % bonus) ---------- //\n\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        // users get 110 % of the nominal assets represented by `shares`\n        return (shares * BONUS_BPS) / BASIS_POINTS;\n    }\n\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        // inverse of previewRedeem (ceil division to avoid under-funding)\n        return (assets * BASIS_POINTS + BONUS_BPS - 1) / BONUS_BPS;\n    }\n\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {\n        // Transfer shares from owner (handles allowance)\n        if (owner != _msgSender()) {\n            _spendAllowance(owner, _msgSender(), shares);\n        }\n\n        // Calculate assets including bonus and burn shares\n        assets = previewRedeem(shares);\n        _burn(owner, shares);\n\n        // Pull the underlying tokens from vault and send to receiver\n        IERC20(asset()).transfer(receiver, assets);\n\n        emit Withdraw(_msgSender(), receiver, owner, assets, shares);\n    }\n\n    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        redeem(shares, receiver, owner); // redeem already handles transfer & events\n    }\n}\n"
    },
    "contracts/oracle_aggregator/chainlink/ChainlinkCompositeAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/chainlink/IAggregatorV3Interface.sol\";\nimport \"../wrapper/ThresholdingUtils.sol\";\n\n/**\n * @title ChainlinkCompositeAggregator\n * @notice Composes prices from two Chainlink price feeds with thresholding\n * @dev Implements AggregatorV3Interface to mimic being a Chainlink price feed\n *      Uses the same composition logic as RedstoneChainlinkCompositeWrapperWithThresholding\n */\ncontract ChainlinkCompositeAggregator is AggregatorV3Interface, ThresholdingUtils {\n    /// @notice First source Chainlink price feed\n    AggregatorV3Interface public immutable sourceFeed1;\n\n    /// @notice Second source Chainlink price feed\n    AggregatorV3Interface public immutable sourceFeed2;\n\n    /// @notice Target decimals for composite price (Chainlink standard: 8)\n    uint8 public constant override decimals = 8;\n\n    /// @notice Base currency unit for price normalization (10^8)\n    uint256 public constant CHAINLINK_BASE_CURRENCY_UNIT = 10 ** 8;\n\n    /// @notice Primary threshold configuration for sourceFeed1\n    ThresholdConfig public primaryThreshold;\n\n    /// @notice Secondary threshold configuration for sourceFeed2\n    ThresholdConfig public secondaryThreshold;\n\n    /// @notice Chainlink heartbeat period (24 hours)\n    uint256 public constant CHAINLINK_HEARTBEAT = 86400;\n\n    /// @notice Heartbeat stale time limit (additional buffer)\n    uint256 public constant heartbeatStaleTimeLimit = 3600; // 1 hour\n\n    /// @notice Error thrown when price is stale\n    error PriceIsStale();\n\n    /// @notice Error thrown when a feed address is zero\n    error ZeroFeedAddress();\n\n    /**\n     * @notice Constructor to initialize the composite wrapper\n     * @param _sourceFeed1 Address of the first source Chainlink price feed\n     * @param _sourceFeed2 Address of the second source Chainlink price feed\n     * @param _primaryThreshold Primary threshold configuration for feed1\n     * @param _secondaryThreshold Secondary threshold configuration for feed2\n     */\n    constructor(\n        address _sourceFeed1,\n        address _sourceFeed2,\n        ThresholdConfig memory _primaryThreshold,\n        ThresholdConfig memory _secondaryThreshold\n    ) {\n        // Validate feed addresses\n        if (_sourceFeed1 == address(0) || _sourceFeed2 == address(0)) {\n            revert ZeroFeedAddress();\n        }\n\n        sourceFeed1 = AggregatorV3Interface(_sourceFeed1);\n        sourceFeed2 = AggregatorV3Interface(_sourceFeed2);\n        primaryThreshold = _primaryThreshold;\n        secondaryThreshold = _secondaryThreshold;\n    }\n\n    /**\n     * @notice Returns the description of the composite feed\n     * @return Description string\n     */\n    function description() external view override returns (string memory) {\n        return string(abi.encodePacked(sourceFeed1.description(), \" x \", sourceFeed2.description(), \" (Composite)\"));\n    }\n\n    /**\n     * @notice Returns the version of the original feed\n     * @return Version number\n     */\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Gets data for the latest round\n     * @return roundId The round ID\n     * @return answer The composite price with target decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        // Get latest data from both feeds\n        (uint80 roundId1, int256 answer1, uint256 startedAt1, uint256 updatedAt1, uint80 answeredInRound1) = sourceFeed1\n            .latestRoundData();\n\n        (\n            ,\n            // roundId2,\n            int256 answer2,\n            uint256 startedAt2,\n            uint256 updatedAt2, // answeredInRound2\n\n        ) = sourceFeed2.latestRoundData();\n\n        // Check if prices are stale\n        if (\n            updatedAt1 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit <= block.timestamp ||\n            updatedAt2 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit <= block.timestamp\n        ) {\n            revert PriceIsStale();\n        }\n\n        // Use the latest timestamp from both feeds\n        uint256 latestUpdatedAt = updatedAt1 > updatedAt2 ? updatedAt1 : updatedAt2;\n        uint256 latestStartedAt = startedAt1 > startedAt2 ? startedAt1 : startedAt2;\n\n        // Calculate composite price using the same logic as Redstone wrapper\n        uint256 compositePrice = _calculateCompositePrice(answer1, answer2);\n\n        return (\n            roundId1, // Use the first feed's round ID\n            int256(compositePrice),\n            latestStartedAt,\n            latestUpdatedAt,\n            answeredInRound1 // Use the first feed's answeredInRound\n        );\n    }\n\n    /**\n     * @notice Gets data for a specific round\n     * @dev IMPORTANT: Due to Chainlink round ID divergence between feeds, this aggregator only supports latest data.\n     *      Historical round queries are not supported and will always return the latest available data.\n     *      Use latestRoundData() for the most recent price information.\n     * @param roundId (ignored, always returns latest data)\n     * @return roundId The round ID\n     * @return answer The composite price with target decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function getRoundData(\n        uint80 /* _roundId */\n    )\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        // Delegate to latestRoundData to avoid round ID divergence issues\n        return this.latestRoundData();\n    }\n\n    /**\n     * @notice Calculate composite price using the same logic as Redstone wrapper\n     * @param answer1 Price from first feed\n     * @param answer2 Price from second feed\n     * @return Composite price in target decimals\n     */\n    function _calculateCompositePrice(int256 answer1, int256 answer2) internal view returns (uint256) {\n        // Convert negative answers to 0 (same as Redstone wrapper)\n        uint256 chainlinkPrice1 = answer1 > 0 ? uint256(answer1) : 0;\n        uint256 chainlinkPrice2 = answer2 > 0 ? uint256(answer2) : 0;\n\n        // Convert both prices to base currency unit first\n        uint256 priceInBase1 = _convertToBaseCurrencyUnit(chainlinkPrice1, sourceFeed1.decimals());\n        uint256 priceInBase2 = _convertToBaseCurrencyUnit(chainlinkPrice2, sourceFeed2.decimals());\n\n        // Apply thresholding to prices in base currency unit if specified\n        if (primaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase1 = _applyThreshold(priceInBase1, primaryThreshold);\n        }\n        if (secondaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase2 = _applyThreshold(priceInBase2, secondaryThreshold);\n        }\n\n        // Calculate composite price: (price1 * price2) / baseCurrencyUnit\n        return (priceInBase1 * priceInBase2) / CHAINLINK_BASE_CURRENCY_UNIT;\n    }\n\n    /**\n     * @notice Convert price to base currency unit (same logic as Redstone wrapper)\n     * @param price Price in source decimals\n     * @param sourceDecimals Decimal precision of the source price\n     * @return Price in base currency unit\n     */\n    function _convertToBaseCurrencyUnit(uint256 price, uint8 sourceDecimals) internal pure returns (uint256) {\n        if (sourceDecimals > decimals) {\n            // Scale down to target decimals\n            return price / (10 ** (sourceDecimals - decimals));\n        } else if (sourceDecimals < decimals) {\n            // Scale up to target decimals\n            return price * (10 ** (decimals - sourceDecimals));\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/chainlink/ChainlinkDecimalConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/chainlink/IAggregatorV3Interface.sol\";\n\n/**\n * @title ChainlinkDecimalConverter\n * @notice Converts between Chainlink price feeds with different decimal precisions\n * @dev Implements AggregatorV3Interface to mimic being a Chainlink price feed\n */\ncontract ChainlinkDecimalConverter is AggregatorV3Interface {\n    /// @notice Original Chainlink price feed\n    AggregatorV3Interface public immutable sourceFeed;\n\n    /// @notice Original decimals from the source feed\n    uint8 public immutable sourceDecimals;\n\n    /// @notice Target decimals for price conversion\n    uint8 public immutable override decimals;\n\n    /// @notice Scaling factor to convert between source and target decimals\n    int256 private immutable scalingFactor;\n\n    /**\n     * @notice Error thrown when target decimals exceed source decimals\n     */\n    error InvalidDecimalsUpscaleNotSupported();\n\n    /**\n     * @notice Constructor to initialize the decimal converter\n     * @param _sourceFeed Address of the source Chainlink price feed\n     * @param _targetDecimals Target decimal precision (must be less than or equal to source decimals)\n     */\n    constructor(address _sourceFeed, uint8 _targetDecimals) {\n        sourceFeed = AggregatorV3Interface(_sourceFeed);\n        sourceDecimals = sourceFeed.decimals();\n        decimals = _targetDecimals;\n\n        // We only support downscaling (reducing precision), not upscaling\n        if (_targetDecimals > sourceDecimals) {\n            revert InvalidDecimalsUpscaleNotSupported();\n        }\n\n        // Calculate the scaling factor to convert from source to target decimals\n        uint8 decimalDifference = sourceDecimals - _targetDecimals;\n        scalingFactor = int256(10 ** decimalDifference);\n    }\n\n    /**\n     * @notice Returns the description of the original feed\n     * @return Description string\n     */\n    function description() external view override returns (string memory) {\n        return sourceFeed.description();\n    }\n\n    /**\n     * @notice Returns the version of the original feed\n     * @return Version number\n     */\n    function version() external view override returns (uint256) {\n        return sourceFeed.version();\n    }\n\n    /**\n     * @notice Gets data for a specific round\n     * @param _roundId The round ID to retrieve data for\n     * @return roundId The round ID\n     * @return answer The price with adjusted decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        (roundId, answer, startedAt, updatedAt, answeredInRound) = sourceFeed.getRoundData(_roundId);\n        answer = answer / scalingFactor;\n    }\n\n    /**\n     * @notice Gets data for the latest round\n     * @return roundId The round ID\n     * @return answer The price with adjusted decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        (roundId, answer, startedAt, updatedAt, answeredInRound) = sourceFeed.latestRoundData();\n        answer = answer / scalingFactor;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/interface/api3/BaseAPI3Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../IOracleWrapper.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title BaseAPI3Wrapper\n * @dev Abstract contract that implements the IOracleWrapper interface for API3 oracles\n * Provides common functionality for all API3 oracle wrappers\n */\nabstract contract BaseAPI3Wrapper is IOracleWrapper, AccessControl {\n    /* Core state */\n\n    uint256 public constant API3_BASE_CURRENCY_UNIT = 10 ** 18;\n    uint256 public constant API3_HEARTBEAT = 24 hours;\n    address private immutable _baseCurrency;\n    uint256 public immutable BASE_CURRENCY_UNIT;\n    uint256 public heartbeatStaleTimeLimit = 30 minutes;\n\n    /* Roles */\n\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER_ROLE\");\n\n    /* Errors */\n\n    error PriceIsStale();\n\n    /**\n     * @dev Constructor that sets the base currency and base currency unit\n     * @param baseCurrency The address of the base currency (zero address for USD)\n     * @param _baseCurrencyUnit The decimal precision of the base currency (e.g., 1e8 for USD)\n     */\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) {\n        _baseCurrency = baseCurrency;\n        BASE_CURRENCY_UNIT = _baseCurrencyUnit;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Returns the base currency address\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view override returns (address) {\n        return _baseCurrency;\n    }\n\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive);\n\n    function getAssetPrice(address asset) external view virtual override returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceIsStale();\n        }\n        return price;\n    }\n\n    function _convertToBaseCurrencyUnit(uint256 price) internal view returns (uint256) {\n        return (price * BASE_CURRENCY_UNIT) / API3_BASE_CURRENCY_UNIT;\n    }\n\n    function setHeartbeatStaleTimeLimit(uint256 _newHeartbeatStaleTimeLimit) external onlyRole(ORACLE_MANAGER_ROLE) {\n        heartbeatStaleTimeLimit = _newHeartbeatStaleTimeLimit;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/interface/api3/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/// @dev See DapiProxy.sol for comments about usage\ninterface IProxy {\n    function read() external view returns (int224 value, uint32 timestamp);\n\n    function api3ServerV1() external view returns (address);\n}\n"
    },
    "contracts/oracle_aggregator/interface/chainlink/BaseChainlinkWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../IOracleWrapper.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title BaseChainlinkWrapper\n * @dev Abstract contract that implements the IOracleWrapper interface for Chainlink-style oracles\n * Provides common functionality for all Chainlink-compatible oracle wrappers\n */\nabstract contract BaseChainlinkWrapper is IOracleWrapper, AccessControl {\n    /* Core state */\n\n    uint256 public constant CHAINLINK_BASE_CURRENCY_UNIT = 10 ** 8; // Chainlink uses 8 decimals\n    uint256 public constant CHAINLINK_HEARTBEAT = 24 hours;\n    address private immutable _baseCurrency;\n    uint256 public immutable BASE_CURRENCY_UNIT;\n    uint256 public heartbeatStaleTimeLimit = 30 minutes;\n\n    /* Roles */\n\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER_ROLE\");\n\n    /* Errors */\n\n    error PriceIsStale();\n    error InvalidPrice();\n    error FeedNotSet(address asset);\n\n    /**\n     * @dev Constructor that sets the base currency and base currency unit\n     * @param baseCurrency The address of the base currency (zero address for USD)\n     * @param _baseCurrencyUnit The decimal precision of the base currency (e.g., 1e8 for USD)\n     */\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) {\n        _baseCurrency = baseCurrency;\n        BASE_CURRENCY_UNIT = _baseCurrencyUnit;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Returns the base currency address\n     * @return Returns the base currency address\n     */\n    function BASE_CURRENCY() external view override returns (address) {\n        return _baseCurrency;\n    }\n\n    /**\n     * @notice Gets the price information for an asset\n     * @param asset The address of the asset to get the price for\n     * @return price The price of the asset in base currency units\n     * @return isAlive Whether the price feed is considered active/valid\n     */\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive);\n\n    /**\n     * @notice Gets the current price of an asset\n     * @param asset The address of the asset to get the price for\n     * @return The current price of the asset\n     */\n    function getAssetPrice(address asset) external view virtual override returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceIsStale();\n        }\n        return price;\n    }\n\n    /**\n     * @dev Converts a price from Chainlink decimals to base currency decimals\n     * @param price The price in Chainlink decimals\n     * @return The price in base currency decimals\n     */\n    function _convertToBaseCurrencyUnit(uint256 price) internal view returns (uint256) {\n        return (price * BASE_CURRENCY_UNIT) / CHAINLINK_BASE_CURRENCY_UNIT;\n    }\n\n    /**\n     * @notice Sets the heartbeat stale time limit\n     * @param _newHeartbeatStaleTimeLimit The new heartbeat stale time limit\n     */\n    function setHeartbeatStaleTimeLimit(uint256 _newHeartbeatStaleTimeLimit) external onlyRole(ORACLE_MANAGER_ROLE) {\n        heartbeatStaleTimeLimit = _newHeartbeatStaleTimeLimit;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/interface/chainlink/IAggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle_aggregator/interface/chainlink/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\ninterface IPriceFeed {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle_aggregator/interface/IOracleWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface for the individual oracle wrappers, to unify interface between Redstone and API3 for example\n */\ninterface IOracleWrapper {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is commonly used for USD, but can be any token address based on the implementation.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev Represents the decimal precision of the base currency (e.g., 1e8 for USD, 1e18 for ETH).\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the price and alive status of an asset\n     * @param asset The address of the asset\n     * @return price The price of the asset\n     * @return isAlive The alive status of the asset\n     */\n    function getPriceInfo(address asset) external view returns (uint256 price, bool isAlive);\n}\n"
    },
    "contracts/oracle_aggregator/interface/liquidityV2/BaseLiquidityV2Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../IOracleWrapper.sol\";\nimport \"./ILiquityV2OracleAggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title BaseLiquityV2Wrapper\n * @dev Abstract contract that implements the IOracleWrapper interface for Liquity V2 oracles\n * Provides common functionality for all Liquity V2-compatible oracle wrappers\n */\nabstract contract BaseLiquityV2Wrapper is IOracleWrapper, AccessControl {\n    /* Core state */\n\n    uint256 public constant LIQUITY_V2_BASE_CURRENCY_UNIT = 10 ** 18;\n    uint8 public constant BASE_CURRENCY_DECIMALS = 18; // Decimals matching LIQUITY_V2_BASE_CURRENCY_UNIT\n    uint256 public constant LIQUITY_V2_HEARTBEAT = 4 hours;\n    address private immutable _baseCurrency;\n    uint256 public immutable BASE_CURRENCY_UNIT;\n    uint256 public heartbeatStaleTimeLimit = 30 minutes;\n\n    /* Roles */\n\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER_ROLE\");\n\n    /* Errors */\n\n    error PriceIsStale();\n    error InvalidPrice();\n    error FeedNotSet(address asset);\n    error DecimalsMismatch(address feed, uint8 feedDecimals, uint8 expectedDecimals);\n\n    /**\n     * @dev Constructor that sets the base currency and base currency unit\n     * @param baseCurrency The address of the base currency (zero address for USD)\n     * @param _baseCurrencyUnit The decimal precision of the base currency (e.g., 1e8 for USD)\n     */\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) {\n        _baseCurrency = baseCurrency;\n        BASE_CURRENCY_UNIT = _baseCurrencyUnit;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Returns the base currency address\n     * @return Returns the base currency address\n     */\n    function BASE_CURRENCY() external view override returns (address) {\n        return _baseCurrency;\n    }\n\n    /**\n     * @notice Gets the price information for an asset\n     * @param asset The address of the asset to get the price for\n     * @return price The price of the asset in base currency units\n     * @return isAlive Whether the price feed is considered active/valid\n     */\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive);\n\n    /**\n     * @notice Gets the current price of an asset\n     * @param asset The address of the asset to get the price for\n     * @return The current price of the asset\n     */\n    function getAssetPrice(address asset) external view virtual override returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceIsStale();\n        }\n        return price;\n    }\n\n    /**\n     * @dev Converts a price from Liquity V2 decimals to base currency decimals\n     * @param price The price in Liquity V2 decimals\n     * @return The price in base currency decimals\n     */\n    function _convertToBaseCurrencyUnit(uint256 price) internal view returns (uint256) {\n        return (price * BASE_CURRENCY_UNIT) / LIQUITY_V2_BASE_CURRENCY_UNIT;\n    }\n\n    /**\n     * @notice Sets the heartbeat stale time limit\n     * @param _newHeartbeatStaleTimeLimit The new heartbeat stale time limit\n     */\n    function setHeartbeatStaleTimeLimit(uint256 _newHeartbeatStaleTimeLimit) external onlyRole(ORACLE_MANAGER_ROLE) {\n        heartbeatStaleTimeLimit = _newHeartbeatStaleTimeLimit;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/interface/liquidityV2/ILiquityV2OracleAggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.19;\n\ninterface LiquityV2OracleAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle_aggregator/OracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interface/IOracleWrapper.sol\";\n\n/**\n * @title OracleAggregator\n * @notice Aggregates price data from multiple oracles\n * @dev Implements IPriceOracleGetter for compatibility with Aave\n */\ncontract OracleAggregator is AccessControl, IOracleWrapper {\n    /* Core state */\n\n    /// @notice Mapping from asset address to oracle address\n    mapping(address => address) public assetOracles;\n\n    /// @notice 1 Unit of base currency (10^priceDecimals)\n    uint256 public immutable baseCurrencyUnit;\n\n    /// @notice Address representing the base currency\n    address public immutable baseCurrency;\n\n    /* Events */\n\n    event OracleUpdated(address indexed asset, address indexed oracle);\n\n    /* Roles */\n\n    /// @notice Role for managing oracles\n    bytes32 public constant ORACLE_MANAGER_ROLE = keccak256(\"ORACLE_MANAGER_ROLE\");\n\n    /* Errors */\n    error UnexpectedBaseUnit(address asset, address oracle, uint256 expectedBaseUnit, uint256 oracleBaseUnit);\n    error OracleNotSet(address asset);\n    error PriceNotAlive(address asset);\n\n    /**\n     * @notice Constructor to initialize the OracleAggregator\n     * @param _baseCurrency Address of the base currency\n     * @param _baseCurrencyUnit Number of decimal places for price values\n     */\n    constructor(address _baseCurrency, uint256 _baseCurrencyUnit) {\n        baseCurrency = _baseCurrency;\n        baseCurrencyUnit = _baseCurrencyUnit;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Sets the oracle for a specific asset\n     * @param asset Address of the asset\n     * @param oracle Address of the oracle for the asset\n     */\n    function setOracle(address asset, address oracle) external onlyRole(ORACLE_MANAGER_ROLE) {\n        uint256 oracleBaseUnit = IOracleWrapper(oracle).BASE_CURRENCY_UNIT();\n        if (oracleBaseUnit != baseCurrencyUnit) {\n            revert UnexpectedBaseUnit(asset, oracle, baseCurrencyUnit, oracleBaseUnit);\n        }\n        assetOracles[asset] = oracle;\n        emit OracleUpdated(asset, oracle);\n    }\n\n    /**\n     * @notice Removes the oracle for a specific asset\n     * @param asset Address of the asset\n     */\n    function removeOracle(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetOracles[asset] = address(0);\n        emit OracleUpdated(asset, address(0));\n    }\n\n    /**\n     * @notice Returns the base currency\n     * @return Address representing the base currency\n     */\n    function BASE_CURRENCY() external view returns (address) {\n        return baseCurrency;\n    }\n\n    /**\n     * @notice Returns the base currency unit\n     * @return Base currency unit (10^priceDecimals)\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256) {\n        return baseCurrencyUnit;\n    }\n\n    /**\n     * @notice Gets the price of an asset\n     * @param asset Address of the asset\n     * @return Price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceNotAlive(asset);\n        }\n        return price;\n    }\n\n    /**\n     * @notice Gets the price info of an asset\n     * @param asset Address of the asset\n     * @return price Price of the asset\n     * @return isAlive Whether the price is considered valid\n     */\n    function getPriceInfo(address asset) public view returns (uint256 price, bool isAlive) {\n        address oracle = assetOracles[asset];\n        if (oracle == address(0)) {\n            revert OracleNotSet(asset);\n        }\n        return IOracleWrapper(oracle).getPriceInfo(asset);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/API3CompositeWrapperWithThresholding.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/api3/BaseAPI3Wrapper.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { IProxy } from \"../interface/api3/IProxy.sol\";\nimport \"./ThresholdingUtils.sol\";\n\n/**\n * @title API3CompositeWrapperWithThresholding\n * @dev Implementation of IAPI3Wrapper for composite API3 oracles with thresholding\n */\ncontract API3CompositeWrapperWithThresholding is BaseAPI3Wrapper, ThresholdingUtils {\n    /* Core state */\n\n    struct CompositeFeed {\n        address proxy1;\n        address proxy2;\n        ThresholdConfig primaryThreshold; // Primary price source threshold config\n        ThresholdConfig secondaryThreshold; // Secondary price source threshold config\n    }\n\n    mapping(address => CompositeFeed) public compositeFeeds;\n\n    /* Events */\n\n    event CompositeFeedAdded(\n        address indexed asset,\n        address proxy1,\n        address proxy2,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    );\n    event CompositeFeedRemoved(address indexed asset);\n    event CompositeFeedUpdated(\n        address indexed asset,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    );\n\n    /* Errors */\n\n    error FeedNotSet(address asset);\n\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) BaseAPI3Wrapper(baseCurrency, _baseCurrencyUnit) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    function addCompositeFeed(\n        address asset,\n        address proxy1,\n        address proxy2,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        compositeFeeds[asset] = CompositeFeed({\n            proxy1: proxy1,\n            proxy2: proxy2,\n            primaryThreshold: ThresholdConfig({\n                lowerThresholdInBase: lowerThresholdInBase1,\n                fixedPriceInBase: fixedPriceInBase1\n            }),\n            secondaryThreshold: ThresholdConfig({\n                lowerThresholdInBase: lowerThresholdInBase2,\n                fixedPriceInBase: fixedPriceInBase2\n            })\n        });\n        emit CompositeFeedAdded(\n            asset,\n            proxy1,\n            proxy2,\n            lowerThresholdInBase1,\n            fixedPriceInBase1,\n            lowerThresholdInBase2,\n            fixedPriceInBase2\n        );\n    }\n\n    function removeCompositeFeed(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        delete compositeFeeds[asset];\n        emit CompositeFeedRemoved(asset);\n    }\n\n    function updateCompositeFeed(\n        address asset,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        CompositeFeed storage feed = compositeFeeds[asset];\n        if (feed.proxy1 == address(0) || feed.proxy2 == address(0)) {\n            revert FeedNotSet(asset);\n        }\n        feed.primaryThreshold.lowerThresholdInBase = lowerThresholdInBase1;\n        feed.primaryThreshold.fixedPriceInBase = fixedPriceInBase1;\n        feed.secondaryThreshold.lowerThresholdInBase = lowerThresholdInBase2;\n        feed.secondaryThreshold.fixedPriceInBase = fixedPriceInBase2;\n        emit CompositeFeedUpdated(\n            asset,\n            lowerThresholdInBase1,\n            fixedPriceInBase1,\n            lowerThresholdInBase2,\n            fixedPriceInBase2\n        );\n    }\n\n    function getPriceInfo(address asset) public view override returns (uint256 price, bool isAlive) {\n        CompositeFeed memory feed = compositeFeeds[asset];\n        if (feed.proxy1 == address(0) || feed.proxy2 == address(0)) {\n            revert FeedNotSet(asset);\n        }\n\n        (int224 value1, uint32 timestamp1) = IProxy(feed.proxy1).read();\n        (int224 value2, uint32 timestamp2) = IProxy(feed.proxy2).read();\n\n        uint256 api3Price1 = value1 > 0 ? uint256(uint224(value1)) : 0;\n        uint256 api3Price2 = value2 > 0 ? uint256(uint224(value2)) : 0;\n\n        // Convert both prices to BASE_CURRENCY_UNIT first\n        uint256 priceInBase1 = _convertToBaseCurrencyUnit(api3Price1);\n        uint256 priceInBase2 = _convertToBaseCurrencyUnit(api3Price2);\n\n        // Apply thresholding to prices in BASE_CURRENCY_UNIT if specified\n        if (feed.primaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase1 = _applyThreshold(priceInBase1, feed.primaryThreshold);\n        }\n        if (feed.secondaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase2 = _applyThreshold(priceInBase2, feed.secondaryThreshold);\n        }\n\n        price = (priceInBase1 * priceInBase2) / BASE_CURRENCY_UNIT;\n        isAlive =\n            price > 0 &&\n            timestamp1 + API3_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp &&\n            timestamp2 + API3_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp;\n    }\n\n    function getAssetPrice(address asset) external view override returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceIsStale();\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/API3Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IProxy } from \"../interface/api3/IProxy.sol\";\nimport \"../interface/api3/BaseAPI3Wrapper.sol\";\n\n/**\n * @title API3Wrapper\n * @dev Implementation of IAPI3Wrapper for standard API3 oracles\n */\ncontract API3Wrapper is BaseAPI3Wrapper {\n    mapping(address => IProxy) public assetToProxy;\n\n    error ProxyNotSet(address asset);\n\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) BaseAPI3Wrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive) {\n        IProxy api3Proxy = assetToProxy[asset];\n        if (address(api3Proxy) == address(0)) {\n            revert ProxyNotSet(asset);\n        }\n\n        (int224 value, uint32 timestamp) = api3Proxy.read();\n        price = value > 0 ? uint256(uint224(value)) : 0;\n\n        isAlive = price > 0 && timestamp + API3_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp;\n\n        price = _convertToBaseCurrencyUnit(price);\n    }\n\n    function setProxy(address asset, address proxy) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetToProxy[asset] = IProxy(proxy);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/API3WrapperWithThresholding.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./API3Wrapper.sol\";\nimport \"./ThresholdingUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract API3WrapperWithThresholding is API3Wrapper, ThresholdingUtils {\n    /* State */\n    mapping(address => ThresholdConfig) public assetThresholds;\n\n    /* Events */\n    event ThresholdConfigSet(address indexed asset, uint256 lowerThresholdInBase, uint256 fixedPriceInBase);\n    event ThresholdConfigRemoved(address indexed asset);\n\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) API3Wrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view override returns (uint256 price, bool isAlive) {\n        (price, isAlive) = super.getPriceInfo(asset);\n        if (isAlive) {\n            ThresholdConfig memory config = assetThresholds[asset];\n            if (config.lowerThresholdInBase > 0) {\n                price = _applyThreshold(price, config);\n            }\n        }\n    }\n\n    function setThresholdConfig(\n        address asset,\n        uint256 lowerThresholdInBase,\n        uint256 fixedPriceInBase\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetThresholds[asset] = ThresholdConfig({\n            lowerThresholdInBase: lowerThresholdInBase,\n            fixedPriceInBase: fixedPriceInBase\n        });\n        emit ThresholdConfigSet(asset, lowerThresholdInBase, fixedPriceInBase);\n    }\n\n    function removeThresholdConfig(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        delete assetThresholds[asset];\n        emit ThresholdConfigRemoved(asset);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/HardPegOracleWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/IOracleWrapper.sol\";\n\ncontract HardPegOracleWrapper is IOracleWrapper {\n    uint256 public immutable pricePeg;\n    address public immutable BASE_CURRENCY;\n\n    uint256 public BASE_CURRENCY_UNIT;\n\n    constructor(address _baseCurrency, uint256 _baseCurrencyUnit, uint256 _pricePeg) {\n        BASE_CURRENCY = _baseCurrency;\n        BASE_CURRENCY_UNIT = _baseCurrencyUnit;\n        pricePeg = _pricePeg;\n    }\n\n    /**\n     * @dev Get the price info of an asset\n     */\n    function getPriceInfo(\n        address // asset\n    ) external view returns (uint256 price, bool isAlive) {\n        return (pricePeg, true);\n    }\n\n    /**\n     * @dev Get the price of an asset\n     */\n    function getAssetPrice(\n        address // asset\n    ) external view override returns (uint256) {\n        return pricePeg;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/RedstoneChainlinkCompositeWrapperWithThresholding.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/chainlink/BaseChainlinkWrapper.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { IPriceFeed } from \"../interface/chainlink/IPriceFeed.sol\";\nimport \"./ThresholdingUtils.sol\";\n\n/**\n * @title RedstoneChainlinkCompositeWrapperWithThresholding\n * @dev Implementation of BaseChainlinkWrapper for composite Redstone oracles with thresholding\n */\ncontract RedstoneChainlinkCompositeWrapperWithThresholding is BaseChainlinkWrapper, ThresholdingUtils {\n    /* Core state */\n\n    struct CompositeFeed {\n        address feed1;\n        address feed2;\n        ThresholdConfig primaryThreshold; // Primary price source threshold config\n        ThresholdConfig secondaryThreshold; // Secondary price source threshold config\n    }\n\n    mapping(address => CompositeFeed) public compositeFeeds;\n\n    /* Events */\n\n    event CompositeFeedAdded(\n        address indexed asset,\n        address feed1,\n        address feed2,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    );\n    event CompositeFeedRemoved(address indexed asset);\n    event CompositeFeedUpdated(\n        address indexed asset,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    );\n\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) BaseChainlinkWrapper(baseCurrency, _baseCurrencyUnit) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ORACLE_MANAGER_ROLE, msg.sender);\n    }\n\n    function addCompositeFeed(\n        address asset,\n        address feed1,\n        address feed2,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        compositeFeeds[asset] = CompositeFeed({\n            feed1: feed1,\n            feed2: feed2,\n            primaryThreshold: ThresholdConfig({\n                lowerThresholdInBase: lowerThresholdInBase1,\n                fixedPriceInBase: fixedPriceInBase1\n            }),\n            secondaryThreshold: ThresholdConfig({\n                lowerThresholdInBase: lowerThresholdInBase2,\n                fixedPriceInBase: fixedPriceInBase2\n            })\n        });\n        emit CompositeFeedAdded(\n            asset,\n            feed1,\n            feed2,\n            lowerThresholdInBase1,\n            fixedPriceInBase1,\n            lowerThresholdInBase2,\n            fixedPriceInBase2\n        );\n    }\n\n    function removeCompositeFeed(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        delete compositeFeeds[asset];\n        emit CompositeFeedRemoved(asset);\n    }\n\n    function updateCompositeFeed(\n        address asset,\n        uint256 lowerThresholdInBase1,\n        uint256 fixedPriceInBase1,\n        uint256 lowerThresholdInBase2,\n        uint256 fixedPriceInBase2\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        CompositeFeed storage feed = compositeFeeds[asset];\n        if (feed.feed1 == address(0) || feed.feed2 == address(0)) {\n            revert FeedNotSet(asset);\n        }\n        feed.primaryThreshold.lowerThresholdInBase = lowerThresholdInBase1;\n        feed.primaryThreshold.fixedPriceInBase = fixedPriceInBase1;\n        feed.secondaryThreshold.lowerThresholdInBase = lowerThresholdInBase2;\n        feed.secondaryThreshold.fixedPriceInBase = fixedPriceInBase2;\n        emit CompositeFeedUpdated(\n            asset,\n            lowerThresholdInBase1,\n            fixedPriceInBase1,\n            lowerThresholdInBase2,\n            fixedPriceInBase2\n        );\n    }\n\n    function getPriceInfo(address asset) public view override returns (uint256 price, bool isAlive) {\n        CompositeFeed memory feed = compositeFeeds[asset];\n        if (feed.feed1 == address(0) || feed.feed2 == address(0)) {\n            revert FeedNotSet(asset);\n        }\n\n        (, int256 answer1, , uint256 updatedAt1, ) = IPriceFeed(feed.feed1).latestRoundData();\n\n        (, int256 answer2, , uint256 updatedAt2, ) = IPriceFeed(feed.feed2).latestRoundData();\n\n        uint256 chainlinkPrice1 = answer1 > 0 ? uint256(answer1) : 0;\n        uint256 chainlinkPrice2 = answer2 > 0 ? uint256(answer2) : 0;\n\n        // Convert both prices to BASE_CURRENCY_UNIT first\n        uint256 priceInBase1 = _convertToBaseCurrencyUnit(chainlinkPrice1);\n        uint256 priceInBase2 = _convertToBaseCurrencyUnit(chainlinkPrice2);\n\n        // Apply thresholding to prices in BASE_CURRENCY_UNIT if specified\n        if (feed.primaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase1 = _applyThreshold(priceInBase1, feed.primaryThreshold);\n        }\n        if (feed.secondaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase2 = _applyThreshold(priceInBase2, feed.secondaryThreshold);\n        }\n\n        price = (priceInBase1 * priceInBase2) / BASE_CURRENCY_UNIT;\n        isAlive =\n            price > 0 &&\n            updatedAt1 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp &&\n            updatedAt2 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp;\n    }\n\n    function getAssetPrice(address asset) external view override returns (uint256) {\n        (uint256 price, bool isAlive) = getPriceInfo(asset);\n        if (!isAlive) {\n            revert PriceIsStale();\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/RedstoneChainlinkWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/chainlink/BaseChainlinkWrapper.sol\";\nimport \"../interface/chainlink/IPriceFeed.sol\";\n\n/**\n * @title RedstoneChainlinkWrapper\n * @dev Implementation of BaseChainlinkWrapper for Redstone oracle feeds that follow Chainlink AggregatorV3Interface\n */\ncontract RedstoneChainlinkWrapper is BaseChainlinkWrapper {\n    mapping(address => IPriceFeed) public assetToFeed;\n\n    constructor(\n        address baseCurrency,\n        uint256 _baseCurrencyUnit\n    ) BaseChainlinkWrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive) {\n        IPriceFeed feed = assetToFeed[asset];\n        if (address(feed) == address(0)) {\n            revert FeedNotSet(asset);\n        }\n\n        (, int256 answer, , uint256 updatedAt, ) = feed.latestRoundData();\n\n        // Validate the oracle data\n        if (answer <= 0) {\n            revert InvalidPrice();\n        }\n\n        price = uint256(answer);\n        isAlive = updatedAt + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp;\n\n        price = _convertToBaseCurrencyUnit(price);\n    }\n\n    /**\n     * @notice Sets the price feed for an asset\n     * @param asset The address of the asset\n     * @param feed The address of the Redstone Chainlink-compatible price feed\n     */\n    function setFeed(address asset, address feed) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetToFeed[asset] = IPriceFeed(feed);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/RedstoneChainlinkWrapperWithThresholding.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./RedstoneChainlinkWrapper.sol\";\nimport \"./ThresholdingUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RedstoneChainlinkWrapperWithThresholding is RedstoneChainlinkWrapper, ThresholdingUtils {\n    /* State */\n    mapping(address => ThresholdConfig) public assetThresholds;\n\n    /* Events */\n    event ThresholdConfigSet(address indexed asset, uint256 lowerThresholdInBase, uint256 fixedPriceInBase);\n    event ThresholdConfigRemoved(address indexed asset);\n\n    constructor(\n        address baseCurrency,\n        uint256 _baseCurrencyUnit\n    ) RedstoneChainlinkWrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view override returns (uint256 price, bool isAlive) {\n        (price, isAlive) = super.getPriceInfo(asset);\n        if (isAlive) {\n            ThresholdConfig memory config = assetThresholds[asset];\n            if (config.lowerThresholdInBase > 0) {\n                price = _applyThreshold(price, config);\n            }\n        }\n    }\n\n    function setThresholdConfig(\n        address asset,\n        uint256 lowerThresholdInBase,\n        uint256 fixedPriceInBase\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetThresholds[asset] = ThresholdConfig({\n            lowerThresholdInBase: lowerThresholdInBase,\n            fixedPriceInBase: fixedPriceInBase\n        });\n        emit ThresholdConfigSet(asset, lowerThresholdInBase, fixedPriceInBase);\n    }\n\n    function removeThresholdConfig(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        delete assetThresholds[asset];\n        emit ThresholdConfigRemoved(asset);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/TellorWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/liquidityV2/BaseLiquidityV2Wrapper.sol\";\nimport \"../interface/liquidityV2/ILiquityV2OracleAggregatorV3Interface.sol\";\n\n/**\n * @title TellorWrapper\n * @dev Implementation of BaseLiquityV2Wrapper for Tellor oracle feeds\n * Compatible with LiquityV2OracleAggregatorV3Interface (Tellor feeds that follow this interface)\n */\ncontract TellorWrapper is BaseLiquityV2Wrapper {\n    mapping(address => LiquityV2OracleAggregatorV3Interface) public assetToFeed;\n\n    constructor(\n        address baseCurrency,\n        uint256 _baseCurrencyUnit\n    ) BaseLiquityV2Wrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view virtual override returns (uint256 price, bool isAlive) {\n        LiquityV2OracleAggregatorV3Interface feed = assetToFeed[asset];\n        if (address(feed) == address(0)) {\n            revert FeedNotSet(asset);\n        }\n\n        (, int256 answer, , uint256 updatedAt, ) = feed.latestRoundData();\n\n        // Validate the oracle data\n        if (answer <= 0) {\n            revert InvalidPrice();\n        }\n\n        price = uint256(answer);\n        isAlive = updatedAt + LIQUITY_V2_HEARTBEAT + heartbeatStaleTimeLimit > block.timestamp;\n\n        price = _convertToBaseCurrencyUnit(price);\n    }\n\n    /**\n     * @notice Sets the Tellor oracle feed for an asset\n     * @dev Validates that the feed decimals match the base currency decimals\n     * @param asset The address of the asset\n     * @param feed The address of the Tellor oracle feed\n     */\n    function setFeed(address asset, address feed) external onlyRole(ORACLE_MANAGER_ROLE) {\n        LiquityV2OracleAggregatorV3Interface feedInterface = LiquityV2OracleAggregatorV3Interface(feed);\n\n        // Validate that feed decimals match expected decimals\n        uint8 feedDecimals = feedInterface.decimals();\n        if (feedDecimals != BASE_CURRENCY_DECIMALS) {\n            revert DecimalsMismatch(feed, feedDecimals, BASE_CURRENCY_DECIMALS);\n        }\n\n        assetToFeed[asset] = feedInterface;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/TellorWrapperWithThresholding.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./TellorWrapper.sol\";\nimport \"./ThresholdingUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TellorWrapperWithThresholding is TellorWrapper, ThresholdingUtils {\n    /* State */\n    mapping(address => ThresholdConfig) public assetThresholds;\n\n    /* Events */\n    event ThresholdConfigSet(address indexed asset, uint256 lowerThresholdInBase, uint256 fixedPriceInBase);\n    event ThresholdConfigRemoved(address indexed asset);\n\n    constructor(address baseCurrency, uint256 _baseCurrencyUnit) TellorWrapper(baseCurrency, _baseCurrencyUnit) {}\n\n    function getPriceInfo(address asset) public view override returns (uint256 price, bool isAlive) {\n        (price, isAlive) = super.getPriceInfo(asset);\n        if (isAlive) {\n            ThresholdConfig memory config = assetThresholds[asset];\n            if (config.lowerThresholdInBase > 0) {\n                price = _applyThreshold(price, config);\n            }\n        }\n    }\n\n    function setThresholdConfig(\n        address asset,\n        uint256 lowerThresholdInBase,\n        uint256 fixedPriceInBase\n    ) external onlyRole(ORACLE_MANAGER_ROLE) {\n        assetThresholds[asset] = ThresholdConfig({\n            lowerThresholdInBase: lowerThresholdInBase,\n            fixedPriceInBase: fixedPriceInBase\n        });\n        emit ThresholdConfigSet(asset, lowerThresholdInBase, fixedPriceInBase);\n    }\n\n    function removeThresholdConfig(address asset) external onlyRole(ORACLE_MANAGER_ROLE) {\n        delete assetThresholds[asset];\n        emit ThresholdConfigRemoved(asset);\n    }\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/ThresholdingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nabstract contract ThresholdingUtils {\n    /* Types */\n    struct ThresholdConfig {\n        /// @notice The minimum price after which thresholding is applied. Not a price cap, but a trigger point.\n        /// @dev If lowerThresholdInBase == fixedPriceInBase: Acts as an upper threshold\n        /// @dev If lowerThresholdInBase < fixedPriceInBase: Acts as \"price rounding up\" (e.g. if USDC > 0.997 then round to 1)\n        /// @dev If lowerThresholdInBase > fixedPriceInBase: Acts as \"price rounding down\" (e.g. if USDC > 1.003 then round to 1)\n        uint256 lowerThresholdInBase;\n        uint256 fixedPriceInBase;\n    }\n\n    /**\n     * @notice Apply threshold to a price value\n     * @param priceInBase The price to check against threshold\n     * @param thresholdConfig The threshold configuration\n     * @return The original price or fixed price based on threshold\n     */\n    function _applyThreshold(\n        uint256 priceInBase,\n        ThresholdConfig memory thresholdConfig\n    ) internal pure returns (uint256) {\n        if (priceInBase > thresholdConfig.lowerThresholdInBase) {\n            return thresholdConfig.fixedPriceInBase;\n        }\n        return priceInBase;\n    }\n}\n"
    },
    "contracts/testing/dex/SimpleDEXMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"contracts/common/BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title SimpleDEXMock\n * @notice A mock decentralized exchange contract for testing purposes\n * @dev This contract mimics DEX behavior with configurable exchange rates and execution slippage\n */\ncontract SimpleDEXMock {\n    using SafeERC20 for IERC20;\n\n    // State variables\n    mapping(address => mapping(address => uint256)) public exchangeRates; // inputToken => outputToken => rate (in 18 decimals)\n    uint256 public executionSlippageBps; // Execution slippage in basis points\n\n    // Events\n    event ExchangeRateSet(address indexed inputToken, address indexed outputToken, uint256 rate);\n    event ExecutionSlippageSet(uint256 slippageBps);\n    event SwapExecuted(\n        address indexed inputToken,\n        address indexed outputToken,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed receiver,\n        string swapType\n    );\n\n    // Errors\n    error ZeroAddress();\n    error ZeroAmount();\n    error ExchangeRateNotSet();\n    error InsufficientOutputAmount(uint256 actual, uint256 minimum);\n    error ExcessiveInputAmount(uint256 actual, uint256 maximum);\n    error InsufficientBalance(address token, uint256 requested, uint256 available);\n    error InsufficientAllowance(address token, uint256 requested, uint256 available);\n    error TransferFailed();\n\n    /**\n     * @notice Constructor\n     */\n    constructor() {\n        executionSlippageBps = 0; // Default no execution slippage\n    }\n\n    /**\n     * @notice Set exchange rate for a token pair\n     * @param inputToken The input token address\n     * @param outputToken The output token address\n     * @param rate The exchange rate (how much outputToken per 1 inputToken, in 18 decimals)\n     */\n    function setExchangeRate(address inputToken, address outputToken, uint256 rate) external {\n        if (inputToken == address(0) || outputToken == address(0)) {\n            revert ZeroAddress();\n        }\n        if (rate == 0) {\n            revert ZeroAmount();\n        }\n\n        exchangeRates[inputToken][outputToken] = rate;\n        emit ExchangeRateSet(inputToken, outputToken, rate);\n    }\n\n    /**\n     * @notice Set execution slippage in basis points\n     * @param slippageBps The execution slippage (e.g., 20000 = 2%)\n     */\n    function setExecutionSlippage(uint256 slippageBps) external {\n        if (slippageBps >= BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert(\"Execution slippage cannot be 100% or more\");\n        }\n        executionSlippageBps = slippageBps;\n        emit ExecutionSlippageSet(slippageBps);\n    }\n\n    /**\n     * @notice Execute swap with exact input amount\n     * @param inputToken The input token to swap from\n     * @param outputToken The output token to swap to\n     * @param amountIn The exact amount of input tokens to swap\n     * @param amountOutMinimum The minimum amount of output tokens expected\n     * @param receiver The address to receive the output tokens\n     * @return amountOut The actual amount of output tokens transferred\n     */\n    function executeSwapExactInput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address receiver\n    ) external returns (uint256 amountOut) {\n        if (address(inputToken) == address(0) || address(outputToken) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amountIn == 0) {\n            revert ZeroAmount();\n        }\n\n        // Check exchange rate exists\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            revert ExchangeRateNotSet();\n        }\n\n        // Check allowance\n        uint256 allowance = inputToken.allowance(msg.sender, address(this));\n        if (allowance < amountIn) {\n            revert InsufficientAllowance(address(inputToken), amountIn, allowance);\n        }\n\n        // Calculate output amount before slippage\n        uint256 outputBeforeSlippage = _calculateOutputAmount(\n            amountIn,\n            rate,\n            inputToken.decimals(),\n            outputToken.decimals()\n        );\n\n        // Apply execution slippage\n        amountOut = _applyExecutionSlippage(outputBeforeSlippage);\n\n        // Check minimum output\n        if (amountOut < amountOutMinimum) {\n            revert InsufficientOutputAmount(amountOut, amountOutMinimum);\n        }\n\n        // Check contract has enough output tokens\n        uint256 contractBalance = outputToken.balanceOf(address(this));\n        if (contractBalance < amountOut) {\n            revert InsufficientBalance(address(outputToken), amountOut, contractBalance);\n        }\n\n        // Execute the swap\n        IERC20(inputToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(outputToken).safeTransfer(receiver, amountOut);\n\n        emit SwapExecuted(address(inputToken), address(outputToken), amountIn, amountOut, receiver, \"ExactInput\");\n\n        return amountOut;\n    }\n\n    /**\n     * @notice Execute swap with exact output amount\n     * @param inputToken The input token to swap from\n     * @param outputToken The output token to swap to\n     * @param amountOut The exact amount of output tokens to receive\n     * @param amountInMaximum The maximum amount of input tokens to spend\n     * @param receiver The address to receive the output tokens\n     * @return amountIn The actual amount of input tokens spent\n     */\n    function executeSwapExactOutput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver\n    ) external returns (uint256 amountIn) {\n        if (address(inputToken) == address(0) || address(outputToken) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amountOut == 0) {\n            revert ZeroAmount();\n        }\n\n        // Check exchange rate exists\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            revert ExchangeRateNotSet();\n        }\n\n        // Check contract has enough output tokens\n        uint256 contractBalance = outputToken.balanceOf(address(this));\n        if (contractBalance < amountOut) {\n            revert InsufficientBalance(address(outputToken), amountOut, contractBalance);\n        }\n\n        // Calculate required input amount considering execution slippage\n        // We need to calculate how much input is needed to get amountOut after slippage\n        uint256 amountOutBeforeSlippage = _reverseExecutionSlippage(amountOut);\n\n        amountIn = _calculateInputAmount(amountOutBeforeSlippage, rate, inputToken.decimals(), outputToken.decimals());\n\n        // Check maximum input\n        if (amountIn > amountInMaximum) {\n            revert ExcessiveInputAmount(amountIn, amountInMaximum);\n        }\n\n        // Check allowance\n        uint256 allowance = inputToken.allowance(msg.sender, address(this));\n        if (allowance < amountIn) {\n            revert InsufficientAllowance(address(inputToken), amountIn, allowance);\n        }\n\n        // Execute the swap\n        IERC20(inputToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(outputToken).safeTransfer(receiver, amountOut);\n\n        emit SwapExecuted(address(inputToken), address(outputToken), amountIn, amountOut, receiver, \"ExactOutput\");\n\n        return amountIn;\n    }\n\n    /**\n     * @notice Get the exchange rate for a token pair\n     * @param inputToken The input token address\n     * @param outputToken The output token address\n     * @return rate The exchange rate (18 decimals)\n     */\n    function getExchangeRate(address inputToken, address outputToken) external view returns (uint256 rate) {\n        return exchangeRates[inputToken][outputToken];\n    }\n\n    /**\n     * @notice Preview output amount for exact input swap\n     * @param inputToken The input token\n     * @param outputToken The output token\n     * @param amountIn The input amount\n     * @return amountOut The expected output amount (after execution slippage)\n     */\n    function previewSwapExactInput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountIn\n    ) external view returns (uint256 amountOut) {\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            return 0;\n        }\n\n        uint256 outputBeforeSlippage = _calculateOutputAmount(\n            amountIn,\n            rate,\n            inputToken.decimals(),\n            outputToken.decimals()\n        );\n\n        return _applyExecutionSlippage(outputBeforeSlippage);\n    }\n\n    /**\n     * @notice Preview input amount for exact output swap\n     * @param inputToken The input token\n     * @param outputToken The output token\n     * @param amountOut The output amount\n     * @return amountIn The expected input amount required\n     */\n    function previewSwapExactOutput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountOut\n    ) external view returns (uint256 amountIn) {\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            return 0;\n        }\n\n        uint256 amountOutBeforeSlippage = _reverseExecutionSlippage(amountOut);\n\n        return _calculateInputAmount(amountOutBeforeSlippage, rate, inputToken.decimals(), outputToken.decimals());\n    }\n\n    /**\n     * @notice Calculate output amount from input amount and rate\n     * @param amountIn The input amount\n     * @param rate The exchange rate (18 decimals)\n     * @param inputDecimals The input token decimals\n     * @param outputDecimals The output token decimals\n     * @return outputAmount The calculated output amount\n     */\n    function _calculateOutputAmount(\n        uint256 amountIn,\n        uint256 rate,\n        uint8 inputDecimals,\n        uint8 outputDecimals\n    ) internal pure returns (uint256 outputAmount) {\n        // Convert input to 18 decimals for calculation\n        uint256 normalizedInput = amountIn;\n        if (inputDecimals < 18) {\n            normalizedInput = amountIn * (10 ** (18 - inputDecimals));\n        } else if (inputDecimals > 18) {\n            normalizedInput = amountIn / (10 ** (inputDecimals - 18));\n        }\n\n        // Calculate output in 18 decimals: input * rate / 1e18\n        uint256 normalizedOutput = (normalizedInput * rate) / 1e18;\n\n        // Convert output to token decimals\n        if (outputDecimals < 18) {\n            outputAmount = normalizedOutput / (10 ** (18 - outputDecimals));\n        } else if (outputDecimals > 18) {\n            outputAmount = normalizedOutput * (10 ** (outputDecimals - 18));\n        } else {\n            outputAmount = normalizedOutput;\n        }\n\n        return outputAmount;\n    }\n\n    /**\n     * @notice Calculate input amount from output amount and rate\n     * @param amountOut The output amount\n     * @param rate The exchange rate (18 decimals)\n     * @param inputDecimals The input token decimals\n     * @param outputDecimals The output token decimals\n     * @return inputAmount The calculated input amount\n     */\n    function _calculateInputAmount(\n        uint256 amountOut,\n        uint256 rate,\n        uint8 inputDecimals,\n        uint8 outputDecimals\n    ) internal pure returns (uint256 inputAmount) {\n        // Convert output to 18 decimals for calculation\n        uint256 normalizedOutput = amountOut;\n        if (outputDecimals < 18) {\n            normalizedOutput = amountOut * (10 ** (18 - outputDecimals));\n        } else if (outputDecimals > 18) {\n            normalizedOutput = amountOut / (10 ** (outputDecimals - 18));\n        }\n\n        // Calculate input in 18 decimals: output * 1e18 / rate\n        uint256 normalizedInput = (normalizedOutput * 1e18) / rate;\n\n        // Convert input to token decimals\n        if (inputDecimals < 18) {\n            inputAmount = normalizedInput / (10 ** (18 - inputDecimals));\n        } else if (inputDecimals > 18) {\n            inputAmount = normalizedInput * (10 ** (inputDecimals - 18));\n        } else {\n            inputAmount = normalizedInput;\n        }\n\n        return inputAmount;\n    }\n\n    /**\n     * @notice Apply execution slippage to reduce output amount\n     * @param amount The original amount\n     * @return slippedAmount The amount after applying execution slippage\n     */\n    function _applyExecutionSlippage(uint256 amount) internal view returns (uint256 slippedAmount) {\n        if (executionSlippageBps == 0) {\n            return amount;\n        }\n\n        // Reduce by execution slippage: amount * (100% - slippage%) / 100%\n        slippedAmount = Math.mulDiv(\n            amount,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - executionSlippageBps,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n        );\n\n        return slippedAmount;\n    }\n\n    /**\n     * @notice Reverse execution slippage to calculate required amount before slippage\n     * @param targetAmount The target amount after slippage\n     * @return originalAmount The amount needed before slippage\n     */\n    function _reverseExecutionSlippage(uint256 targetAmount) internal view returns (uint256 originalAmount) {\n        if (executionSlippageBps == 0) {\n            return targetAmount;\n        }\n\n        // Calculate original amount: targetAmount * 100% / (100% - slippage%)\n        originalAmount = Math.mulDiv(\n            targetAmount,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - executionSlippageBps\n        );\n\n        return originalAmount;\n    }\n\n    /**\n     * @notice Emergency function to withdraw tokens (for testing purposes)\n     * @param token The token to withdraw\n     * @param amount The amount to withdraw\n     * @param to The recipient address\n     */\n    function emergencyWithdraw(IERC20 token, uint256 amount, address to) external {\n        if (to == address(0)) {\n            revert ZeroAddress();\n        }\n        token.safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/testing/dstake/MockUnderDeliveringAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDStableConversionAdapter } from \"contracts/vaults/dstake/interfaces/IDStableConversionAdapter.sol\";\nimport { IMintableERC20 } from \"contracts/common/IMintableERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title MockUnderDeliveringAdapter\n * @notice Test adapter that intentionally under-delivers vault asset shares compared to the preview result.\n *         Used only in Hardhat tests to verify router slippage protections.\n */\ncontract MockUnderDeliveringAdapter is IDStableConversionAdapter {\n    using SafeERC20 for IERC20;\n\n    address public immutable dStable;\n    address public immutable collateralVault;\n    IMintableERC20 public immutable vaultAssetToken;\n\n    uint256 public immutable factorBps; // e.g. 9000 => mints 90% of preview amount\n\n    error InvalidFactor();\n\n    constructor(address _dStable, address _collateralVault, IMintableERC20 _vaultAssetToken, uint256 _factorBps) {\n        if (_factorBps == 0 || _factorBps > 10_000) revert InvalidFactor();\n        dStable = _dStable;\n        collateralVault = _collateralVault;\n        vaultAssetToken = _vaultAssetToken;\n        factorBps = _factorBps;\n    }\n\n    // ---------------- IDStableConversionAdapter ----------------\n\n    function convertToVaultAsset(uint256 dStableAmount) external override returns (address, uint256) {\n        // Pull dStable from caller\n        IERC20(dStable).safeTransferFrom(msg.sender, address(this), dStableAmount);\n\n        uint256 shares = (dStableAmount * factorBps) / 10_000;\n\n        // Mint shares directly to collateral vault (simulating under-delivery)\n        vaultAssetToken.mint(collateralVault, shares);\n\n        return (address(vaultAssetToken), shares);\n    }\n\n    function convertFromVaultAsset(uint256 vaultAssetAmount) external pure override returns (uint256) {\n        // Not needed for this mock; revert to prevent unexpected use\n        revert(\"Not implemented\");\n    }\n\n    function previewConvertToVaultAsset(uint256 dStableAmount) external view override returns (address, uint256) {\n        // Preview assumes 1:1 conversion\n        return (address(vaultAssetToken), dStableAmount);\n    }\n\n    function previewConvertFromVaultAsset(uint256 vaultAssetAmount) external pure override returns (uint256) {\n        return vaultAssetAmount; // 1:1\n    }\n\n    function assetValueInDStable(\n        address /*vaultAsset*/,\n        uint256 vaultAssetAmount\n    ) external pure override returns (uint256) {\n        return vaultAssetAmount;\n    }\n\n    function vaultAsset() external view override returns (address) {\n        return address(vaultAssetToken);\n    }\n}\n"
    },
    "contracts/testing/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title MockERC20\n * @dev Simple ERC20 token for testing purposes.\n */\ncontract MockERC20 is ERC20 {\n    constructor(string memory name_, string memory symbol_, uint256 initialSupply) ERC20(name_, symbol_) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/testing/oracle/MockAPI3Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IProxy } from \"../../oracle_aggregator/interface/api3/IProxy.sol\";\n\ncontract MockAPI3Oracle is IProxy {\n    int224 private mockPrice;\n    uint32 private mockTimestamp;\n    address private immutable api3ServerV1Address;\n\n    constructor(address _api3ServerV1Address) {\n        api3ServerV1Address = _api3ServerV1Address;\n    }\n\n    function setMock(int224 _price, uint32 _timestamp) external {\n        mockPrice = _price;\n        mockTimestamp = _timestamp;\n    }\n\n    function read() external view override returns (int224 value, uint32 timestamp) {\n        return (mockPrice, mockTimestamp);\n    }\n\n    function api3ServerV1() external view override returns (address) {\n        return api3ServerV1Address;\n    }\n}\n"
    },
    "contracts/testing/oracle/MockAPI3OracleAlwaysAlive.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IProxy } from \"../../oracle_aggregator/interface/api3/IProxy.sol\";\n\ncontract MockAPI3OracleAlwaysAlive is IProxy {\n    int224 private mockPrice;\n    address private immutable api3ServerV1Address;\n\n    constructor(address _api3ServerV1Address) {\n        api3ServerV1Address = _api3ServerV1Address;\n    }\n\n    function setMock(int224 _price) external {\n        mockPrice = _price;\n    }\n\n    function read() external view override returns (int224 value, uint32 timestamp) {\n        return (mockPrice, uint32(block.timestamp));\n    }\n\n    function api3ServerV1() external view override returns (address) {\n        return api3ServerV1Address;\n    }\n}\n"
    },
    "contracts/testing/oracle/MockChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"../../oracle_aggregator/interface/chainlink/IAggregatorV3Interface.sol\";\n\ncontract MockChainlinkAggregatorV3 is AggregatorV3Interface {\n    int256 private mockPrice;\n    uint80 private mockRoundId;\n    uint8 private mockDecimals;\n    string private mockDescription;\n    uint256 private mockUpdatedAt;\n\n    constructor(uint8 _decimals, string memory _description) {\n        mockRoundId = 1;\n        mockDecimals = _decimals;\n        mockDescription = _description;\n        mockUpdatedAt = block.timestamp;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return mockDecimals;\n    }\n\n    function description() external view override returns (string memory) {\n        return mockDescription;\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function setMock(int256 _price) external {\n        mockPrice = _price;\n        mockRoundId++;\n        mockUpdatedAt = block.timestamp;\n    }\n\n    function setMockWithTimestamp(int256 _price, uint256 _timestamp) external {\n        mockPrice = _price;\n        mockRoundId++;\n        mockUpdatedAt = _timestamp;\n    }\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (_roundId, mockPrice, mockUpdatedAt, mockUpdatedAt, _roundId);\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (mockRoundId, mockPrice, mockUpdatedAt, mockUpdatedAt, mockRoundId);\n    }\n}\n"
    },
    "contracts/testing/oracle/MockOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IOracleWrapper } from \"../../oracle_aggregator/interface/IOracleWrapper.sol\";\n\ncontract MockOracleAggregator is IOracleWrapper {\n    address public immutable BASE_CURRENCY;\n    uint256 public immutable BASE_CURRENCY_UNIT;\n\n    mapping(address => uint256) public prices;\n    mapping(address => bool) public isAlive;\n\n    constructor(address _baseCurrency, uint256 _baseCurrencyUnit) {\n        BASE_CURRENCY = _baseCurrency;\n        BASE_CURRENCY_UNIT = _baseCurrencyUnit;\n    }\n\n    function setAssetPrice(address _asset, uint256 _price) external {\n        if (_asset == BASE_CURRENCY) {\n            revert(\"Cannot set price for base currency\");\n        }\n\n        prices[_asset] = _price;\n        isAlive[_asset] = true;\n    }\n\n    function setAssetAlive(address _asset, bool _isAlive) external {\n        isAlive[_asset] = _isAlive;\n    }\n\n    function getAssetPrice(address _asset) external view override returns (uint256) {\n        if (_asset == BASE_CURRENCY) {\n            return BASE_CURRENCY_UNIT;\n        }\n\n        uint256 _price = prices[_asset];\n        require(isAlive[_asset], \"Price feed is not alive\");\n\n        return _price;\n    }\n\n    function getPriceInfo(address _asset) external view override returns (uint256 price, bool _isAlive) {\n        if (_asset == BASE_CURRENCY) {\n            return (BASE_CURRENCY_UNIT, true);\n        }\n\n        price = prices[_asset];\n        _isAlive = isAlive[_asset];\n\n        return (price, _isAlive);\n    }\n}\n"
    },
    "contracts/testing/oracle/MockRedstoneChainlinkOracleAlwaysAlive.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport { IPriceFeed } from \"../../oracle_aggregator/interface/chainlink/IPriceFeed.sol\";\n\ncontract MockRedstoneChainlinkOracleAlwaysAlive is IPriceFeed {\n    int256 private mockPrice;\n    uint80 private mockRoundId;\n\n    constructor() {\n        mockRoundId = 1;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 8;\n    }\n\n    function setMock(int256 _price) external {\n        mockPrice = _price;\n        mockRoundId++;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (mockRoundId, mockPrice, block.timestamp, block.timestamp, mockRoundId);\n    }\n}\n"
    },
    "contracts/testing/token/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n        // Mint a total supply of 1e18 * 10^decimals_ to the deployer\n        _mint(msg.sender, 1e18 * 10 ** decimals_);\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/testing/token/TestERC20FlashMintable.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20FlashMint.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\n\ncontract TestERC20FlashMintable is ERC20, ERC20FlashMint, IMintableERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function mint(address to, uint256 amount) external override {\n        _mint(to, amount);\n    }\n\n    function burn(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external override {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    function decimals() public view virtual override(ERC20, IMintableERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/testing/token/TestMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\n\ncontract TestMintableERC20 is ERC20, IMintableERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function mint(address to, uint256 amount) external override {\n        _mint(to, amount);\n    }\n\n    function burn(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external override {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    function decimals() public view virtual override(ERC20, IMintableERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/testing/WithdrawalFeeHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"contracts/common/SupportsWithdrawalFee.sol\";\n\ncontract WithdrawalFeeHarness is SupportsWithdrawalFee {\n    constructor(uint256 initialFeeBps) {\n        _initializeWithdrawalFee(initialFeeBps);\n    }\n\n    function calc(uint256 amount) external view returns (uint256) {\n        return _calculateWithdrawalFee(amount);\n    }\n\n    // Set reasonable max fee default of 5% to prevent accidental high fees\n    function _maxWithdrawalFeeBps() internal pure override returns (uint256) {\n        return 5 * BasisPointConstants.ONE_PERCENT_BPS; // 5%\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.20;\n\nimport { ECDSA } from \"./ECDSA.sol\";\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /* //////////////////////////////////////////////////////////////\n                        EVENTS\n  ////////////////////////////////////////////////////////////// */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* //////////////////////////////////////////////////////////////\n                        METADATA STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    /* //////////////////////////////////////////////////////////////\n                        ERC20 STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /* //////////////////////////////////////////////////////////////\n                        EIP-2612 STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    mapping(address => uint256) public nonces;\n\n    /* //////////////////////////////////////////////////////////////\n                        CONSTRUCTOR\n  ////////////////////////////////////////////////////////////// */\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        ERC20 LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          EIP-2612 LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address signer = ECDSA.recover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(signer == owner, \"INVALID_SIGNER\");\n\n            allowance[signer][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            INTERNAL MINT/BURN LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport { IRewardsController } from \"../../../dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\ninterface IAToken {\n    function POOL() external view returns (address);\n\n    function getIncentivesController() external view returns (address);\n\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n    /**\n     * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n     * @return The scaled total supply\n     */\n    function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is \"managed\" by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the\n     * \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     *\n     * NOTE: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the\n     * \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     * While deposit of aToken is not affected by aave pool configrations, deposit of the aTokenUnderlying will need to deposit to aave\n     * so it is affected by current aave pool configuration.\n     * Reference: https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/ValidationLogic.sol#L57\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call to the aToken underlying.\n     * While redeem of aToken is not affected by aave pool configrations, redeeming of the aTokenUnderlying will need to redeem from aave\n     * so it is affected by current aave pool configuration.\n     * Reference: https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/ValidationLogic.sol#L87\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IStaticATokenFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport { IPool, DataTypes } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// ITransparentProxyFactory is missing, add to missing list\n// import {ITransparentProxyFactory} from \"contracts/dlend/core/interfaces/ITransparentProxyFactory.sol\";\n// Ownable is not used in the interface, can be omitted\n\ninterface IStaticATokenFactory {\n    /**\n     * @notice Creates new staticATokens\n     * @param underlyings the addresses of the underlyings to create.\n     * @return address[] addresses of the new staticATokens.\n     */\n    function createStaticATokens(address[] memory underlyings) external returns (address[] memory);\n\n    /**\n     * @notice Returns all tokens deployed via this registry.\n     * @return address[] list of tokens\n     */\n    function getStaticATokens() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the staticAToken for a given underlying.\n     * @param underlying the address of the underlying.\n     * @return address the staticAToken address.\n     */\n    function getStaticAToken(address underlying) external view returns (address);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IStaticATokenLM.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IRewardsController } from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\ninterface IStaticATokenLM {\n    struct SignatureParams {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct PermitParams {\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct UserRewardsData {\n        uint128 rewardsIndexOnLastInteraction; // (in RAYs)\n        uint128 unclaimedRewards; // (in RAYs)\n    }\n\n    struct RewardIndexCache {\n        bool isRegistered;\n        uint248 lastUpdatedIndex;\n    }\n\n    event RewardTokenRegistered(address indexed reward, uint256 startIndex);\n\n    /**\n     * @notice Allows to deposit on Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param depositor Address from which the funds to deposit are going to be pulled\n     * @param receiver Address that will receive the staticATokens, in the average case, same as the `depositor`\n     * @param assets The amount to deposit\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param depositToAave bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function metaDeposit(\n        address depositor,\n        address receiver,\n        uint256 assets,\n        uint16 referralCode,\n        bool depositToAave,\n        uint256 deadline,\n        PermitParams calldata permit,\n        SignatureParams calldata sigParams\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows to withdraw from Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner Address owning the staticATokens\n     * @param receiver Address that will receive the underlying withdrawn from Aave\n     * @param shares The amount of staticAToken to withdraw. If > 0, `assets` needs to be 0\n     * @param assets The amount of underlying/aToken to withdraw. If > 0, `shares` needs to be 0\n     * @param withdrawFromAave bool\n     * - `true` for the receiver to get underlying tokens (e.g. USDC)\n     * - `false` for the receiver to get aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `receiver`, dynamic balance\n     */\n    function metaWithdraw(\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 assets,\n        bool withdrawFromAave,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Returns the Aave liquidity index of the underlying aToken, denominated rate here\n     * as it can be considered as an ever-increasing exchange rate\n     * @return The liquidity index\n     **/\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n     * @param reward The reward to claim\n     * @return uint256 Amount collected\n     */\n    function collectAndUpdateRewards(address reward) external returns (uint256);\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n     * @param onBehalfOf The address to claim on behalf of\n     * @param receiver The address to receive the rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewardsOnBehalf(address onBehalfOf, address receiver, address[] memory rewards) external;\n\n    /**\n     * @notice Claim rewards and send them to a receiver\n     * @param receiver The address to receive the rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewards(address receiver, address[] memory rewards) external;\n\n    /**\n     * @notice Claim rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewardsToSelf(address[] memory rewards) external;\n\n    /**\n     * @notice Get the total claimable rewards of the contract.\n     * @param reward The reward to claim\n     * @return uint256 The current balance + pending rewards from the `_incentivesController`\n     */\n    function getTotalClaimableRewards(address reward) external view returns (uint256);\n\n    /**\n     * @notice Get the total claimable rewards for a user in WAD\n     * @param user The address of the user\n     * @param reward The reward to claim\n     * @return uint256 The claimable amount of rewards in WAD\n     */\n    function getClaimableRewards(address user, address reward) external view returns (uint256);\n\n    /**\n     * @notice The unclaimed rewards for a user in WAD\n     * @param user The address of the user\n     * @param reward The reward to claim\n     * @return uint256 The unclaimed amount of rewards in WAD\n     */\n    function getUnclaimedRewards(address user, address reward) external view returns (uint256);\n\n    /**\n     * @notice The underlying asset reward index in RAY\n     * @param reward The reward to claim\n     * @return uint256 The underlying asset reward index in RAY\n     */\n    function getCurrentRewardsIndex(address reward) external view returns (uint256);\n\n    /**\n     * @notice The aToken used inside the 4626 vault.\n     * @return IERC20 The aToken IERC20.\n     */\n    function aToken() external view returns (IERC20);\n\n    /**\n     * @notice The IERC20s that are currently rewarded to addresses of the vault via LM on incentivescontroller.\n     * @return IERC20 The IERC20s of the rewards.\n     */\n    function rewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice Fetches all rewardTokens from the incentivecontroller and registers the missing ones.\n     */\n    function refreshRewardTokens() external;\n\n    /**\n     * @notice Checks if the passed token is a registered reward.\n     * @return bool signaling if token is a registered reward.\n     */\n    function isRegisteredRewardToken(address reward) external view returns (bool);\n\n    /**\n     * @notice Deposits aTokens and mints static aTokens to the receiver\n     * @param aTokenAmount The amount of aTokens to deposit\n     * @param receiver The address that will receive the static aTokens\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function depositATokens(uint256 aTokenAmount, address receiver) external returns (uint256);\n\n    /**\n     * @notice Burns static aTokens and returns aTokens to the receiver\n     * @param shares The amount of static aTokens to burn\n     * @param receiver The address that will receive the aTokens\n     * @param owner The address whose static aTokens will be burned\n     * @return uint256 The amount of aTokens returned\n     */\n    function redeemATokens(uint256 shares, address receiver, address owner) external returns (uint256);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/RayMathExplicitRounding.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nenum Rounding {\n    UP,\n    DOWN\n}\n\n/**\n * Simplified version of RayMath that instead of half-up rounding does explicit rounding in a specified direction.\n * This is needed to have a 4626 complient implementation, that always predictable rounds in favor of the vault / static a token.\n */\nlibrary RayMathExplicitRounding {\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function rayMulRoundDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return Math.mulDiv(a, b, RAY); // default is rounding down\n    }\n\n    function rayMulRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return Math.mulDiv(a, b, RAY, Math.Rounding.Ceil);\n    }\n\n    function rayDivRoundDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return Math.mulDiv(a, RAY, b); // rounding down\n    }\n\n    function rayDivRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return Math.mulDiv(a, RAY, b, Math.Rounding.Ceil);\n    }\n\n    function rayToWadRoundDown(uint256 a) internal pure returns (uint256) {\n        return a / WAD_RAY_RATIO;\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenErrors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nlibrary StaticATokenErrors {\n    string public constant INVALID_OWNER = \"1\";\n    string public constant INVALID_EXPIRATION = \"2\";\n    string public constant INVALID_SIGNATURE = \"3\";\n    string public constant INVALID_DEPOSITOR = \"4\";\n    string public constant INVALID_RECIPIENT = \"5\";\n    string public constant INVALID_CLAIMER = \"6\";\n    string public constant ONLY_ONE_AMOUNT_FORMAT_ALLOWED = \"7\";\n    string public constant INVALID_ZERO_AMOUNT = \"8\";\n    string public constant REWARD_NOT_INITIALIZED = \"9\";\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IPool, DataTypes } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { StaticATokenLM } from \"./StaticATokenLM.sol\";\nimport { IStaticATokenFactory } from \"./interfaces/IStaticATokenFactory.sol\";\nimport { IRewardsController } from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\n/**\n * @title StaticATokenFactory\n * @notice Factory contract that keeps track of all deployed static aToken wrappers for a specified pool.\n * This registry also acts as a factory, allowing to deploy new static aTokens on demand.\n * There can only be one static aToken per underlying on the registry at a time.\n * @author BGD labs (modified by Colt)\n */\ncontract StaticATokenFactory is IStaticATokenFactory {\n    IPool public immutable POOL;\n\n    mapping(address => address) internal _underlyingToStaticAToken;\n    address[] internal _staticATokens;\n\n    event StaticTokenCreated(address indexed staticAToken, address indexed underlying);\n\n    constructor(IPool pool) {\n        POOL = pool;\n    }\n\n    function initialize() external pure {\n        revert(\"NO_INITIALIZER\");\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function createStaticATokens(address[] memory underlyings) external returns (address[] memory) {\n        address[] memory staticATokens = new address[](underlyings.length);\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address cachedStaticAToken = _underlyingToStaticAToken[underlyings[i]];\n            if (cachedStaticAToken == address(0)) {\n                DataTypes.ReserveData memory reserveData = POOL.getReserveData(underlyings[i]);\n                require(reserveData.aTokenAddress != address(0), \"UNDERLYING_NOT_LISTED\");\n                StaticATokenLM staticAToken = new StaticATokenLM(\n                    POOL,\n                    IRewardsController(address(0)), // TODO: pass correct incentives controller if needed\n                    reserveData.aTokenAddress,\n                    string(abi.encodePacked(\"Wrapped \", IERC20Metadata(reserveData.aTokenAddress).name())),\n                    string(abi.encodePacked(\"w\", IERC20Metadata(reserveData.aTokenAddress).symbol()))\n                );\n                address staticATokenAddr = address(staticAToken);\n                _underlyingToStaticAToken[underlyings[i]] = staticATokenAddr;\n                staticATokens[i] = staticATokenAddr;\n                _staticATokens.push(staticATokenAddr);\n                emit StaticTokenCreated(staticATokenAddr, underlyings[i]);\n            } else {\n                staticATokens[i] = cachedStaticAToken;\n            }\n        }\n        return staticATokens;\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function getStaticATokens() external view returns (address[] memory) {\n        return _staticATokens;\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function getStaticAToken(address underlying) external view returns (address) {\n        return _underlyingToStaticAToken[underlying];\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// --- DLend fork imports ---\nimport { IPool } from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport { DataTypes } from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\nimport { ReserveConfiguration } from \"contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { IScaledBalanceToken } from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport { IRewardsController } from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\nimport { WadRayMath } from \"contracts/dlend/core/protocol/libraries/math/WadRayMath.sol\";\nimport { MathUtils } from \"contracts/dlend/core/protocol/libraries/math/MathUtils.sol\";\nimport { SafeCast } from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport { Initializable } from \"contracts/dlend/core/dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20WithPermit } from \"contracts/dlend/core/interfaces/IERC20WithPermit.sol\";\n// --- Local imports ---\nimport { IStaticATokenLM } from \"./interfaces/IStaticATokenLM.sol\";\nimport { IAToken } from \"./interfaces/IAToken.sol\";\nimport { ERC20 } from \"./ERC20.sol\";\nimport { StaticATokenErrors } from \"./StaticATokenErrors.sol\";\nimport { RayMathExplicitRounding, Rounding } from \"./RayMathExplicitRounding.sol\";\nimport { IERC4626 } from \"./interfaces/IERC4626.sol\";\nimport { ECDSA } from \"./ECDSA.sol\";\n\n/**\n * @title StaticATokenLM\n * @notice Wrapper smart contract that allows to deposit tokens on the Aave protocol and receive\n * a token which balance doesn't increase automatically, but uses an ever-increasing exchange rate.\n * It supports claiming liquidity mining rewards from the Aave system.\n * @author BGD labs\n */\ncontract StaticATokenLM is ERC20, IStaticATokenLM, IERC4626 {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using WadRayMath for uint256;\n    using RayMathExplicitRounding for uint256;\n\n    bytes32 public constant METADEPOSIT_TYPEHASH =\n        keccak256(\n            \"Deposit(address depositor,address receiver,uint256 assets,uint16 referralCode,bool depositToAave,uint256 nonce,uint256 deadline,PermitParams permit)\"\n        );\n    bytes32 public constant METAWITHDRAWAL_TYPEHASH =\n        keccak256(\n            \"Withdraw(address owner,address receiver,uint256 shares,uint256 assets,bool withdrawFromAave,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 public constant STATIC__ATOKEN_LM_REVISION = 2;\n\n    IPool public immutable POOL;\n    IRewardsController public immutable REWARDS_CONTROLLER;\n\n    IERC20 internal _aToken;\n    address internal _aTokenUnderlying;\n    address[] internal _rewardTokens;\n    mapping(address => RewardIndexCache) internal _startIndex;\n    mapping(address => mapping(address => UserRewardsData)) internal _userRewardsData;\n\n    constructor(\n        IPool pool,\n        IRewardsController rewardsController,\n        address newAToken,\n        string memory staticATokenName,\n        string memory staticATokenSymbol\n    ) ERC20(staticATokenName, staticATokenSymbol, IERC20Metadata(newAToken).decimals()) {\n        POOL = pool;\n        REWARDS_CONTROLLER = rewardsController;\n        _aToken = IERC20(newAToken);\n        _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();\n        // Use standard approve for trusted protocol token (aToken underlying) and trusted protocol contract (dLEND POOL)\n        IERC20(_aTokenUnderlying).approve(address(POOL), type(uint256).max);\n        if (address(REWARDS_CONTROLLER) != address(0)) {\n            refreshRewardTokens();\n        }\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function refreshRewardTokens() public override {\n        address[] memory rewards = REWARDS_CONTROLLER.getRewardsByAsset(address(_aToken));\n        for (uint256 i = 0; i < rewards.length; i++) {\n            _registerRewardToken(rewards[i]);\n        }\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function isRegisteredRewardToken(address reward) public view override returns (bool) {\n        return _startIndex[reward].isRegistered;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function metaDeposit(\n        address depositor,\n        address receiver,\n        uint256 assets,\n        uint16 referralCode,\n        bool depositToAave,\n        uint256 deadline,\n        PermitParams calldata permit,\n        SignatureParams calldata sigParams\n    ) external returns (uint256) {\n        require(depositor != address(0), StaticATokenErrors.INVALID_DEPOSITOR);\n        //solium-disable-next-line\n        require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);\n        uint256 nonce = nonces[depositor];\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            METADEPOSIT_TYPEHASH,\n                            depositor,\n                            receiver,\n                            assets,\n                            referralCode,\n                            depositToAave,\n                            nonce,\n                            deadline,\n                            permit\n                        )\n                    )\n                )\n            );\n            nonces[depositor] = nonce + 1;\n            require(\n                depositor == ECDSA.recover(digest, sigParams.v, sigParams.r, sigParams.s),\n                StaticATokenErrors.INVALID_SIGNATURE\n            );\n        }\n        // assume if deadline 0 no permit was supplied\n        if (permit.deadline != 0) {\n            try\n                IERC20WithPermit(depositToAave ? address(_aTokenUnderlying) : address(_aToken)).permit(\n                    depositor,\n                    address(this),\n                    permit.value,\n                    permit.deadline,\n                    permit.v,\n                    permit.r,\n                    permit.s\n                )\n            {} catch {}\n        }\n        (uint256 shares, ) = _deposit(depositor, receiver, 0, assets, referralCode, depositToAave);\n        return shares;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function metaWithdraw(\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 assets,\n        bool withdrawFromAave,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256) {\n        require(owner != address(0), StaticATokenErrors.INVALID_OWNER);\n        //solium-disable-next-line\n        require(deadline >= block.timestamp, StaticATokenErrors.INVALID_EXPIRATION);\n        uint256 nonce = nonces[owner];\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            METAWITHDRAWAL_TYPEHASH,\n                            owner,\n                            receiver,\n                            shares,\n                            assets,\n                            withdrawFromAave,\n                            nonce,\n                            deadline\n                        )\n                    )\n                )\n            );\n            nonces[owner] = nonce + 1;\n            require(\n                owner == ECDSA.recover(digest, sigParams.v, sigParams.r, sigParams.s),\n                StaticATokenErrors.INVALID_SIGNATURE\n            );\n        }\n        return _withdraw(owner, receiver, shares, assets, withdrawFromAave);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Rounding.UP);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Rounding.UP);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function rate() public view returns (uint256) {\n        return POOL.getReserveNormalizedIncome(_aTokenUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function collectAndUpdateRewards(address reward) public returns (uint256) {\n        if (reward == address(0)) {\n            return 0;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(_aToken);\n\n        return REWARDS_CONTROLLER.claimRewards(assets, type(uint256).max, address(this), reward);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewardsOnBehalf(address onBehalfOf, address receiver, address[] memory rewards) external {\n        require(\n            msg.sender == onBehalfOf || msg.sender == REWARDS_CONTROLLER.getClaimer(onBehalfOf),\n            StaticATokenErrors.INVALID_CLAIMER\n        );\n        _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewards(address receiver, address[] memory rewards) external {\n        _claimRewardsOnBehalf(msg.sender, receiver, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewardsToSelf(address[] memory rewards) external {\n        _claimRewardsOnBehalf(msg.sender, msg.sender, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getCurrentRewardsIndex(address reward) public view returns (uint256) {\n        if (address(reward) == address(0)) {\n            return 0;\n        }\n        (, uint256 nextIndex) = REWARDS_CONTROLLER.getAssetIndex(address(_aToken), reward);\n        return nextIndex;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getTotalClaimableRewards(address reward) external view returns (uint256) {\n        if (reward == address(0)) {\n            return 0;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(_aToken);\n        uint256 freshRewards = REWARDS_CONTROLLER.getUserRewards(assets, address(this), reward);\n        return IERC20(reward).balanceOf(address(this)) + freshRewards;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getClaimableRewards(address user, address reward) external view returns (uint256) {\n        return _getClaimableRewards(user, reward, balanceOf[user], getCurrentRewardsIndex(reward));\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getUnclaimedRewards(address user, address reward) external view returns (uint256) {\n        return _userRewardsData[user][reward].unclaimedRewards;\n    }\n\n    ///@inheritdoc IERC4626\n    function asset() external view returns (address) {\n        return address(_aTokenUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function aToken() external view returns (IERC20) {\n        return _aToken;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function rewardTokens() external view returns (address[] memory) {\n        return _rewardTokens;\n    }\n\n    ///@inheritdoc IERC4626\n    function totalAssets() external view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n\n    ///@inheritdoc IERC4626\n    function convertToShares(uint256 assets) external view returns (uint256) {\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function convertToAssets(uint256 shares) external view returns (uint256) {\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        uint256 assets = maxDeposit(address(0));\n        if (assets == type(uint256).max) return type(uint256).max;\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        uint256 shares = maxRedeem(owner);\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        address cachedATokenUnderlying = _aTokenUnderlying;\n        DataTypes.ReserveData memory reserveData = POOL.getReserveData(cachedATokenUnderlying);\n\n        // if paused or inactive users cannot withdraw underlying\n        if (\n            !ReserveConfiguration.getActive(reserveData.configuration) ||\n            ReserveConfiguration.getPaused(reserveData.configuration)\n        ) {\n            return 0;\n        }\n\n        // otherwise users can withdraw up to the available amount\n        uint256 underlyingTokenBalanceInShares = _convertToShares(\n            IERC20(cachedATokenUnderlying).balanceOf(reserveData.aTokenAddress),\n            Rounding.DOWN\n        );\n        uint256 cachedUserBalance = balanceOf[owner];\n        return underlyingTokenBalanceInShares >= cachedUserBalance ? cachedUserBalance : underlyingTokenBalanceInShares;\n    }\n\n    ///@inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        DataTypes.ReserveData memory reserveData = POOL.getReserveData(_aTokenUnderlying);\n\n        // if inactive, paused or frozen users cannot deposit underlying\n        if (\n            !ReserveConfiguration.getActive(reserveData.configuration) ||\n            ReserveConfiguration.getPaused(reserveData.configuration) ||\n            ReserveConfiguration.getFrozen(reserveData.configuration)\n        ) {\n            return 0;\n        }\n\n        uint256 supplyCap = ReserveConfiguration.getSupplyCap(reserveData.configuration) *\n            (10 ** ReserveConfiguration.getDecimals(reserveData.configuration));\n        // if no supply cap deposit is unlimited\n        if (supplyCap == 0) return type(uint256).max;\n        // return remaining supply cap margin\n        uint256 currentSupply = (IAToken(reserveData.aTokenAddress).scaledTotalSupply() + reserveData.accruedToTreasury)\n            .rayMulRoundUp(_getNormalizedIncome(reserveData));\n        return currentSupply > supplyCap ? 0 : supplyCap - currentSupply;\n    }\n\n    ///@inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) external virtual returns (uint256) {\n        (uint256 shares, ) = _deposit(msg.sender, receiver, 0, assets, 0, true);\n        return shares;\n    }\n\n    ///@inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) external virtual returns (uint256) {\n        (, uint256 assets) = _deposit(msg.sender, receiver, shares, 0, 0, true);\n\n        return assets;\n    }\n\n    ///@inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) external virtual returns (uint256) {\n        (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, true);\n\n        return shares;\n    }\n\n    ///@inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) external virtual returns (uint256) {\n        (, uint256 assets) = _withdraw(owner, receiver, shares, 0, true);\n\n        return assets;\n    }\n\n    /// @notice Deposit aTokens and mint static tokens to receiver\n    function depositATokens(uint256 aTokenAmount, address receiver) external override returns (uint256) {\n        require(aTokenAmount > 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // allow compensation for rebase during tx\n        uint256 userBalance = _aToken.balanceOf(msg.sender);\n        uint256 amount = aTokenAmount > userBalance ? userBalance : aTokenAmount;\n        // determine shares to mint\n        uint256 shares = previewDeposit(amount);\n        require(shares != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // transfer aTokens in\n        _aToken.safeTransferFrom(msg.sender, address(this), amount);\n        // mint static tokens\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, amount, shares);\n        return shares;\n    }\n\n    /// @notice Burn static tokens and return aTokens to receiver\n    function redeemATokens(uint256 shares, address receiver, address owner) external override returns (uint256) {\n        require(shares > 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // determine assets to return\n        uint256 assets = previewRedeem(shares);\n        require(assets != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // handle allowance if not owner\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender];\n            if (allowed != type(uint256).max) {\n                allowance[owner][msg.sender] = allowed - shares;\n            }\n        }\n        // burn static tokens\n        _burn(owner, shares);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        // transfer aTokens out\n        _aToken.safeTransfer(receiver, assets);\n        return assets;\n    }\n\n    function _deposit(\n        address depositor,\n        address receiver,\n        uint256 _shares,\n        uint256 _assets,\n        uint16 referralCode,\n        bool depositToAave\n    ) internal returns (uint256, uint256) {\n        require(receiver != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        require(_shares == 0 || _assets == 0, StaticATokenErrors.ONLY_ONE_AMOUNT_FORMAT_ALLOWED);\n\n        uint256 assets = _assets;\n        uint256 shares = _shares;\n        if (shares > 0) {\n            if (depositToAave) {\n                require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n            }\n            assets = previewMint(shares);\n        } else {\n            if (depositToAave) {\n                require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n            }\n            shares = previewDeposit(assets);\n        }\n        require(shares != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n\n        if (depositToAave) {\n            address cachedATokenUnderlying = _aTokenUnderlying;\n            SafeERC20.safeTransferFrom(IERC20(cachedATokenUnderlying), depositor, address(this), assets);\n            POOL.deposit(cachedATokenUnderlying, assets, address(this), referralCode);\n        } else {\n            _aToken.safeTransferFrom(depositor, address(this), assets);\n        }\n\n        _mint(receiver, shares);\n\n        emit Deposit(depositor, receiver, assets, shares);\n\n        return (shares, assets);\n    }\n\n    function _withdraw(\n        address owner,\n        address receiver,\n        uint256 _shares,\n        uint256 _assets,\n        bool withdrawFromAave\n    ) internal returns (uint256, uint256) {\n        require(receiver != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        require(_shares == 0 || _assets == 0, StaticATokenErrors.ONLY_ONE_AMOUNT_FORMAT_ALLOWED);\n        require(_shares != _assets, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n\n        uint256 assets = _assets;\n        uint256 shares = _shares;\n\n        if (shares > 0) {\n            if (withdrawFromAave) {\n                require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n            }\n            assets = previewRedeem(shares);\n        } else {\n            if (withdrawFromAave) {\n                require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n            }\n            shares = previewWithdraw(assets);\n        }\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        if (withdrawFromAave) {\n            POOL.withdraw(_aTokenUnderlying, assets, receiver);\n        } else {\n            _aToken.safeTransfer(receiver, assets);\n        }\n\n        return (shares, assets);\n    }\n\n    /**\n     * @notice Updates rewards for senders and receiver in a transfer (not updating rewards for address(0))\n     * @param from The address of the sender of tokens\n     * @param to The address of the receiver of tokens\n     */\n    function _beforeTokenTransfer(address from, address to, uint256) internal override {\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\n            address rewardToken = address(_rewardTokens[i]);\n            uint256 rewardsIndex = getCurrentRewardsIndex(rewardToken);\n            if (from != address(0)) {\n                _updateUser(from, rewardsIndex, rewardToken);\n            }\n            if (to != address(0) && from != to) {\n                _updateUser(to, rewardsIndex, rewardToken);\n            }\n        }\n    }\n\n    /**\n     * @notice Adding the pending rewards to the unclaimed for specific user and updating user index\n     * @param user The address of the user to update\n     * @param currentRewardsIndex The current rewardIndex\n     * @param rewardToken The address of the reward token\n     */\n    function _updateUser(address user, uint256 currentRewardsIndex, address rewardToken) internal {\n        uint256 balance = balanceOf[user];\n        if (balance > 0) {\n            _userRewardsData[user][rewardToken].unclaimedRewards = _getClaimableRewards(\n                user,\n                rewardToken,\n                balance,\n                currentRewardsIndex\n            ).toUint128();\n        }\n        _userRewardsData[user][rewardToken].rewardsIndexOnLastInteraction = currentRewardsIndex.toUint128();\n    }\n\n    /**\n     * @notice Compute the pending in WAD. Pending is the amount to add (not yet unclaimed) rewards in WAD.\n     * @param balance The balance of the user\n     * @param rewardsIndexOnLastInteraction The index which was on the last interaction of the user\n     * @param currentRewardsIndex The current rewards index in the system\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The amount of pending rewards in WAD\n     */\n    function _getPendingRewards(\n        uint256 balance,\n        uint256 rewardsIndexOnLastInteraction,\n        uint256 currentRewardsIndex,\n        uint256 assetUnit\n    ) internal pure returns (uint256) {\n        if (balance == 0) {\n            return 0;\n        }\n        return (balance * (currentRewardsIndex - rewardsIndexOnLastInteraction)) / assetUnit;\n    }\n\n    /**\n     * @notice Compute the claimable rewards for a user\n     * @param user The address of the user\n     * @param reward The address of the reward\n     * @param balance The balance of the user in WAD\n     * @param currentRewardsIndex The current rewards index\n     * @return The total rewards that can be claimed by the user (if `fresh` flag true, after updating rewards)\n     */\n    function _getClaimableRewards(\n        address user,\n        address reward,\n        uint256 balance,\n        uint256 currentRewardsIndex\n    ) internal view returns (uint256) {\n        RewardIndexCache memory rewardsIndexCache = _startIndex[reward];\n        require(rewardsIndexCache.isRegistered == true, StaticATokenErrors.REWARD_NOT_INITIALIZED);\n        UserRewardsData memory currentUserRewardsData = _userRewardsData[user][reward];\n        uint256 assetUnit = 10 ** decimals;\n        return\n            currentUserRewardsData.unclaimedRewards +\n            _getPendingRewards(\n                balance,\n                currentUserRewardsData.rewardsIndexOnLastInteraction == 0\n                    ? rewardsIndexCache.lastUpdatedIndex\n                    : currentUserRewardsData.rewardsIndexOnLastInteraction,\n                currentRewardsIndex,\n                assetUnit\n            );\n    }\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @param onBehalfOf The address to claim on behalf of\n     * @param rewards The addresses of the rewards\n     * @param receiver The address to receive the rewards\n     */\n    function _claimRewardsOnBehalf(address onBehalfOf, address receiver, address[] memory rewards) internal {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            if (address(rewards[i]) == address(0)) {\n                continue;\n            }\n            uint256 currentRewardsIndex = getCurrentRewardsIndex(rewards[i]);\n            uint256 balance = balanceOf[onBehalfOf];\n            uint256 userReward = _getClaimableRewards(onBehalfOf, rewards[i], balance, currentRewardsIndex);\n            uint256 totalRewardTokenBalance = IERC20(rewards[i]).balanceOf(address(this));\n            uint256 unclaimedReward = 0;\n\n            if (userReward > totalRewardTokenBalance) {\n                totalRewardTokenBalance += collectAndUpdateRewards(address(rewards[i]));\n            }\n\n            if (userReward > totalRewardTokenBalance) {\n                unclaimedReward = userReward - totalRewardTokenBalance;\n                userReward = totalRewardTokenBalance;\n            }\n            if (userReward > 0) {\n                _userRewardsData[onBehalfOf][rewards[i]].unclaimedRewards = unclaimedReward.toUint128();\n                _userRewardsData[onBehalfOf][rewards[i]].rewardsIndexOnLastInteraction = currentRewardsIndex\n                    .toUint128();\n                IERC20(rewards[i]).safeTransfer(receiver, userReward);\n            }\n        }\n    }\n\n    function _convertToShares(uint256 assets, Rounding rounding) internal view returns (uint256) {\n        if (rounding == Rounding.UP) return assets.rayDivRoundUp(rate());\n        return assets.rayDivRoundDown(rate());\n    }\n\n    function _convertToAssets(uint256 shares, Rounding rounding) internal view returns (uint256) {\n        if (rounding == Rounding.UP) return shares.rayMulRoundUp(rate());\n        return shares.rayMulRoundDown(rate());\n    }\n\n    /**\n     * @notice Initializes a new rewardToken\n     * @param reward The reward token to be registered\n     */\n    function _registerRewardToken(address reward) internal {\n        if (isRegisteredRewardToken(reward)) return;\n        uint256 startIndex = getCurrentRewardsIndex(reward);\n\n        _rewardTokens.push(reward);\n        _startIndex[reward] = RewardIndexCache(true, uint240(startIndex));\n\n        emit RewardTokenRegistered(reward, startIndex);\n    }\n\n    /**\n     * @notice Returns the ongoing normalized income for the reserve.\n     * @dev A value of 1e27 means there is no income. As time passes, the income is accrued\n     * @dev A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n     * @param reserve The reserve object\n     * @return The normalized income, expressed in ray\n     */\n    function _getNormalizedIncome(DataTypes.ReserveData memory reserve) internal view returns (uint256) {\n        uint40 timestamp = reserve.lastUpdateTimestamp;\n\n        //solium-disable-next-line\n        if (timestamp == block.timestamp) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return reserve.liquidityIndex;\n        } else {\n            return\n                MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n                    reserve.liquidityIndex\n                );\n        }\n    }\n}\n"
    },
    "contracts/vaults/dstake/adapters/WrappedDLendConversionAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDStableConversionAdapter } from \"../interfaces/IDStableConversionAdapter.sol\";\nimport { IStaticATokenLM } from \"../../atoken_wrapper/interfaces/IStaticATokenLM.sol\"; // Interface for StaticATokenLM\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\n/**\n * @title WrappedDLendConversionAdapter\n * @notice Adapter for converting between a dSTABLE asset (like dUSD) and a specific wrapped dLEND aToken\n *         (like wddUSD, implemented via StaticATokenLM). The wrapped dLEND token address must be provided at deployment.\n * @dev Implements the IDStableConversionAdapter interface.\n *      Interacts with a specific StaticATokenLM contract provided at deployment.\n */\ncontract WrappedDLendConversionAdapter is IDStableConversionAdapter {\n    using SafeERC20 for IERC20;\n\n    // --- Errors ---\n    error ZeroAddress();\n    error InvalidAmount();\n    error InconsistentState(string message);\n\n    // --- State ---\n    address public immutable dStable; // The underlying dSTABLE asset (e.g., dUSD)\n    IStaticATokenLM public immutable wrappedDLendToken; // The wrapped dLEND aToken (StaticATokenLM instance, e.g., wddUSD)\n    address public immutable collateralVault; // The DStakeCollateralVault to deposit wrappedDLendToken into\n\n    // --- Constructor ---\n    /**\n     * @param _dStable The address of the dSTABLE asset (e.g., dUSD)\n     * @param _wrappedDLendToken The address of the wrapped dLEND token (StaticATokenLM, e.g., wddUSD)\n     * @param _collateralVault The address of the DStakeCollateralVault\n     */\n    constructor(address _dStable, address _wrappedDLendToken, address _collateralVault) {\n        if (_dStable == address(0) || _wrappedDLendToken == address(0) || _collateralVault == address(0)) {\n            revert ZeroAddress();\n        }\n        dStable = _dStable;\n        wrappedDLendToken = IStaticATokenLM(_wrappedDLendToken);\n        collateralVault = _collateralVault;\n\n        // Sanity check: Ensure the StaticATokenLM wrapper uses the correct underlying by casting to IERC4626\n        if (IERC4626(_wrappedDLendToken).asset() != _dStable) {\n            revert InconsistentState(\"StaticATokenLM underlying mismatch\");\n        }\n    }\n\n    // --- IDStableConversionAdapter Implementation ---\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     * @dev Converts dStable -> wrappedDLendToken by depositing into StaticATokenLM.\n     *      The StaticATokenLM contract MUST be pre-approved to spend dStable held by this adapter.\n     *      The StaticATokenLM contract mints the wrappedDLendToken directly to the collateralVault.\n     */\n    function convertToVaultAsset(\n        uint256 dStableAmount\n    ) external override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        if (dStableAmount == 0) {\n            revert InvalidAmount();\n        }\n\n        // 1. Pull dStable from caller (Router)\n        IERC20(dStable).safeTransferFrom(msg.sender, address(this), dStableAmount);\n\n        // 2. Approve the StaticATokenLM wrapper to pull the dStable\n        IERC20(dStable).approve(address(wrappedDLendToken), dStableAmount);\n\n        // 3. Deposit dStable into the StaticATokenLM wrapper, minting wrappedDLendToken to collateralVault\n        vaultAssetAmount = IERC4626(address(wrappedDLendToken)).deposit(dStableAmount, collateralVault);\n\n        return (address(wrappedDLendToken), vaultAssetAmount);\n    }\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     * @dev Converts wrappedDLendToken -> dStable by withdrawing from StaticATokenLM.\n     *      The StaticATokenLM contract sends the dStable directly to msg.sender.\n     */\n    function convertFromVaultAsset(uint256 vaultAssetAmount) external override returns (uint256 dStableAmount) {\n        if (vaultAssetAmount == 0) {\n            revert InvalidAmount();\n        }\n\n        // 1. Pull wrappedDLendToken (shares) from caller (Router)\n        IERC20(address(wrappedDLendToken)).safeTransferFrom(msg.sender, address(this), vaultAssetAmount);\n\n        // 2. Withdraw from StaticATokenLM, sending dStable to msg.sender\n        dStableAmount = IERC4626(address(wrappedDLendToken)).redeem(vaultAssetAmount, msg.sender, address(this));\n\n        if (dStableAmount == 0) {\n            revert InvalidAmount();\n        }\n\n        return dStableAmount;\n    }\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     * @dev Uses StaticATokenLM's previewRedeem function to get the underlying value (dStable).\n     */\n    function assetValueInDStable(\n        address _vaultAsset,\n        uint256 vaultAssetAmount\n    ) external view override returns (uint256 dStableValue) {\n        if (_vaultAsset != address(wrappedDLendToken)) {\n            revert InconsistentState(\"Incorrect vault asset address\");\n        }\n        // previewRedeem takes shares (vaultAssetAmount) and returns assets (dStableValue)\n        return IERC4626(address(wrappedDLendToken)).previewRedeem(vaultAssetAmount);\n    }\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     */\n    function vaultAsset() external view override returns (address) {\n        return address(wrappedDLendToken);\n    }\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     * @dev Preview the result of converting a given dSTABLE amount to wrappedDLendToken.\n     */\n    function previewConvertToVaultAsset(\n        uint256 dStableAmount\n    ) public view override returns (address _vaultAsset, uint256 vaultAssetAmount) {\n        _vaultAsset = address(wrappedDLendToken);\n        vaultAssetAmount = IERC4626(address(wrappedDLendToken)).previewDeposit(dStableAmount);\n    }\n\n    /**\n     * @inheritdoc IDStableConversionAdapter\n     * @dev Preview the result of converting a given wrappedDLendToken amount to dSTABLE.\n     */\n    function previewConvertFromVaultAsset(\n        uint256 vaultAssetAmount\n    ) public view override returns (uint256 dStableAmount) {\n        dStableAmount = IERC4626(address(wrappedDLendToken)).previewRedeem(vaultAssetAmount);\n    }\n}\n"
    },
    "contracts/vaults/dstake/DStakeCollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDStakeCollateralVault } from \"./interfaces/IDStakeCollateralVault.sol\";\nimport { IDStableConversionAdapter } from \"./interfaces/IDStableConversionAdapter.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// ---------------------------------------------------------------------------\n// Internal interface to query the router's public mapping without importing the\n// full router contract (avoids circular dependencies).\n// ---------------------------------------------------------------------------\ninterface IAdapterProvider {\n    function vaultAssetToAdapter(address) external view returns (address);\n}\n\n/**\n * @title DStakeCollateralVault\n * @notice Holds various yield-bearing/convertible ERC20 tokens (`vault assets`) managed by dSTAKE.\n * @dev Calculates the total value of these assets in terms of the underlying dStable asset\n *      using registered adapters. This contract is non-upgradeable but replaceable via\n *      DStakeToken governance.\n *      Uses AccessControl for role-based access control.\n */\ncontract DStakeCollateralVault is IDStakeCollateralVault, AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // --- Roles ---\n    bytes32 public constant ROUTER_ROLE = keccak256(\"ROUTER_ROLE\");\n\n    // --- Errors ---\n    error ZeroAddress();\n    error AssetNotSupported(address asset);\n    error AssetAlreadySupported(address asset);\n    error NonZeroBalance(address asset);\n    error CannotRescueRestrictedToken(address token);\n    error ETHTransferFailed(address receiver, uint256 amount);\n\n    // --- Events ---\n    event TokenRescued(address indexed token, address indexed receiver, uint256 amount);\n    event ETHRescued(address indexed receiver, uint256 amount);\n\n    // --- State ---\n    address public immutable dStakeToken; // The DStakeToken this vault serves\n    address public immutable dStable; // The underlying dStable asset address\n\n    address public router; // The DStakeRouter allowed to interact\n\n    EnumerableSet.AddressSet private _supportedAssets; // Set of supported vault assets\n\n    // --- Constructor ---\n    constructor(address _dStakeVaultShare, address _dStableAsset) {\n        if (_dStakeVaultShare == address(0) || _dStableAsset == address(0)) {\n            revert ZeroAddress();\n        }\n        dStakeToken = _dStakeVaultShare;\n        dStable = _dStableAsset;\n\n        // Set up the DEFAULT_ADMIN_ROLE initially to the contract deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // --- External Views (IDStakeCollateralVault Interface) ---\n\n    /**\n     * @inheritdoc IDStakeCollateralVault\n     */\n    function totalValueInDStable() external view override returns (uint256 dStableValue) {\n        uint256 totalValue = 0;\n        uint256 len = _supportedAssets.length();\n        for (uint256 i = 0; i < len; i++) {\n            address vaultAsset = _supportedAssets.at(i);\n            address adapterAddress = IAdapterProvider(router).vaultAssetToAdapter(vaultAsset);\n\n            if (adapterAddress == address(0)) {\n                // If there is no adapter configured, simply skip this asset to\n                // preserve liveness. Anyone can dust this vault and we cannot\n                // enforce that all assets have adapters before removal\n                continue;\n            }\n\n            uint256 balance = IERC20(vaultAsset).balanceOf(address(this));\n            if (balance > 0) {\n                totalValue += IDStableConversionAdapter(adapterAddress).assetValueInDStable(vaultAsset, balance);\n            }\n        }\n        return totalValue;\n    }\n\n    // --- External Functions (Router Interactions) ---\n\n    /**\n     * @notice Transfers `amount` of `vaultAsset` from this vault to `recipient`.\n     * @dev Only callable by the registered router (ROUTER_ROLE).\n     */\n    function sendAsset(address vaultAsset, uint256 amount, address recipient) external onlyRole(ROUTER_ROLE) {\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\n        IERC20(vaultAsset).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Adds a new supported vault asset. Can only be invoked by the router.\n     */\n    function addSupportedAsset(address vaultAsset) external onlyRole(ROUTER_ROLE) {\n        if (vaultAsset == address(0)) revert ZeroAddress();\n        if (_isSupported(vaultAsset)) revert AssetAlreadySupported(vaultAsset);\n\n        _supportedAssets.add(vaultAsset);\n        emit SupportedAssetAdded(vaultAsset);\n    }\n\n    /**\n     * @notice Removes a supported vault asset. Can only be invoked by the router.\n     */\n    function removeSupportedAsset(address vaultAsset) external onlyRole(ROUTER_ROLE) {\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\n        // NOTE: Previously this function reverted if the vault still held a\n        // non-zero balance of the asset, causing a griefing / DoS vector:\n        // anyone could deposit 1 wei of the token to block removal. The\n        // check has been removed so governance can always delist an asset.\n\n        _supportedAssets.remove(vaultAsset);\n        emit SupportedAssetRemoved(vaultAsset);\n    }\n\n    // --- Governance Functions ---\n\n    /**\n     * @notice Sets the router address. Grants ROUTER_ROLE to new router and\n     *         revokes it from the previous router.\n     */\n    function setRouter(address _newRouter) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newRouter == address(0)) revert ZeroAddress();\n\n        // Revoke role from old router\n        if (router != address(0)) {\n            _revokeRole(ROUTER_ROLE, router);\n        }\n\n        _grantRole(ROUTER_ROLE, _newRouter);\n        router = _newRouter;\n        emit RouterSet(_newRouter);\n    }\n\n    // --- Internal Utilities ---\n\n    function _isSupported(address asset) private view returns (bool) {\n        return _supportedAssets.contains(asset);\n    }\n\n    // --- External Views ---\n\n    /**\n     * @notice Returns the vault asset at `index` from the internal supported set.\n     *         Kept for backwards-compatibility with the previous public array getter.\n     */\n    function supportedAssets(uint256 index) external view override returns (address) {\n        return _supportedAssets.at(index);\n    }\n\n    /**\n     * @notice Returns the entire list of supported vault assets. Useful for UIs & off-chain tooling.\n     */\n    function getSupportedAssets() external view returns (address[] memory) {\n        return _supportedAssets.values();\n    }\n\n    // --- Recovery Functions ---\n\n    /**\n     * @notice Rescues tokens accidentally sent to the contract\n     * @dev Cannot rescue supported vault assets or the dStable token\n     * @param token Address of the token to rescue\n     * @param receiver Address to receive the rescued tokens\n     * @param amount Amount of tokens to rescue\n     */\n    function rescueToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Check if token is a supported asset\n        if (_isSupported(token)) {\n            revert CannotRescueRestrictedToken(token);\n        }\n\n        // Check if token is the dStable token\n        if (token == dStable) {\n            revert CannotRescueRestrictedToken(token);\n        }\n\n        // Rescue the token\n        IERC20(token).safeTransfer(receiver, amount);\n        emit TokenRescued(token, receiver, amount);\n    }\n\n    /**\n     * @notice Rescues ETH accidentally sent to the contract\n     * @param receiver Address to receive the rescued ETH\n     * @param amount Amount of ETH to rescue\n     */\n    function rescueETH(address receiver, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (bool success, ) = receiver.call{ value: amount }(\"\");\n        if (!success) revert ETHTransferFailed(receiver, amount);\n\n        emit ETHRescued(receiver, amount);\n    }\n\n    /**\n     * @notice Returns the list of tokens that cannot be rescued\n     * @return restrictedTokens Array of restricted token addresses\n     */\n    function getRestrictedRescueTokens() external view returns (address[] memory) {\n        address[] memory assets = _supportedAssets.values();\n        address[] memory restrictedTokens = new address[](assets.length + 1);\n\n        // Add all supported assets\n        for (uint256 i = 0; i < assets.length; i++) {\n            restrictedTokens[i] = assets[i];\n        }\n\n        // Add dStable token\n        restrictedTokens[assets.length] = dStable;\n\n        return restrictedTokens;\n    }\n\n    /**\n     * @notice Allows the contract to receive ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/vaults/dstake/DStakeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ERC4626Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDStakeCollateralVault } from \"./interfaces/IDStakeCollateralVault.sol\";\nimport { IDStakeRouter } from \"./interfaces/IDStakeRouter.sol\";\nimport { BasisPointConstants } from \"../../common/BasisPointConstants.sol\";\nimport { SupportsWithdrawalFee } from \"../../common/SupportsWithdrawalFee.sol\";\n\n/**\n * @title DStakeToken\n * @dev ERC4626-compliant token representing shares in the DStakeCollateralVault.\n */\ncontract DStakeToken is Initializable, ERC4626Upgradeable, AccessControlUpgradeable, SupportsWithdrawalFee {\n    // --- Roles ---\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    // --- Errors ---\n    error ZeroAddress();\n    error ZeroShares();\n    error ERC4626ExceedsMaxWithdraw(uint256 assets, uint256 maxAssets);\n    error ERC4626ExceedsMaxRedeem(uint256 shares, uint256 maxShares);\n\n    // --- State ---\n    IDStakeCollateralVault public collateralVault;\n    IDStakeRouter public router;\n\n    uint256 public constant MAX_WITHDRAWAL_FEE_BPS = BasisPointConstants.ONE_PERCENT_BPS;\n\n    // --- Initializer ---\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IERC20 _dStable,\n        string memory _name,\n        string memory _symbol,\n        address _initialAdmin,\n        address _initialFeeManager\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC4626_init(_dStable);\n        __AccessControl_init();\n        _initializeWithdrawalFee(0);\n\n        if (address(_dStable) == address(0) || _initialAdmin == address(0) || _initialFeeManager == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialAdmin);\n        _grantRole(FEE_MANAGER_ROLE, _initialFeeManager);\n    }\n\n    // --- SupportsWithdrawalFee Implementation ---\n    function _maxWithdrawalFeeBps() internal view virtual override returns (uint256) {\n        return MAX_WITHDRAWAL_FEE_BPS;\n    }\n\n    /**\n     * @notice Public getter for the current withdrawal fee in basis points.\n     */\n    function withdrawalFeeBps() public view returns (uint256) {\n        return getWithdrawalFeeBps(); // Uses getter from SupportsWithdrawalFee\n    }\n\n    /**\n     * @notice Public getter for the maximum withdrawal fee in basis points.\n     */\n    function maxWithdrawalFeeBps() public view returns (uint256) {\n        return MAX_WITHDRAWAL_FEE_BPS;\n    }\n\n    // --- ERC4626 Overrides ---\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev\n     * IMPORTANT: When all vault shares have been redeemed, the router intentionally\n     * leaves up to `dustTolerance` (1 wei by default) of wrapper tokens in the\n     * `DStakeCollateralVault`. These wrapper tokens continue to accrue\n     * yield via an ever-increasing price-per-share. As a result, it is\n     * theoretically possible for `totalSupply() == 0` while `totalAssets()`\n     * returns a non-zero value.\n     *\n     * The protocol explicitly accepts that the **first depositor after such a\n     * complete withdrawal will receive whatever residual value has\n     * accumulated**.  Given the minuscule starting balance ( 1 wei) and slow\n     * growth rate, the team judged that the gas cost of enforcing a strict\n     * invariant outweighed the negligible windfall.\n     *\n     * Please keep this in mind if `dustTolerance` is increased to a non-negligible value.\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        if (address(collateralVault) == address(0)) {\n            return 0;\n        }\n        return collateralVault.totalValueInDStable();\n    }\n\n    /**\n     * @dev Pulls dSTABLE asset from depositor, then delegates the core deposit logic\n     *      (converting dSTABLE to vault assets) to the router.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual override {\n        // Revert early if the calculated share amount is zero to prevent depositing assets without receiving shares\n        if (shares == 0) {\n            revert ZeroShares();\n        }\n        if (address(router) == address(0) || address(collateralVault) == address(0)) {\n            revert ZeroAddress(); // Router or Vault not set\n        }\n\n        // Pull assets from caller\n        super._deposit(caller, receiver, assets, shares); // This handles the ERC20 transfer\n\n        // Approve router to spend the received assets (necessary because super._deposit transfers to this contract)\n        // Use standard approve for trusted protocol token (dStable) and trusted protocol contract (router)\n        IERC20(asset()).approve(address(router), assets);\n\n        // Delegate conversion and vault update logic to router\n        router.deposit(assets);\n    }\n\n    /**\n     * @dev Override to handle withdrawals with fees correctly.\n     *      The `assets` parameter is the net amount of assets the user wants to receive.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 shares) {\n        // Calculate how many shares correspond to the desired NET `assets` amount.\n        shares = previewWithdraw(assets);\n\n        // Ensure the owner has enough shares to cover the withdrawal (checks in share terms rather than assets).\n        if (shares > maxRedeem(owner)) {\n            revert ERC4626ExceedsMaxRedeem(shares, maxRedeem(owner));\n        }\n\n        // Translate the shares back into the GROSS asset amount that needs to be withdrawn\n        // so that the internal logic can compute the fee only once.\n        uint256 grossAssets = convertToAssets(shares);\n\n        _withdraw(_msgSender(), receiver, owner, grossAssets, shares);\n        return shares;\n    }\n\n    /**\n     * @notice Returns the maximum NET assets that `owner` can withdraw taking the current\n     *         withdrawal fee into account.\n     *\n     *         OpenZeppelin's reference implementation returns the owner's share balance\n     *         converted to assets (i.e. a gross value).  In a fee-charging vault that\n     *         exposes `withdraw(netAssets)`, the intuitive expectation is that\n     *         `maxWithdraw` already reflects what the user will actually receive after\n     *         fees.  We therefore convert the share balance to GROSS assets first and then\n     *         subtract the fee.\n     */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        uint256 grossAssets = convertToAssets(balanceOf(owner));\n        return _getNetAmountAfterFee(grossAssets);\n    }\n\n    /**\n     * @dev Override to ensure the withdrawal fee is deducted only once.\n     *      The `shares` parameter is converted to its equivalent gross asset value, then the\n     *      internal _withdraw handles fee calculation. The returned value is the net assets\n     *      actually received by the `receiver`, matching previewRedeem().\n     */\n    function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256 assets) {\n        uint256 grossAssets = convertToAssets(shares); // shares  gross assets before fee\n\n        if (shares > maxRedeem(owner)) {\n            revert ERC4626ExceedsMaxRedeem(shares, maxRedeem(owner));\n        }\n\n        // Perform withdrawal using gross assets so that _withdraw computes the correct fee once\n        _withdraw(_msgSender(), receiver, owner, grossAssets, shares);\n\n        // Net assets the user effectively receives\n        assets = _getNetAmountAfterFee(grossAssets);\n        return assets;\n    }\n\n    /**\n     * @dev Calculates withdrawal fee, then delegates the core withdrawal logic\n     *      (converting vault assets back to dSTABLE) to the router.\n     *      The `assets` parameter is now the gross amount that needs to be withdrawn from the vault.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets, // This is now the GROSS amount\n        uint256 shares\n    ) internal virtual override {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        if (address(router) == address(0) || address(collateralVault) == address(0)) {\n            revert ZeroAddress(); // Router or Vault not set\n        }\n\n        uint256 fee = _calculateWithdrawalFee(assets); // Calculate fee on GROSS amount\n        uint256 amountToSend = assets - fee; // Send NET amount to user\n\n        // Burn shares from owner\n        _burn(owner, shares);\n\n        // Delegate conversion and vault update logic to router\n        // Router is responsible for ensuring `amountToSend` of dSTABLE reaches the `receiver`.\n        router.withdraw(amountToSend, receiver, owner);\n\n        // Emit ERC4626 Withdraw event with the NET assets that were actually sent\n        emit Withdraw(caller, receiver, owner, amountToSend, shares);\n\n        // Optional: Emit fee event\n        if (fee > 0) {\n            emit WithdrawalFee(owner, receiver, fee);\n        }\n    }\n\n    /**\n     * @dev Preview withdraw including withdrawal fee.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 grossAssetsRequired = _getGrossAmountRequiredForNet(assets);\n        return super.previewWithdraw(grossAssetsRequired);\n    }\n\n    /**\n     * @dev Preview redeem including withdrawal fee.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        uint256 grossAssets = super.previewRedeem(shares);\n        return _getNetAmountAfterFee(grossAssets);\n    }\n\n    // --- Governance Functions ---\n\n    /**\n     * @notice Sets the address of the DStakeRouter contract.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _router The address of the new router contract.\n     */\n    function setRouter(address _router) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_router == address(0)) {\n            revert ZeroAddress();\n        }\n        router = IDStakeRouter(_router);\n        emit RouterSet(_router);\n    }\n\n    /**\n     * @notice Sets the address of the DStakeCollateralVault contract.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _collateralVault The address of the new collateral vault contract.\n     */\n    function setCollateralVault(address _collateralVault) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_collateralVault == address(0)) {\n            revert ZeroAddress();\n        }\n        collateralVault = IDStakeCollateralVault(_collateralVault);\n        emit CollateralVaultSet(_collateralVault);\n    }\n\n    /**\n     * @notice Sets the withdrawal fee in basis points.\n     * @dev Requires FEE_MANAGER_ROLE.\n     * @param _feeBps The new withdrawal fee (e.g., 1000 = 0.1%).\n     */\n    function setWithdrawalFee(uint256 _feeBps) external onlyRole(FEE_MANAGER_ROLE) {\n        _setWithdrawalFee(_feeBps);\n    }\n\n    // --- Events ---\n    event RouterSet(address indexed router);\n    event CollateralVaultSet(address indexed collateralVault);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStableConversionAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStableConversionAdapter Interface\n * @notice Interface for contracts that handle the conversion between the core dStable asset\n *         and a specific yield-bearing or convertible ERC20 token (`vault asset`), as well as\n *         valuing that `vault asset` in terms of the dStable asset.\n * @dev Implementations interact with specific protocols (lending pools, DEX LPs, wrappers, etc.).\n */\ninterface IDStableConversionAdapter {\n    /**\n     * @notice Converts a specified amount of the dStable asset into the specific `vaultAsset`\n     *         managed by this adapter.\n     * @dev The adapter MUST pull `dStableAmount` of the dStable asset from the caller (expected to be the Router).\n     * @dev The resulting `vaultAsset` MUST be sent/deposited/minted directly to the `collateralVault` address provided during adapter setup or retrieved.\n     * @param dStableAmount The amount of dStable asset to convert.\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\n     * @return vaultAssetAmount The amount of `vaultAsset` generated from the conversion.\n     */\n    function convertToVaultAsset(uint256 dStableAmount) external returns (address vaultAsset, uint256 vaultAssetAmount);\n\n    /**\n     * @notice Converts a specific amount of `vaultAsset` back into the dStable asset.\n     * @dev The adapter MUST pull the required amount of `vaultAsset` from the caller (expected to be the Router).\n     * @dev The resulting dStable asset MUST be sent to the caller.\n     * @param vaultAssetAmount The amount of `vaultAsset` to convert.\n     * @return dStableAmount The amount of dStable asset sent to the caller.\n     */\n    function convertFromVaultAsset(uint256 vaultAssetAmount) external returns (uint256 dStableAmount);\n\n    /**\n     * @notice Preview the result of converting a given dStable amount to vaultAsset (without state change).\n     * @param dStableAmount The amount of dStable asset to preview conversion for.\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\n     * @return vaultAssetAmount The amount of `vaultAsset` that would be received.\n     */\n    function previewConvertToVaultAsset(\n        uint256 dStableAmount\n    ) external view returns (address vaultAsset, uint256 vaultAssetAmount);\n\n    /**\n     * @notice Preview the result of converting a given vaultAsset amount to dStable (without state change).\n     * @param vaultAssetAmount The amount of `vaultAsset` to preview conversion for.\n     * @return dStableAmount The amount of dStable asset that would be received.\n     */\n    function previewConvertFromVaultAsset(uint256 vaultAssetAmount) external view returns (uint256 dStableAmount);\n\n    /**\n     * @notice Calculates the value of a given amount of the specific `vaultAsset` managed by this adapter\n     *         in terms of the dStable asset.\n     * @param vaultAsset The address of the vault asset token (should match getVaultAsset()). Included for explicitness.\n     * @param vaultAssetAmount The amount of the `vaultAsset` to value.\n     * @return dStableValue The equivalent value in the dStable asset.\n     */\n    function assetValueInDStable(\n        address vaultAsset,\n        uint256 vaultAssetAmount\n    ) external view returns (uint256 dStableValue);\n\n    /**\n     * @notice Returns the address of the specific `vault asset` token managed by this adapter.\n     * @return The address of the `vault asset`.\n     */\n    function vaultAsset() external view returns (address);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStakeCollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStakeCollateralVault Interface\n * @notice Defines the external functions of the DStakeCollateralVault required by other\n *         contracts in the dSTAKE system, primarily the DStakeToken.\n */\ninterface IDStakeCollateralVault {\n    /**\n     * @notice Calculates the total value of all managed `vault assets` held by the vault,\n     *         denominated in the underlying dStable asset.\n     * @dev This is typically called by the DStakeToken's `totalAssets()` function.\n     * @return dStableValue The total value of managed assets in terms of the dStable asset.\n     */\n    function totalValueInDStable() external view returns (uint256 dStableValue);\n\n    /**\n     * @notice Returns the address of the underlying dStable asset the vault operates with.\n     * @return The address of the dStable asset.\n     */\n    function dStable() external view returns (address);\n\n    /**\n     * @notice The DStakeToken contract address this vault serves.\n     */\n    function dStakeToken() external view returns (address);\n\n    /**\n     * @notice The DStakeRouter contract address allowed to interact.\n     */\n    function router() external view returns (address);\n\n    /**\n     * @notice Returns the vault asset at `index` from the internal supported list.\n     */\n    function supportedAssets(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the entire list of supported vault assets. Convenient for UIs & off-chain analytics.\n     */\n    function getSupportedAssets() external view returns (address[] memory);\n\n    /**\n     * @notice Transfers `amount` of `vaultAsset` from this vault to the `recipient`.\n     * @dev Only callable by the registered router.\n     * @param vaultAsset The address of the vault asset to send.\n     * @param amount The amount to send.\n     * @param recipient The address to receive the asset.\n     */\n    function sendAsset(address vaultAsset, uint256 amount, address recipient) external;\n\n    /**\n     * @notice Sets the address of the DStakeRouter contract.\n     * @dev Only callable by an address with the DEFAULT_ADMIN_ROLE.\n     * @param _newRouter The address of the new router contract.\n     */\n    function setRouter(address _newRouter) external;\n\n    /**\n     * @notice Adds a vault asset to the supported list. Callable only by the router.\n     */\n    function addSupportedAsset(address vaultAsset) external;\n\n    /**\n     * @notice Removes a vault asset from the supported list. Callable only by the router.\n     */\n    function removeSupportedAsset(address vaultAsset) external;\n\n    /**\n     * @notice Emitted when the router address is set.\n     * @param router The address of the new router.\n     */\n    event RouterSet(address indexed router);\n\n    /**\n     * @notice Emitted when a new vault asset is added to the supported list.\n     */\n    event SupportedAssetAdded(address indexed vaultAsset);\n\n    /**\n     * @notice Emitted when a vault asset is removed from the supported list.\n     */\n    event SupportedAssetRemoved(address indexed vaultAsset);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStakeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStakeRouter Interface\n * @notice Defines the external functions of the DStakeRouter required by the DStakeToken\n *         for handling deposits and withdrawals.\n */\ninterface IDStakeRouter {\n    /**\n     * @notice Handles the conversion of deposited dStable asset into a chosen `vaultAsset`\n     *         and informs the collateral vault.\n     * @dev Called by `DStakeToken._deposit()` after the token has received the dStable asset.\n     * @dev The router MUST pull `dStableAmount` from the caller (`DStakeToken`).\n     * @param dStableAmount The amount of dStable asset deposited by the user into the DStakeToken.\n     */\n    function deposit(uint256 dStableAmount) external;\n\n    /**\n     * @notice Handles the conversion of a `vaultAsset` back into the dStable asset for withdrawal.\n     * @dev Called by `DStakeToken._withdraw()`.\n     * @dev The router coordinates pulling the required `vaultAsset` from the collateral vault\n     *      and ensuring the converted dStable asset is sent to the `receiver`.\n     * @param dStableAmount The amount of dStable asset to be withdrawn to the `receiver` (after vault fees).\n     * @param receiver The address that will receive the withdrawn dStable asset.\n     * @param owner The original owner initiating the withdrawal (typically the user burning shares).\n     */\n    function withdraw(uint256 dStableAmount, address receiver, address owner) external;\n}\n"
    },
    "contracts/vaults/rewards_claimable/RewardClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title RewardClaimable\n * @dev Abstract contract for vaults with claimable rewards\n * Implements functionality for claiming and compounding rewards\n */\nabstract contract RewardClaimable is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Roles\n    bytes32 public constant REWARDS_MANAGER_ROLE = keccak256(\"REWARDS_MANAGER_ROLE\");\n\n    // State variables\n    address public treasury;\n    uint256 public treasuryFeeBps;\n    uint256 public exchangeThreshold;\n    address public immutable exchangeAsset;\n    uint256 public immutable maxTreasuryFeeBps;\n\n    // Events\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event TreasuryFeeBpsUpdated(uint256 oldTreasuryFeeBps, uint256 newTreasuryFeeBps);\n    event ExchangeThresholdUpdated(uint256 oldExchangeThreshold, uint256 newExchangeThreshold);\n    event RewardCompounded(address exchangeAsset, uint256 amount, address[] rewardTokens);\n\n    // Custom errors\n    error ExchangeAmountTooLow(uint256 amount, uint256 threshold);\n    error RewardAmountsLengthMismatch(uint256 claimedAmountsLength, uint256 rewardTokensLength);\n    error TreasuryFeeExceedsRewardAmount(uint256 treasuryFee, uint256 rewardAmount);\n    error ZeroExchangeAssetAddress();\n    error ZeroTreasuryAddress();\n    error MaxTreasuryFeeTooHigh(uint256 maxTreasuryFeeBps);\n    error TreasuryFeeTooHigh(uint256 treasuryFeeBps, uint256 maxTreasuryFeeBps);\n    error ZeroExchangeThreshold();\n    error ZeroReceiverAddress();\n    error ZeroRewardTokens();\n\n    /**\n     * @dev Constructor for the RewardClaimable contract\n     * @param _exchangeAsset The address of the exchange asset\n     * @param _treasury The address of the treasury\n     * @param _maxTreasuryFeeBps The maximum treasury fee in basis points (30000 = 3%), where 100 = 1bps (1e2 for decimals)\n     * @param _initialTreasuryFeeBps The initial treasury fee in basis points (100 = 1bps, 10000 = 100bps = 1%)\n     * @param _initialExchangeThreshold The initial minimum threshold amount (in the same unit as the exchange asset)\n     */\n    constructor(\n        address _exchangeAsset,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold\n    ) {\n        if (_exchangeAsset == address(0)) {\n            revert ZeroExchangeAssetAddress();\n        }\n        if (_treasury == address(0)) {\n            revert ZeroTreasuryAddress();\n        }\n        // The fee cannot exceed the reward amount (100%)\n        if (_maxTreasuryFeeBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert MaxTreasuryFeeTooHigh(_maxTreasuryFeeBps);\n        }\n        // The initial fee cannot exceed the max fee, which means cannot be greater than 100% as well\n        if (_initialTreasuryFeeBps > _maxTreasuryFeeBps) {\n            revert TreasuryFeeTooHigh(_initialTreasuryFeeBps, _maxTreasuryFeeBps);\n        }\n        if (_initialExchangeThreshold == 0) {\n            revert ZeroExchangeThreshold();\n        }\n\n        exchangeAsset = _exchangeAsset;\n        treasury = _treasury;\n        maxTreasuryFeeBps = _maxTreasuryFeeBps;\n        treasuryFeeBps = _initialTreasuryFeeBps;\n        exchangeThreshold = _initialExchangeThreshold;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(REWARDS_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Sets the treasury address\n     * @param newTreasury The new treasury address\n     */\n    function setTreasury(address newTreasury) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newTreasury == address(0)) {\n            revert ZeroTreasuryAddress();\n        }\n        address oldTreasury = treasury;\n        treasury = newTreasury;\n\n        emit TreasuryUpdated(oldTreasury, newTreasury);\n    }\n\n    /**\n     * @dev Sets the treasury fee in basis points\n     * @param newTreasuryFeeBps New treasury fee in basis points (100 = 1bps = 0.01%)\n     */\n    function setTreasuryFeeBps(uint256 newTreasuryFeeBps) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newTreasuryFeeBps > maxTreasuryFeeBps) {\n            revert TreasuryFeeTooHigh(newTreasuryFeeBps, maxTreasuryFeeBps);\n        }\n\n        uint256 oldTreasuryFeeBps = treasuryFeeBps;\n        treasuryFeeBps = newTreasuryFeeBps;\n\n        emit TreasuryFeeBpsUpdated(oldTreasuryFeeBps, newTreasuryFeeBps);\n    }\n\n    /**\n     * @dev Sets the minimum threshold for exchange operations\n     * @param newExchangeThreshold New minimum threshold amount\n     */\n    function setExchangeThreshold(uint256 newExchangeThreshold) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newExchangeThreshold == 0) {\n            revert ZeroExchangeThreshold();\n        }\n        uint256 oldExchangeThreshold = exchangeThreshold;\n        exchangeThreshold = newExchangeThreshold;\n\n        emit ExchangeThresholdUpdated(oldExchangeThreshold, newExchangeThreshold);\n    }\n\n    /**\n     * @dev Calculates the treasury fee for a given amount\n     * @param amount The amount to calculate the treasury fee for\n     * @return The treasury fee in the same unit as the amount\n     */\n    function getTreasuryFee(uint256 amount) public view returns (uint256) {\n        return Math.mulDiv(amount, treasuryFeeBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n    }\n\n    /**\n     * @dev Compounds multiple rewards\n     * @param amount The amount to compound\n     * @param rewardTokens The reward tokens to claim\n     * @param receiver The address to receive the compounded rewards\n     */\n    function compoundRewards(\n        uint256 amount,\n        address[] calldata rewardTokens,\n        address receiver\n    ) public virtual nonReentrant {\n        if (amount < exchangeThreshold) {\n            revert ExchangeAmountTooLow(amount, exchangeThreshold);\n        }\n        if (receiver == address(0)) {\n            revert ZeroReceiverAddress();\n        }\n        if (rewardTokens.length == 0) {\n            revert ZeroRewardTokens();\n        }\n\n        // Transfer the exchange asset from the caller to the vault\n        IERC20(exchangeAsset).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Emit the event before the internal call to avoid reentrancy\n        emit RewardCompounded(exchangeAsset, amount, rewardTokens);\n\n        // Claim the rewards\n        uint256[] memory rewardAmounts = _claimRewards(rewardTokens, address(this));\n\n        if (rewardAmounts.length != rewardTokens.length) {\n            revert RewardAmountsLengthMismatch(rewardAmounts.length, rewardTokens.length);\n        }\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewardAmount = rewardAmounts[i];\n            uint256 treasuryFee = getTreasuryFee(rewardAmount);\n\n            // Overflow protection\n            if (treasuryFee > rewardAmount) {\n                revert TreasuryFeeExceedsRewardAmount(treasuryFee, rewardAmount);\n            }\n\n            // Transfer the treasury fee to the treasury\n            IERC20(rewardTokens[i]).safeTransfer(treasury, treasuryFee);\n\n            // Transfer the remaining amount to the caller\n            IERC20(rewardTokens[i]).safeTransfer(receiver, rewardAmount - treasuryFee);\n        }\n\n        // Process the exchange asset deposit\n        _processExchangeAssetDeposit(amount);\n    }\n\n    /**\n     * @dev Claims multiple rewards\n     * @param rewardTokens The reward tokens to claim\n     * @param receiver The address to receive the claimed rewards\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\n     */\n    function _claimRewards(\n        address[] calldata rewardTokens,\n        address receiver\n    ) internal virtual returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @dev Processes the exchange asset deposit from the caller\n     * @param amount The amount of exchange asset to deposit\n     */\n    function _processExchangeAssetDeposit(uint256 amount) internal virtual;\n}\n"
    },
    "contracts/vaults/rewards_claimable/test/MockRewardClaimableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../RewardClaimable.sol\";\n\n/**\n * @title MockRewardClaimableVault\n * @dev Mock implementation of RewardClaimable contract for testing purposes\n */\ncontract MockRewardClaimableVault is RewardClaimable {\n    using SafeERC20 for IERC20;\n\n    // Track deposited amounts for testing\n    mapping(address => uint256) public deposits;\n\n    // Mock reward tokens for testing\n    mapping(address => bool) public rewardTokens;\n    mapping(address => uint256) public rewardTokenEmissionAmount;\n\n    // Mock target pool address\n    address public targetPool;\n    // Mock fake reward pool address\n    address public fakeRewardPool;\n\n    error InsufficientAllowanceFromFakeRewardPool(address token, uint256 allowance, uint256 amount);\n\n    /**\n     * @dev Constructor for the MockRewardClaimableVault contract\n     * @param _exchangeAsset The address of the exchange asset\n     * @param _treasury The address of the treasury\n     * @param _maxTreasuryFeeBps The maximum treasury fee in basis points\n     * @param _initialTreasuryFeeBps The initial treasury fee in basis points\n     * @param _initialExchangeThreshold The initial minimum threshold amount\n     * @param _targetPool The address of the target pool\n     * @param _fakeRewardPool The address of the fake reward pool\n     */\n    constructor(\n        address _exchangeAsset,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold,\n        address _targetPool,\n        address _fakeRewardPool\n    )\n        RewardClaimable(\n            _exchangeAsset,\n            _treasury,\n            _maxTreasuryFeeBps,\n            _initialTreasuryFeeBps,\n            _initialExchangeThreshold\n        )\n    {\n        targetPool = _targetPool;\n        fakeRewardPool = _fakeRewardPool;\n    }\n\n    /**\n     * @dev Adds a reward token to the list of mock reward tokens (for testing purposes)\n     * @param _rewardToken The address of the reward token to add\n     * @param _emissionAmount The emission amount of the reward token each time the vault claims rewards\n     */\n    function addRewardToken(address _rewardToken, uint256 _emissionAmount) external {\n        rewardTokens[_rewardToken] = true;\n\n        require(_emissionAmount > 0, \"Emission amount must be greater than 0\");\n        rewardTokenEmissionAmount[_rewardToken] = _emissionAmount;\n    }\n\n    /**\n     * @dev Public function to expose the internal _claimRewards function for testing\n     */\n    function claimRewards(address[] calldata tokens, address receiver) external {\n        _claimRewards(tokens, receiver);\n    }\n\n    /**\n     * @dev Mocks claiming rewards\n     * @param tokens The reward tokens to claim\n     * @param receiver The address to receive the claimed rewards\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\n     */\n    function _claimRewards(\n        address[] calldata tokens,\n        address receiver\n    ) internal override returns (uint256[] memory rewardAmounts) {\n        rewardAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!rewardTokens[tokens[i]]) {\n                revert(\"Invalid reward token\");\n            }\n\n            // Now, we will drain reward tokens from the fake reward pool to mimic the behavior of the real vault\n            // claiming the rewards\n            uint256 amount = rewardTokenEmissionAmount[tokens[i]];\n\n            // Make sure having enough allowance to transfer from the fake reward pool\n            uint256 allowance = IERC20(tokens[i]).allowance(fakeRewardPool, address(this));\n            if (allowance < amount) {\n                revert InsufficientAllowanceFromFakeRewardPool(tokens[i], allowance, amount);\n            }\n\n            // Transfer the tokens to the receiver\n            IERC20(tokens[i]).safeTransferFrom(fakeRewardPool, receiver, amount);\n\n            rewardAmounts[i] = amount;\n        }\n\n        return rewardAmounts;\n    }\n\n    /**\n     * @dev Mocks processing the exchange asset deposit from the caller\n     * @param amount The amount of exchange asset to deposit\n     */\n    function _processExchangeAssetDeposit(uint256 amount) internal virtual override {\n        deposits[exchangeAsset] += amount;\n        // Transfer tokens from contract to the target pool (tokens are already in the contract)\n        IERC20(exchangeAsset).safeTransfer(targetPool, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
