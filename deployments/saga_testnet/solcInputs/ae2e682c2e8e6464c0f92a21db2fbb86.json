{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(\n            value <= type(uint224).max,\n            \"SafeCast: value doesn't fit in 224 bits\"\n        );\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(\n            value <= type(uint128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(\n            value <= type(uint96).max,\n            \"SafeCast: value doesn't fit in 96 bits\"\n        );\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(\n            value <= type(uint64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(\n            value <= type(uint32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(\n            value <= type(uint16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(\n            value <= type(uint8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(\n            value >= type(int128).min && value <= type(int128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(\n            value >= type(int64).min && value <= type(int64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(\n            value >= type(int32).min && value <= type(int32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(\n            value >= type(int16).min && value <= type(int16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(\n            value >= type(int8).min && value <= type(int8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dlend/core/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IPriceOracleGetter} from \"./IPriceOracleGetter.sol\";\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n    /**\n     * @dev Emitted after the base currency is set\n     * @param baseCurrency The base currency of used for price quotes\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    event BaseCurrencySet(\n        address indexed baseCurrency,\n        uint256 baseCurrencyUnit\n    );\n\n    /**\n     * @dev Emitted after the price source of an asset is updated\n     * @param asset The address of the asset\n     * @param source The price source of the asset\n     */\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n\n    /**\n     * @dev Emitted after the address of fallback oracle is updated\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    /**\n     * @notice Returns the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER()\n        external\n        view\n        returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Sets or replaces price sources of assets\n     * @param assets The addresses of the assets\n     * @param sources The addresses of the price sources\n     */\n    function setAssetSources(\n        address[] calldata assets,\n        address[] calldata sources\n    ) external;\n\n    /**\n     * @notice Sets the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function setFallbackOracle(address fallbackOracle) external;\n\n    /**\n     * @notice Returns a list of prices from a list of assets addresses\n     * @param assets The list of assets addresses\n     * @return The prices of the given assets\n     */\n    function getAssetsPrices(\n        address[] calldata assets\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns the address of the source for an asset address\n     * @param asset The address of the asset\n     * @return The address of the source\n     */\n    function getSourceOfAsset(address asset) external view returns (address);\n\n    /**\n     * @notice Returns the address of the fallback oracle\n     * @return The address of the fallback oracle\n     */\n    function getFallbackOracle() external view returns (address);\n}\n"
    },
    "contracts/dlend/core/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @title IERC20WithPermit\n * @author Aave\n * @notice Interface for the permit function (EIP-2612)\n */\ninterface IERC20WithPermit is IERC20 {\n    /**\n     * @notice Allow passing a signed message to approve spending\n     * @dev implements the permit function as for\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner The owner of the funds\n     * @param spender The spender\n     * @param value The amount\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v Signature param\n     * @param s Signature param\n     * @param r Signature param\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../protocol/libraries/types/DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n    /**\n     * @dev Emitted on mintUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n     * @param amount The amount of supplied assets\n     * @param referralCode The referral code used\n     */\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param backer The address paying for the backing\n     * @param amount The amount added as backing\n     * @param fee The amount paid in fees\n     */\n    event BackUnbacked(\n        address indexed reserve,\n        address indexed backer,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /**\n     * @dev Emitted on supply()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n     * @param amount The amount supplied\n     * @param referralCode The referral code used\n     */\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlying asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to The address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n     * @param referralCode The referral code used\n     */\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n     */\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    event SwapBorrowRateMode(\n        address indexed reserve,\n        address indexed user,\n        DataTypes.InterestRateMode interestRateMode\n    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n     * @param asset The address of the underlying asset of the reserve\n     * @param totalDebt The total isolation mode debt for the reserve\n     */\n    event IsolationModeTotalDebtUpdated(\n        address indexed asset,\n        uint256 totalDebt\n    );\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n     * @param user The address of the user\n     * @param categoryId The category id\n     */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     */\n    event RebalanceStableBorrowRate(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     */\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The next liquidity rate\n     * @param stableBorrowRate The next stable borrow rate\n     * @param variableBorrowRate The next variable borrow rate\n     * @param liquidityIndex The next liquidity index\n     * @param variableBorrowIndex The next variable borrow index\n     */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n     * @param reserve The address of the reserve\n     * @param amountMinted The amount minted to the treasury\n     */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n     * @param asset The address of the underlying asset to mint\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function mintUnbacked(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n     * @param asset The address of the underlying asset to back\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @return The backed amount\n     */\n    function backUnbacked(\n        address asset,\n        uint256 amount,\n        uint256 fee\n    ) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to The address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     */\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     */\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     */\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n     * equivalent debt tokens\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n     * balance is not enough to cover the whole debt\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return The final amount repaid\n     */\n    function repayWithATokens(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    function swapBorrowRateMode(\n        address asset,\n        uint256 interestRateMode\n    ) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n     * @param asset The address of the underlying asset supplied\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     */\n    function setUserUseReserveAsCollateral(\n        address asset,\n        bool useAsCollateral\n    ) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts of the assets being flash-borrowed\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n     * @param asset The address of the asset being flash-borrowed\n     * @param amount The amount of the asset being flash-borrowed\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n     * interest rate strategy\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param rateStrategyAddress The address of the interest rate strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param configuration The new configuration bitmap\n     */\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     */\n    function getConfiguration(\n        address asset\n    ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     */\n    function getUserConfiguration(\n        address user\n    ) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n     * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\n     * combination with variable debt supply/balances.\n     * If using this function externally, consider that is possible to have an increasing normalized\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\n     * (e.g. only updates with non-zero variable debt supply)\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state and configuration data of the reserve\n     */\n    function getReserveData(\n        address asset\n    ) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n     * @dev Only callable by the overlying aToken of the `asset`\n     * @param asset The address of the underlying asset of the aToken\n     * @param from The user from which the aTokens are transferred\n     * @param to The user receiving the aTokens\n     * @param amount The amount being transferred/withdrawn\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\n     */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n     * @dev It does not include dropped reserves\n     * @return The addresses of the underlying assets of the initialized reserves\n     */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n     * @return The address of the reserve associated with id\n     */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Returns the PoolAddressesProvider connected to this contract\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER()\n        external\n        view\n        returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n     */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra, one time accumulated interest\n     * - A part is collected by the protocol treasury\n     * @dev The total premium is calculated on the total borrowed amount\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n     * @dev Only callable by the PoolConfigurator contract\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n     */\n    function updateFlashloanPremiums(\n        uint128 flashLoanPremiumTotal,\n        uint128 flashLoanPremiumToProtocol\n    ) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n     * The category 0 is reserved as it's the default for volatile assets\n     * @param id The id of the category\n     * @param config The configuration of the category\n     */\n    function configureEModeCategory(\n        uint8 id,\n        DataTypes.EModeCategory memory config\n    ) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n     * @param id The id of the category\n     * @return The configuration data of the category\n     */\n    function getEModeCategoryData(\n        uint8 id\n    ) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n     * @param categoryId The id of the category\n     */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n     * @param user The address of the user\n     * @return The eMode id\n     */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n     * @return The percentage of available liquidity to borrow, expressed in bps\n     */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n     * @return The total fee on flashloans\n     */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n     * @return The bridge fee sent to the protocol treasury\n     */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n     * @return The flashloan fee sent to the protocol treasury\n     */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n     * @return The maximum number of reserves supported\n     */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @dev Deprecated: Use the `supply` function instead\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed implementationAddress\n    );\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(\n        bytes32 indexed id,\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddressFromID(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(\n        bytes32 id,\n        address newImplementationAddress\n    ) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param caller The address performing the mint\n     * @param onBehalfOf The address of the user that will receive the minted tokens\n     * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n     * @param index The next liquidity index of the reserve\n     */\n    event Mint(\n        address indexed caller,\n        address indexed onBehalfOf,\n        uint256 value,\n        uint256 balanceIncrease,\n        uint256 index\n    );\n\n    /**\n     * @dev Emitted after the burn action\n     * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n     * @param from The address from which the tokens will be burned\n     * @param target The address that will receive the underlying, if any\n     * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n     * @param index The next liquidity index of the reserve\n     */\n    event Burn(\n        address indexed from,\n        address indexed target,\n        uint256 value,\n        uint256 balanceIncrease,\n        uint256 index\n    );\n\n    /**\n     * @notice Returns the scaled balance of the user.\n     * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n     * at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     */\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled total supply\n     */\n    function getScaledUserBalanceAndSupply(\n        address user\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n     * @return The scaled total supply\n     */\n    function scaledTotalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns last index interest was accrued to the user's balance\n     * @param user The address of the user\n     * @return The last index interest was accrued to the user's balance, expressed in ray\n     */\n    function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n    uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n    uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n    uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n    uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n    uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n    uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n    uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n    uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n    uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n    uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n    uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n    uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n    uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n    uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n    uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n    uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n    uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n    uint256 internal constant MAX_VALID_LTV = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n    uint256 internal constant MAX_VALID_DECIMALS = 255;\n    uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n    uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n    uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n    uint256 public constant DEBT_CEILING_DECIMALS = 2;\n    uint16 public constant MAX_RESERVES_COUNT = 128;\n\n    /**\n     * @notice Sets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @param ltv The new ltv\n     */\n    function setLtv(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 ltv\n    ) internal pure {\n        require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n        self.data = (self.data & LTV_MASK) | ltv;\n    }\n\n    /**\n     * @notice Gets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @return The loan to value\n     */\n    function getLtv(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return self.data & ~LTV_MASK;\n    }\n\n    /**\n     * @notice Sets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @param threshold The new liquidation threshold\n     */\n    function setLiquidationThreshold(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 threshold\n    ) internal pure {\n        require(\n            threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,\n            Errors.INVALID_LIQ_THRESHOLD\n        );\n\n        self.data =\n            (self.data & LIQUIDATION_THRESHOLD_MASK) |\n            (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation threshold\n     */\n    function getLiquidationThreshold(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\n            LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @param bonus The new liquidation bonus\n     */\n    function setLiquidationBonus(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 bonus\n    ) internal pure {\n        require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n        self.data =\n            (self.data & LIQUIDATION_BONUS_MASK) |\n            (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation bonus\n     */\n    function getLiquidationBonus(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~LIQUIDATION_BONUS_MASK) >>\n            LIQUIDATION_BONUS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @param decimals The decimals\n     */\n    function setDecimals(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 decimals\n    ) internal pure {\n        require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n        self.data =\n            (self.data & DECIMALS_MASK) |\n            (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @return The decimals of the asset\n     */\n    function getDecimals(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the active state of the reserve\n     * @param self The reserve configuration\n     * @param active The active state\n     */\n    function setActive(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool active\n    ) internal pure {\n        self.data =\n            (self.data & ACTIVE_MASK) |\n            (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the active state of the reserve\n     * @param self The reserve configuration\n     * @return The active state\n     */\n    function getActive(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~ACTIVE_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @param frozen The frozen state\n     */\n    function setFrozen(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool frozen\n    ) internal pure {\n        self.data =\n            (self.data & FROZEN_MASK) |\n            (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @return The frozen state\n     */\n    function getFrozen(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~FROZEN_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the paused state of the reserve\n     * @param self The reserve configuration\n     * @param paused The paused state\n     */\n    function setPaused(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool paused\n    ) internal pure {\n        self.data =\n            (self.data & PAUSED_MASK) |\n            (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the paused state of the reserve\n     * @param self The reserve configuration\n     * @return The paused state\n     */\n    function getPaused(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~PAUSED_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the borrowable in isolation flag for the reserve.\n     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n     * amount will be accumulated in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @param borrowable True if the asset is borrowable\n     */\n    function setBorrowableInIsolation(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool borrowable\n    ) internal pure {\n        self.data =\n            (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n            (uint256(borrowable ? 1 : 0) <<\n                BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowable in isolation flag for the reserve.\n     * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n     * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @return The borrowable in isolation flag\n     */\n    function getBorrowableInIsolation(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @param siloed True if the asset is siloed\n     */\n    function setSiloedBorrowing(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool siloed\n    ) internal pure {\n        self.data =\n            (self.data & SILOED_BORROWING_MASK) |\n            (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @return The siloed borrowing flag\n     */\n    function getSiloedBorrowing(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~SILOED_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the borrowing needs to be enabled, false otherwise\n     */\n    function setBorrowingEnabled(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool enabled\n    ) internal pure {\n        self.data =\n            (self.data & BORROWING_MASK) |\n            (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The borrowing state\n     */\n    function getBorrowingEnabled(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables stable rate borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n     */\n    function setStableRateBorrowingEnabled(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool enabled\n    ) internal pure {\n        self.data =\n            (self.data & STABLE_BORROWING_MASK) |\n            (uint256(enabled ? 1 : 0) <<\n                STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the stable rate borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The stable rate borrowing state\n     */\n    function getStableRateBorrowingEnabled(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @param reserveFactor The reserve factor\n     */\n    function setReserveFactor(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 reserveFactor\n    ) internal pure {\n        require(\n            reserveFactor <= MAX_VALID_RESERVE_FACTOR,\n            Errors.INVALID_RESERVE_FACTOR\n        );\n\n        self.data =\n            (self.data & RESERVE_FACTOR_MASK) |\n            (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @return The reserve factor\n     */\n    function getReserveFactor(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~RESERVE_FACTOR_MASK) >>\n            RESERVE_FACTOR_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @param borrowCap The borrow cap\n     */\n    function setBorrowCap(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 borrowCap\n    ) internal pure {\n        require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n        self.data =\n            (self.data & BORROW_CAP_MASK) |\n            (borrowCap << BORROW_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @return The borrow cap\n     */\n    function getBorrowCap(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @param supplyCap The supply cap\n     */\n    function setSupplyCap(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 supplyCap\n    ) internal pure {\n        require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n        self.data =\n            (self.data & SUPPLY_CAP_MASK) |\n            (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @return The supply cap\n     */\n    function getSupplyCap(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the debt ceiling in isolation mode for the asset\n     * @param self The reserve configuration\n     * @param ceiling The maximum debt ceiling for the asset\n     */\n    function setDebtCeiling(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 ceiling\n    ) internal pure {\n        require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n        self.data =\n            (self.data & DEBT_CEILING_MASK) |\n            (ceiling << DEBT_CEILING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n     * @param self The reserve configuration\n     * @return The debt ceiling (0 = isolation mode disabled)\n     */\n    function getDebtCeiling(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation protocol fee of the reserve\n     * @param self The reserve configuration\n     * @param liquidationProtocolFee The liquidation protocol fee\n     */\n    function setLiquidationProtocolFee(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 liquidationProtocolFee\n    ) internal pure {\n        require(\n            liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n            Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n        );\n\n        self.data =\n            (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n            (liquidationProtocolFee <<\n                LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the liquidation protocol fee\n     * @param self The reserve configuration\n     * @return The liquidation protocol fee\n     */\n    function getLiquidationProtocolFee(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >>\n            LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @param unbackedMintCap The unbacked mint cap\n     */\n    function setUnbackedMintCap(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 unbackedMintCap\n    ) internal pure {\n        require(\n            unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP,\n            Errors.INVALID_UNBACKED_MINT_CAP\n        );\n\n        self.data =\n            (self.data & UNBACKED_MINT_CAP_MASK) |\n            (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @return The unbacked mint cap\n     */\n    function getUnbackedMintCap(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~UNBACKED_MINT_CAP_MASK) >>\n            UNBACKED_MINT_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the eMode asset category\n     * @param self The reserve configuration\n     * @param category The asset category when the user selects the eMode\n     */\n    function setEModeCategory(\n        DataTypes.ReserveConfigurationMap memory self,\n        uint256 category\n    ) internal pure {\n        require(\n            category <= MAX_VALID_EMODE_CATEGORY,\n            Errors.INVALID_EMODE_CATEGORY\n        );\n\n        self.data =\n            (self.data & EMODE_CATEGORY_MASK) |\n            (category << EMODE_CATEGORY_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the eMode asset category\n     * @param self The reserve configuration\n     * @return The eMode category for the asset\n     */\n    function getEModeCategory(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256) {\n        return\n            (self.data & ~EMODE_CATEGORY_MASK) >>\n            EMODE_CATEGORY_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n     */\n    function setFlashLoanEnabled(\n        DataTypes.ReserveConfigurationMap memory self,\n        bool flashLoanEnabled\n    ) internal pure {\n        self.data =\n            (self.data & FLASHLOAN_ENABLED_MASK) |\n            (uint256(flashLoanEnabled ? 1 : 0) <<\n                FLASHLOAN_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @return The flashloanable flag\n     */\n    function getFlashLoanEnabled(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool) {\n        return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n    }\n\n    /**\n     * @notice Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flag representing active\n     * @return The state flag representing frozen\n     * @return The state flag representing borrowing enabled\n     * @return The state flag representing stableRateBorrowing enabled\n     * @return The state flag representing paused\n     */\n    function getFlags(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (bool, bool, bool, bool, bool) {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~ACTIVE_MASK) != 0,\n            (dataLocal & ~FROZEN_MASK) != 0,\n            (dataLocal & ~BORROWING_MASK) != 0,\n            (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n            (dataLocal & ~PAUSED_MASK) != 0\n        );\n    }\n\n    /**\n     * @notice Gets the configuration parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing ltv\n     * @return The state param representing liquidation threshold\n     * @return The state param representing liquidation bonus\n     * @return The state param representing reserve decimals\n     * @return The state param representing reserve factor\n     * @return The state param representing eMode category\n     */\n    function getParams(\n        DataTypes.ReserveConfigurationMap memory self\n    )\n        internal\n        pure\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        uint256 dataLocal = self.data;\n\n        return (\n            dataLocal & ~LTV_MASK,\n            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\n                LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n            (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\n                LIQUIDATION_BONUS_START_BIT_POSITION,\n            (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n            (dataLocal & ~RESERVE_FACTOR_MASK) >>\n                RESERVE_FACTOR_START_BIT_POSITION,\n            (dataLocal & ~EMODE_CATEGORY_MASK) >>\n                EMODE_CATEGORY_START_BIT_POSITION\n        );\n    }\n\n    /**\n     * @notice Gets the caps parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing borrow cap\n     * @return The state param representing supply cap.\n     */\n    function getCaps(\n        DataTypes.ReserveConfigurationMap memory self\n    ) internal pure returns (uint256, uint256) {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n            (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n        );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n    string public constant CALLER_NOT_POOL_ADMIN = \"1\"; // 'The caller of the function is not a pool admin'\n    string public constant CALLER_NOT_EMERGENCY_ADMIN = \"2\"; // 'The caller of the function is not an emergency admin'\n    string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \"3\"; // 'The caller of the function is not a pool or emergency admin'\n    string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \"4\"; // 'The caller of the function is not a risk or pool admin'\n    string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \"5\"; // 'The caller of the function is not an asset listing or pool admin'\n    string public constant CALLER_NOT_BRIDGE = \"6\"; // 'The caller of the function is not a bridge'\n    string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \"7\"; // 'Pool addresses provider is not registered'\n    string public constant INVALID_ADDRESSES_PROVIDER_ID = \"8\"; // 'Invalid id for the pool addresses provider'\n    string public constant NOT_CONTRACT = \"9\"; // 'Address is not a contract'\n    string public constant CALLER_NOT_POOL_CONFIGURATOR = \"10\"; // 'The caller of the function is not the pool configurator'\n    string public constant CALLER_NOT_ATOKEN = \"11\"; // 'The caller of the function is not an AToken'\n    string public constant INVALID_ADDRESSES_PROVIDER = \"12\"; // 'The address of the pool addresses provider is invalid'\n    string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \"13\"; // 'Invalid return value of the flashloan executor function'\n    string public constant RESERVE_ALREADY_ADDED = \"14\"; // 'Reserve has already been added to reserve list'\n    string public constant NO_MORE_RESERVES_ALLOWED = \"15\"; // 'Maximum amount of reserves in the pool reached'\n    string public constant EMODE_CATEGORY_RESERVED = \"16\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n    string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \"17\"; // 'Invalid eMode category assignment to asset'\n    string public constant RESERVE_LIQUIDITY_NOT_ZERO = \"18\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant FLASHLOAN_PREMIUM_INVALID = \"19\"; // 'Invalid flashloan premium'\n    string public constant INVALID_RESERVE_PARAMS = \"20\"; // 'Invalid risk parameters for the reserve'\n    string public constant INVALID_EMODE_CATEGORY_PARAMS = \"21\"; // 'Invalid risk parameters for the eMode category'\n    string public constant BRIDGE_PROTOCOL_FEE_INVALID = \"22\"; // 'Invalid bridge protocol fee'\n    string public constant CALLER_MUST_BE_POOL = \"23\"; // 'The caller of this function must be a pool'\n    string public constant INVALID_MINT_AMOUNT = \"24\"; // 'Invalid amount to mint'\n    string public constant INVALID_BURN_AMOUNT = \"25\"; // 'Invalid amount to burn'\n    string public constant INVALID_AMOUNT = \"26\"; // 'Amount must be greater than 0'\n    string public constant RESERVE_INACTIVE = \"27\"; // 'Action requires an active reserve'\n    string public constant RESERVE_FROZEN = \"28\"; // 'Action cannot be performed because the reserve is frozen'\n    string public constant RESERVE_PAUSED = \"29\"; // 'Action cannot be performed because the reserve is paused'\n    string public constant BORROWING_NOT_ENABLED = \"30\"; // 'Borrowing is not enabled'\n    string public constant STABLE_BORROWING_NOT_ENABLED = \"31\"; // 'Stable borrowing is not enabled'\n    string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"32\"; // 'User cannot withdraw more than the available balance'\n    string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \"33\"; // 'Invalid interest rate mode selected'\n    string public constant COLLATERAL_BALANCE_IS_ZERO = \"34\"; // 'The collateral balance is 0'\n    string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD =\n        \"35\"; // 'Health factor is lesser than the liquidation threshold'\n    string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \"36\"; // 'There is not enough collateral to cover a new borrow'\n    string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"37\"; // 'Collateral is (mostly) the same currency that is being borrowed'\n    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"38\"; // 'The requested amount is greater than the max loan size in stable rate mode'\n    string public constant NO_DEBT_OF_SELECTED_TYPE = \"39\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n    string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"40\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\n    string public constant NO_OUTSTANDING_STABLE_DEBT = \"41\"; // 'User does not have outstanding stable rate debt on this reserve'\n    string public constant NO_OUTSTANDING_VARIABLE_DEBT = \"42\"; // 'User does not have outstanding variable rate debt on this reserve'\n    string public constant UNDERLYING_BALANCE_ZERO = \"43\"; // 'The underlying balance needs to be greater than 0'\n    string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"44\"; // 'Interest rate rebalance conditions were not met'\n    string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"45\"; // 'Health factor is not below the threshold'\n    string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \"46\"; // 'The collateral chosen cannot be liquidated'\n    string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"47\"; // 'User did not borrow the specified currency'\n    string public constant INCONSISTENT_FLASHLOAN_PARAMS = \"49\"; // 'Inconsistent flashloan parameters'\n    string public constant BORROW_CAP_EXCEEDED = \"50\"; // 'Borrow cap is exceeded'\n    string public constant SUPPLY_CAP_EXCEEDED = \"51\"; // 'Supply cap is exceeded'\n    string public constant UNBACKED_MINT_CAP_EXCEEDED = \"52\"; // 'Unbacked mint cap is exceeded'\n    string public constant DEBT_CEILING_EXCEEDED = \"53\"; // 'Debt ceiling is exceeded'\n    string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = \"54\"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n    string public constant STABLE_DEBT_NOT_ZERO = \"55\"; // 'Stable debt supply is not zero'\n    string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \"56\"; // 'Variable debt supply is not zero'\n    string public constant LTV_VALIDATION_FAILED = \"57\"; // 'Ltv validation failed'\n    string public constant INCONSISTENT_EMODE_CATEGORY = \"58\"; // 'Inconsistent eMode category'\n    string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \"59\"; // 'Price oracle sentinel validation failed'\n    string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \"60\"; // 'Asset is not borrowable in isolation mode'\n    string public constant RESERVE_ALREADY_INITIALIZED = \"61\"; // 'Reserve has already been initialized'\n    string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = \"62\"; // 'User is in isolation mode or ltv is zero'\n    string public constant INVALID_LTV = \"63\"; // 'Invalid ltv parameter for the reserve'\n    string public constant INVALID_LIQ_THRESHOLD = \"64\"; // 'Invalid liquidity threshold parameter for the reserve'\n    string public constant INVALID_LIQ_BONUS = \"65\"; // 'Invalid liquidity bonus parameter for the reserve'\n    string public constant INVALID_DECIMALS = \"66\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\n    string public constant INVALID_RESERVE_FACTOR = \"67\"; // 'Invalid reserve factor parameter for the reserve'\n    string public constant INVALID_BORROW_CAP = \"68\"; // 'Invalid borrow cap for the reserve'\n    string public constant INVALID_SUPPLY_CAP = \"69\"; // 'Invalid supply cap for the reserve'\n    string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \"70\"; // 'Invalid liquidation protocol fee for the reserve'\n    string public constant INVALID_EMODE_CATEGORY = \"71\"; // 'Invalid eMode category for the reserve'\n    string public constant INVALID_UNBACKED_MINT_CAP = \"72\"; // 'Invalid unbacked mint cap for the reserve'\n    string public constant INVALID_DEBT_CEILING = \"73\"; // 'Invalid debt ceiling for the reserve\n    string public constant INVALID_RESERVE_INDEX = \"74\"; // 'Invalid reserve index'\n    string public constant ACL_ADMIN_CANNOT_BE_ZERO = \"75\"; // 'ACL admin cannot be set to the zero address'\n    string public constant INCONSISTENT_PARAMS_LENGTH = \"76\"; // 'Array parameters that should be equal length are not'\n    string public constant ZERO_ADDRESS_NOT_VALID = \"77\"; // 'Zero address not valid'\n    string public constant INVALID_EXPIRATION = \"78\"; // 'Invalid expiration'\n    string public constant INVALID_SIGNATURE = \"79\"; // 'Invalid signature'\n    string public constant OPERATION_NOT_SUPPORTED = \"80\"; // 'Operation not supported'\n    string public constant DEBT_CEILING_NOT_ZERO = \"81\"; // 'Debt ceiling is not zero'\n    string public constant ASSET_NOT_LISTED = \"82\"; // 'Asset is not listed'\n    string public constant INVALID_OPTIMAL_USAGE_RATIO = \"83\"; // 'Invalid optimal usage ratio'\n    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \"84\"; // 'Invalid optimal stable to total debt ratio'\n    string public constant UNDERLYING_CANNOT_BE_RESCUED = \"85\"; // 'The underlying asset cannot be rescued'\n    string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \"86\"; // 'Reserve has already been added to reserve list'\n    string public constant POOL_ADDRESSES_DO_NOT_MATCH = \"87\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n    string public constant STABLE_BORROWING_ENABLED = \"88\"; // 'Stable borrowing is enabled'\n    string public constant SILOED_BORROWING_VIOLATION = \"89\"; // 'User is trying to borrow multiple assets including a siloed one'\n    string public constant RESERVE_DEBT_NOT_ZERO = \"90\"; // the total debt of the reserve needs to be 0\n    string public constant FLASHLOAN_DISABLED = \"91\"; // FlashLoaning for this asset is disabled\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {WadRayMath} from \"./WadRayMath.sol\";\n\n/**\n * @title MathUtils library\n * @author Aave\n * @notice Provides functions to perform linear and compounded interest calculations\n */\nlibrary MathUtils {\n    using WadRayMath for uint256;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\n     */\n    function calculateLinearInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp\n    ) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 result = rate *\n            (block.timestamp - uint256(lastUpdateTimestamp));\n        unchecked {\n            result = result / SECONDS_PER_YEAR;\n        }\n\n        return WadRayMath.RAY + result;\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great\n     * gas cost reductions. The whitepaper contains reference to the approximation and a table showing the margin of\n     * error per different time periods\n     *\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     */\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp,\n        uint256 currentTimestamp\n    ) internal pure returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRayMath.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo =\n                rate.rayMul(rate) /\n                (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return\n            WadRayMath.RAY +\n            (rate * exp) /\n            SECONDS_PER_YEAR +\n            secondTerm +\n            thirdTerm;\n    }\n\n    /**\n     * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n     * @param rate The interest rate (in ray)\n     * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n     * @return The interest rate compounded between lastUpdateTimestamp and current block timestamp, in ray\n     */\n    function calculateCompoundedInterest(\n        uint256 rate,\n        uint40 lastUpdateTimestamp\n    ) internal view returns (uint256) {\n        return\n            calculateCompoundedInterest(\n                rate,\n                lastUpdateTimestamp,\n                block.timestamp\n            );\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     */\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     */\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(\n                iszero(b),\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     */\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     */\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(\n                iszero(b),\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     */\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     */\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62: siloed borrowing enabled\n        //bit 63: flashloaning enabled\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n    }\n\n    struct EModeCategory {\n        // each eMode category has a custom ltv and liquidation threshold\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n        address priceSource;\n        string label;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currPrincipalStableDebt;\n        uint256 currAvgStableBorrowRate;\n        uint256 currTotalStableDebt;\n        uint256 nextAvgStableBorrowRate;\n        uint256 nextTotalStableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n        uint40 stableDebtLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidationCallParams {\n        uint256 reservesCount;\n        uint256 debtToCover;\n        address collateralAsset;\n        address debtAsset;\n        address user;\n        bool receiveAToken;\n        address priceOracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        address onBehalfOf;\n        bool useATokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ExecuteSetUserEModeParams {\n        uint256 reservesCount;\n        address oracle;\n        uint8 categoryId;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n        uint8 fromEModeCategory;\n    }\n\n    struct FlashloanParams {\n        address receiverAddress;\n        address[] assets;\n        uint256[] amounts;\n        uint256[] interestRateModes;\n        address onBehalfOf;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address addressesProvider;\n        uint8 userEModeCategory;\n        bool isAuthorizedFlashBorrower;\n    }\n\n    struct FlashloanSimpleParams {\n        address receiverAddress;\n        address asset;\n        uint256 amount;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n    }\n\n    struct FlashLoanRepaymentParams {\n        uint256 amount;\n        uint256 totalPremium;\n        uint256 flashLoanPremiumToProtocol;\n        address asset;\n        address receiverAddress;\n        uint16 referralCode;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint256 maxStableLoanPercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n        bool isolationModeActive;\n        address isolationModeCollateralAddress;\n        uint256 isolationModeDebtCeiling;\n    }\n\n    struct ValidateLiquidationCallParams {\n        ReserveCache debtReserveCache;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        address priceOracleSentinel;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 unbacked;\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 averageStableBorrowRate;\n        uint256 reserveFactor;\n        address reserve;\n        address aToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address aTokenAddress;\n        address stableDebtAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IAaveOracle} from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport {IRewardsDistributor} from \"./IRewardsDistributor.sol\";\nimport {ITransferStrategyBase} from \"./ITransferStrategyBase.sol\";\nimport {RewardsDataTypes} from \"../libraries/RewardsDataTypes.sol\";\n\n/**\n * @title IRewardsController\n * @author Aave\n * @notice Defines the basic interface for a Rewards Controller.\n */\ninterface IRewardsController is IRewardsDistributor {\n    /**\n     * @dev Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @dev Emitted when rewards are claimed\n     * @param user The address of the user rewards has been claimed on behalf of\n     * @param reward The address of the token reward is claimed\n     * @param to The address of the receiver of the rewards\n     * @param claimer The address of the claimer\n     * @param amount The amount of rewards claimed\n     */\n    event RewardsClaimed(\n        address indexed user,\n        address indexed reward,\n        address indexed to,\n        address claimer,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a transfer strategy is installed for the reward distribution\n     * @param reward The address of the token reward\n     * @param transferStrategy The address of TransferStrategy contract\n     */\n    event TransferStrategyInstalled(\n        address indexed reward,\n        address indexed transferStrategy\n    );\n\n    /**\n     * @dev Emitted when the reward oracle is updated\n     * @param reward The address of the token reward\n     * @param rewardOracle The address of oracle\n     */\n    event RewardOracleUpdated(\n        address indexed reward,\n        address indexed rewardOracle\n    );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Sets a TransferStrategy logic contract that determines the logic of the rewards transfer\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the TransferStrategy logic contract\n     */\n    function setTransferStrategy(\n        address reward,\n        ITransferStrategyBase transferStrategy\n    ) external;\n\n    /**\n     * @dev Sets an Aave Oracle contract to enforce rewards with a source of value.\n     * @notice At the moment of reward configuration, the Incentives Controller performs\n     * a check to see if the reward asset oracle is compatible with IAaveOracle interface.\n     * This check is enforced for integrators to be able to show incentives at\n     * the current Aave UI without the need to setup an external price registry\n     * @param reward The address of the reward to set the price aggregator\n     * @param rewardOracle The address of price aggregator that follows IAaveOracle interface\n     */\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external;\n\n    /**\n     * @dev Get the price aggregator oracle address\n     * @param reward The address of the reward\n     * @return The price oracle of the reward\n     */\n    function getRewardOracle(address reward) external view returns (address);\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Returns the Transfer Strategy implementation contract address being used for a reward address\n     * @param reward The address of the reward\n     * @return The address of the TransferStrategy contract\n     */\n    function getTransferStrategy(\n        address reward\n    ) external view returns (address);\n\n    /**\n     * @dev Configure assets to incentivize with an emission of rewards per second until the end of distribution.\n     * @param config The assets configuration input, the list of structs contains the following fields:\n     *   uint104 emissionPerSecond: The emission per second following rewards unit decimals.\n     *   uint256 totalSupply: The total supply of the asset to incentivize\n     *   uint40 distributionEnd: The end of the distribution of the incentives for an asset\n     *   address asset: The asset address to incentivize\n     *   address reward: The reward token address\n     *   ITransferStrategy transferStrategy: The TransferStrategy address with the install hook and claim logic.\n     *   IAaveOracle rewardOracle: The Price Oracle of a reward to visualize the incentives at the UI Frontend.\n     */\n    function configureAssets(\n        RewardsDataTypes.RewardsConfigInput[] memory config\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n     * @dev The units of `totalSupply` and `userBalance` should be the same.\n     * @param user The address of the user whose asset balance has changed\n     * @param totalSupply The total supply of the asset prior to user balance change\n     * @param userBalance The previous user balance prior to balance change\n     **/\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance\n    ) external;\n\n    /**\n     * @dev Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The\n     * caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardList\"\n     **/\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Recieve more fund from the user to existing reward\n     * @param reward The reward address is being distributed\n     * @param amount The token amount is being funded\n     * @param from The address of the one who funds the rewards\n     */\n    function depositRewardFrom(\n        address reward,\n        uint256 amount,\n        address from\n    ) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IRewardsDistributor\n * @author Aave\n * @notice Defines the basic interface for a Rewards Distributor.\n */\ninterface IRewardsDistributor {\n    /**\n     * @dev Emitted when the configuration of the rewards of an asset is updated.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param oldEmission The old emissions per second value of the reward distribution\n     * @param newEmission The new emissions per second value of the reward distribution\n     * @param oldDistributionEnd The old end timestamp of the reward distribution\n     * @param newDistributionEnd The new end timestamp of the reward distribution\n     * @param assetIndex The index of the asset distribution\n     */\n    event AssetConfigUpdated(\n        address indexed asset,\n        address indexed reward,\n        uint256 oldEmission,\n        uint256 newEmission,\n        uint256 oldDistributionEnd,\n        uint256 newDistributionEnd,\n        uint256 assetIndex\n    );\n\n    /**\n     * @dev Emitted when rewards of an asset are accrued on behalf of a user.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param user The address of the user that rewards are accrued on behalf of\n     * @param assetIndex The index of the asset distribution\n     * @param userIndex The index of the asset distribution on behalf of the user\n     * @param rewardsAccrued The amount of rewards accrued\n     */\n    event Accrued(\n        address indexed asset,\n        address indexed reward,\n        address indexed user,\n        uint256 assetIndex,\n        uint256 userIndex,\n        uint256 rewardsAccrued\n    );\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param asset The asset to incentivize\n     * @param reward The reward token that incentives the asset\n     * @param newDistributionEnd The end date of the incentivization, in unix time format\n     **/\n    function setDistributionEnd(\n        address asset,\n        address reward,\n        uint32 newDistributionEnd\n    ) external;\n\n    /**\n     * @dev Sets the emission per second of a set of reward distributions\n     * @param asset The asset is being incentivized\n     * @param rewards List of reward addresses are being distributed\n     * @param newEmissionsPerSecond List of new reward emissions per second\n     */\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Gets the end date for the distribution\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The timestamp with the end of the distribution, in unix time format\n     **/\n    function getDistributionEnd(\n        address asset,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the index of a user on a reward distribution\n     * @param user Address of the user\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The current user asset index, not including new distributions\n     **/\n    function getUserAssetIndex(\n        address user,\n        address asset,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution reward for a certain asset\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The index of the asset distribution\n     * @return The emission per second of the reward distribution\n     * @return The timestamp of the last update of the index\n     * @return The timestamp of the distribution end\n     **/\n    function getRewardsData(\n        address asset,\n        address reward\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    /**\n     * @dev Calculates the next value of an specific distribution index, with validations.\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The old index of the asset distribution\n     * @return The new index of the asset distribution\n     **/\n    function getAssetIndex(\n        address asset,\n        address reward\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the list of available reward token addresses of an incentivized asset\n     * @param asset The incentivized asset\n     * @return List of rewards addresses of the input asset\n     **/\n    function getRewardsByAsset(\n        address asset\n    ) external view returns (address[] memory);\n\n    /**\n     * @dev Returns the list of available reward addresses\n     * @return List of rewards supported in this contract\n     **/\n    function getRewardsList() external view returns (address[] memory);\n\n    /**\n     * @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return Unclaimed rewards, not including new distributions\n     **/\n    function getUserAccruedRewards(\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return The rewards amount\n     **/\n    function getUserRewards(\n        address[] calldata assets,\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @return The list of reward addresses\n     * @return The list of unclaimed amount of rewards\n     **/\n    function getAllUserRewards(\n        address[] calldata assets,\n        address user\n    ) external view returns (address[] memory, uint256[] memory);\n\n    /**\n     * @dev Returns the decimals of an asset to calculate the distribution delta\n     * @param asset The address to retrieve decimals\n     * @return The decimals of an underlying asset\n     */\n    function getAssetDecimals(address asset) external view returns (uint8);\n\n    /**\n     * @dev Returns the address of the emission manager\n     * @return The address of the EmissionManager\n     */\n    function EMISSION_MANAGER() external view returns (address);\n\n    /**\n     * @dev Returns the address of the emission manager.\n     * Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.\n     * @return The address of the EmissionManager\n     */\n    function getEmissionManager() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/ITransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\ninterface ITransferStrategyBase {\n    event EmergencyWithdrawal(\n        address indexed caller,\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @param to Account to transfer rewards\n     * @param reward Address of the reward token\n     * @param amount Amount to transfer to the \"to\" address parameter\n     * @return Returns true bool if transfer logic succeeds\n     */\n    function performTransfer(\n        address to,\n        address reward,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @return Returns the address of the Incentives Controller\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @return Returns the address of the Rewards admin\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /**\n     * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/libraries/RewardsDataTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IAaveOracle} from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport {ITransferStrategyBase} from \"../interfaces/ITransferStrategyBase.sol\";\n\nlibrary RewardsDataTypes {\n    struct RewardsConfigInput {\n        uint88 emissionPerSecond;\n        uint256 totalSupply;\n        uint32 distributionEnd;\n        address asset;\n        address reward;\n        ITransferStrategyBase transferStrategy;\n        IAaveOracle rewardOracle;\n    }\n\n    struct UserAssetBalance {\n        address asset;\n        uint256 userBalance;\n        uint256 totalSupply;\n    }\n\n    struct UserData {\n        // Liquidity index of the reward distribution for the user\n        uint104 index;\n        // Amount of accrued rewards for the user since last user index update\n        uint128 accrued;\n    }\n\n    struct RewardData {\n        // Liquidity index of the reward distribution\n        uint104 index;\n        // Amount of reward tokens distributed per second\n        uint88 emissionPerSecond;\n        // Timestamp of the last reward index update\n        uint32 lastUpdateTimestamp;\n        // The end of the distribution of rewards (in seconds)\n        uint32 distributionEnd;\n        // Map of user addresses and their rewards data (userAddress => userData)\n        mapping(address => UserData) usersData;\n    }\n\n    struct AssetData {\n        // Map of reward token addresses and their data (rewardTokenAddress => rewardData)\n        mapping(address => RewardData) rewards;\n        // List of reward token addresses for the asset\n        mapping(uint128 => address) availableRewards;\n        // Count of reward tokens for the asset\n        uint128 availableRewardsCount;\n        // Number of decimals of the asset\n        uint8 decimals;\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (\n                address(0),\n                RecoverError.InvalidSignatureLength,\n                bytes32(signature.length)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            signature\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs &\n                bytes32(\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n                );\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            r,\n            vs\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            v,\n            r,\n            s\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"./ECDSA.sol\";\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    /* //////////////////////////////////////////////////////////////\n                        EVENTS\n  ////////////////////////////////////////////////////////////// */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /* //////////////////////////////////////////////////////////////\n                        METADATA STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    /* //////////////////////////////////////////////////////////////\n                        ERC20 STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /* //////////////////////////////////////////////////////////////\n                        EIP-2612 STORAGE\n  ////////////////////////////////////////////////////////////// */\n\n    mapping(address => uint256) public nonces;\n\n    /* //////////////////////////////////////////////////////////////\n                        CONSTRUCTOR\n  ////////////////////////////////////////////////////////////// */\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        ERC20 LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          EIP-2612 LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address signer = ECDSA.recover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                PERMIT_TYPEHASH,\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(signer == owner, \"INVALID_SIGNER\");\n\n            allowance[signer][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            INTERNAL MINT/BURN LOGIC\n  ////////////////////////////////////////////////////////////// */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport {IRewardsController} from \"../../../dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\ninterface IAToken {\n    function POOL() external view returns (address);\n\n    function getIncentivesController() external view returns (address);\n\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n    /**\n     * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n     * @return The scaled total supply\n     */\n    function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 {\n    event Deposit(\n        address indexed sender,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is \"managed\" by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the\n     * \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(\n        uint256 assets\n    ) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     *\n     * NOTE: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the\n     * \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(\n        uint256 shares\n    ) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     * While deposit of aToken is not affected by aave pool configrations, deposit of the aTokenUnderlying will need to deposit to aave\n     * so it is affected by current aave pool configuration.\n     * Reference: https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/ValidationLogic.sol#L57\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function maxDeposit(\n        address receiver\n    ) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(\n        uint256 assets\n    ) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(\n        address receiver\n    ) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(\n        address owner\n    ) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(\n        uint256 assets\n    ) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call to the aToken underlying.\n     * While redeem of aToken is not affected by aave pool configrations, redeeming of the aTokenUnderlying will need to redeem from aave\n     * so it is affected by current aave pool configuration.\n     * Reference: https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/ValidationLogic.sol#L87\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(\n        uint256 shares\n    ) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IStaticATokenFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport {IPool, DataTypes} from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// ITransparentProxyFactory is missing, add to missing list\n// import {ITransparentProxyFactory} from \"contracts/dlend/core/interfaces/ITransparentProxyFactory.sol\";\n// Ownable is not used in the interface, can be omitted\n\ninterface IStaticATokenFactory {\n    /**\n     * @notice Creates new staticATokens\n     * @param underlyings the addresses of the underlyings to create.\n     * @return address[] addresses of the new staticATokens.\n     */\n    function createStaticATokens(\n        address[] memory underlyings\n    ) external returns (address[] memory);\n\n    /**\n     * @notice Returns all tokens deployed via this registry.\n     * @return address[] list of tokens\n     */\n    function getStaticATokens() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the staticAToken for a given underlying.\n     * @param underlying the address of the underlying.\n     * @return address the staticAToken address.\n     */\n    function getStaticAToken(\n        address underlying\n    ) external view returns (address);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/interfaces/IStaticATokenLM.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPool} from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport {IRewardsController} from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\ninterface IStaticATokenLM {\n    struct SignatureParams {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct PermitParams {\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct UserRewardsData {\n        uint128 rewardsIndexOnLastInteraction; // (in RAYs)\n        uint128 unclaimedRewards; // (in RAYs)\n    }\n\n    struct RewardIndexCache {\n        bool isRegistered;\n        uint248 lastUpdatedIndex;\n    }\n\n    event RewardTokenRegistered(address indexed reward, uint256 startIndex);\n\n    /**\n     * @notice Allows to deposit on Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param depositor Address from which the funds to deposit are going to be pulled\n     * @param receiver Address that will receive the staticATokens, in the average case, same as the `depositor`\n     * @param assets The amount to deposit\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param depositToAave bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function metaDeposit(\n        address depositor,\n        address receiver,\n        uint256 assets,\n        uint16 referralCode,\n        bool depositToAave,\n        uint256 deadline,\n        PermitParams calldata permit,\n        SignatureParams calldata sigParams\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows to withdraw from Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner Address owning the staticATokens\n     * @param receiver Address that will receive the underlying withdrawn from Aave\n     * @param shares The amount of staticAToken to withdraw. If > 0, `assets` needs to be 0\n     * @param assets The amount of underlying/aToken to withdraw. If > 0, `shares` needs to be 0\n     * @param withdrawFromAave bool\n     * - `true` for the receiver to get underlying tokens (e.g. USDC)\n     * - `false` for the receiver to get aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `receiver`, dynamic balance\n     */\n    function metaWithdraw(\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 assets,\n        bool withdrawFromAave,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Returns the Aave liquidity index of the underlying aToken, denominated rate here\n     * as it can be considered as an ever-increasing exchange rate\n     * @return The liquidity index\n     **/\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n     * @param reward The reward to claim\n     * @return uint256 Amount collected\n     */\n    function collectAndUpdateRewards(address reward) external returns (uint256);\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n     * @param onBehalfOf The address to claim on behalf of\n     * @param receiver The address to receive the rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        address[] memory rewards\n    ) external;\n\n    /**\n     * @notice Claim rewards and send them to a receiver\n     * @param receiver The address to receive the rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewards(address receiver, address[] memory rewards) external;\n\n    /**\n     * @notice Claim rewards\n     * @param rewards The rewards to claim\n     */\n    function claimRewardsToSelf(address[] memory rewards) external;\n\n    /**\n     * @notice Get the total claimable rewards of the contract.\n     * @param reward The reward to claim\n     * @return uint256 The current balance + pending rewards from the `_incentivesController`\n     */\n    function getTotalClaimableRewards(\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the total claimable rewards for a user in WAD\n     * @param user The address of the user\n     * @param reward The reward to claim\n     * @return uint256 The claimable amount of rewards in WAD\n     */\n    function getClaimableRewards(\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @notice The unclaimed rewards for a user in WAD\n     * @param user The address of the user\n     * @param reward The reward to claim\n     * @return uint256 The unclaimed amount of rewards in WAD\n     */\n    function getUnclaimedRewards(\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @notice The underlying asset reward index in RAY\n     * @param reward The reward to claim\n     * @return uint256 The underlying asset reward index in RAY\n     */\n    function getCurrentRewardsIndex(\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @notice The aToken used inside the 4626 vault.\n     * @return IERC20 The aToken IERC20.\n     */\n    function aToken() external view returns (IERC20);\n\n    /**\n     * @notice The IERC20s that are currently rewarded to addresses of the vault via LM on incentivescontroller.\n     * @return IERC20 The IERC20s of the rewards.\n     */\n    function rewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice Fetches all rewardTokens from the incentivecontroller and registers the missing ones.\n     */\n    function refreshRewardTokens() external;\n\n    /**\n     * @notice Checks if the passed token is a registered reward.\n     * @return bool signaling if token is a registered reward.\n     */\n    function isRegisteredRewardToken(\n        address reward\n    ) external view returns (bool);\n\n    /**\n     * @notice Deposits aTokens and mints static aTokens to the receiver\n     * @param aTokenAmount The amount of aTokens to deposit\n     * @param receiver The address that will receive the static aTokens\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function depositATokens(\n        uint256 aTokenAmount,\n        address receiver\n    ) external returns (uint256);\n\n    /**\n     * @notice Burns static aTokens and returns aTokens to the receiver\n     * @param shares The amount of static aTokens to burn\n     * @param receiver The address that will receive the aTokens\n     * @param owner The address whose static aTokens will be burned\n     * @return uint256 The amount of aTokens returned\n     */\n    function redeemATokens(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256);\n}\n"
    },
    "contracts/vaults/atoken_wrapper/RayMathExplicitRounding.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nenum Rounding {\n    UP,\n    DOWN\n}\n\n/**\n * Simplified version of RayMath that instead of half-up rounding does explicit rounding in a specified direction.\n * This is needed to have a 4626 complient implementation, that always predictable rounds in favor of the vault / static a token.\n */\nlibrary RayMathExplicitRounding {\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function rayMulRoundDown(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return Math.mulDiv(a, b, RAY); // default is rounding down\n    }\n\n    function rayMulRoundUp(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return Math.mulDiv(a, b, RAY, Math.Rounding.Ceil);\n    }\n\n    function rayDivRoundDown(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (uint256) {\n        return Math.mulDiv(a, RAY, b); // rounding down\n    }\n\n    function rayDivRoundUp(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (uint256) {\n        return Math.mulDiv(a, RAY, b, Math.Rounding.Ceil);\n    }\n\n    function rayToWadRoundDown(uint256 a) internal pure returns (uint256) {\n        return a / WAD_RAY_RATIO;\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenErrors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.20;\n\nlibrary StaticATokenErrors {\n    string public constant INVALID_OWNER = \"1\";\n    string public constant INVALID_EXPIRATION = \"2\";\n    string public constant INVALID_SIGNATURE = \"3\";\n    string public constant INVALID_DEPOSITOR = \"4\";\n    string public constant INVALID_RECIPIENT = \"5\";\n    string public constant INVALID_CLAIMER = \"6\";\n    string public constant ONLY_ONE_AMOUNT_FORMAT_ALLOWED = \"7\";\n    string public constant INVALID_ZERO_AMOUNT = \"8\";\n    string public constant REWARD_NOT_INITIALIZED = \"9\";\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IPool, DataTypes} from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {StaticATokenLM} from \"./StaticATokenLM.sol\";\nimport {IStaticATokenFactory} from \"./interfaces/IStaticATokenFactory.sol\";\nimport {IRewardsController} from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\n\n/**\n * @title StaticATokenFactory\n * @notice Factory contract that keeps track of all deployed static aToken wrappers for a specified pool.\n * This registry also acts as a factory, allowing to deploy new static aTokens on demand.\n * There can only be one static aToken per underlying on the registry at a time.\n * @author BGD labs (modified by Colt)\n */\ncontract StaticATokenFactory is IStaticATokenFactory {\n    IPool public immutable POOL;\n\n    mapping(address => address) internal _underlyingToStaticAToken;\n    address[] internal _staticATokens;\n\n    event StaticTokenCreated(\n        address indexed staticAToken,\n        address indexed underlying\n    );\n\n    constructor(IPool pool) {\n        POOL = pool;\n    }\n\n    function initialize() external pure {\n        revert(\"NO_INITIALIZER\");\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function createStaticATokens(\n        address[] memory underlyings\n    ) external returns (address[] memory) {\n        address[] memory staticATokens = new address[](underlyings.length);\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address cachedStaticAToken = _underlyingToStaticAToken[\n                underlyings[i]\n            ];\n            if (cachedStaticAToken == address(0)) {\n                DataTypes.ReserveData memory reserveData = POOL.getReserveData(\n                    underlyings[i]\n                );\n                require(\n                    reserveData.aTokenAddress != address(0),\n                    \"UNDERLYING_NOT_LISTED\"\n                );\n                StaticATokenLM staticAToken = new StaticATokenLM(\n                    POOL,\n                    IRewardsController(address(0)), // TODO: pass correct incentives controller if needed\n                    reserveData.aTokenAddress,\n                    string(\n                        abi.encodePacked(\n                            \"Wrapped \",\n                            IERC20Metadata(reserveData.aTokenAddress).name()\n                        )\n                    ),\n                    string(\n                        abi.encodePacked(\n                            \"w\",\n                            IERC20Metadata(reserveData.aTokenAddress).symbol()\n                        )\n                    )\n                );\n                address staticATokenAddr = address(staticAToken);\n                _underlyingToStaticAToken[underlyings[i]] = staticATokenAddr;\n                staticATokens[i] = staticATokenAddr;\n                _staticATokens.push(staticATokenAddr);\n                emit StaticTokenCreated(staticATokenAddr, underlyings[i]);\n            } else {\n                staticATokens[i] = cachedStaticAToken;\n            }\n        }\n        return staticATokens;\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function getStaticATokens() external view returns (address[] memory) {\n        return _staticATokens;\n    }\n\n    ///@inheritdoc IStaticATokenFactory\n    function getStaticAToken(\n        address underlying\n    ) external view returns (address) {\n        return _underlyingToStaticAToken[underlying];\n    }\n}\n"
    },
    "contracts/vaults/atoken_wrapper/StaticATokenLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// --- DLend fork imports ---\nimport {IPool} from \"contracts/dlend/core/interfaces/IPool.sol\";\nimport {DataTypes} from \"contracts/dlend/core/protocol/libraries/types/DataTypes.sol\";\nimport {ReserveConfiguration} from \"contracts/dlend/core/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport {IScaledBalanceToken} from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport {IRewardsController} from \"contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol\";\nimport {WadRayMath} from \"contracts/dlend/core/protocol/libraries/math/WadRayMath.sol\";\nimport {MathUtils} from \"contracts/dlend/core/protocol/libraries/math/MathUtils.sol\";\nimport {SafeCast} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {Initializable} from \"contracts/dlend/core/dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20WithPermit} from \"contracts/dlend/core/interfaces/IERC20WithPermit.sol\";\n// --- Local imports ---\nimport {IStaticATokenLM} from \"./interfaces/IStaticATokenLM.sol\";\nimport {IAToken} from \"./interfaces/IAToken.sol\";\nimport {ERC20} from \"./ERC20.sol\";\nimport {StaticATokenErrors} from \"./StaticATokenErrors.sol\";\nimport {RayMathExplicitRounding, Rounding} from \"./RayMathExplicitRounding.sol\";\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\nimport {ECDSA} from \"./ECDSA.sol\";\n\n/**\n * @title StaticATokenLM\n * @notice Wrapper smart contract that allows to deposit tokens on the Aave protocol and receive\n * a token which balance doesn't increase automatically, but uses an ever-increasing exchange rate.\n * It supports claiming liquidity mining rewards from the Aave system.\n * @author BGD labs\n */\ncontract StaticATokenLM is ERC20, IStaticATokenLM, IERC4626 {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using WadRayMath for uint256;\n    using RayMathExplicitRounding for uint256;\n\n    bytes32 public constant METADEPOSIT_TYPEHASH =\n        keccak256(\n            \"Deposit(address depositor,address receiver,uint256 assets,uint16 referralCode,bool depositToAave,uint256 nonce,uint256 deadline,PermitParams permit)\"\n        );\n    bytes32 public constant METAWITHDRAWAL_TYPEHASH =\n        keccak256(\n            \"Withdraw(address owner,address receiver,uint256 shares,uint256 assets,bool withdrawFromAave,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 public constant STATIC__ATOKEN_LM_REVISION = 2;\n\n    IPool public immutable POOL;\n    IRewardsController public immutable REWARDS_CONTROLLER;\n\n    IERC20 internal _aToken;\n    address internal _aTokenUnderlying;\n    address[] internal _rewardTokens;\n    mapping(address => RewardIndexCache) internal _startIndex;\n    mapping(address => mapping(address => UserRewardsData))\n        internal _userRewardsData;\n\n    constructor(\n        IPool pool,\n        IRewardsController rewardsController,\n        address newAToken,\n        string memory staticATokenName,\n        string memory staticATokenSymbol\n    )\n        ERC20(\n            staticATokenName,\n            staticATokenSymbol,\n            IERC20Metadata(newAToken).decimals()\n        )\n    {\n        POOL = pool;\n        REWARDS_CONTROLLER = rewardsController;\n        _aToken = IERC20(newAToken);\n        _aTokenUnderlying = IAToken(newAToken).UNDERLYING_ASSET_ADDRESS();\n        // Use standard approve for trusted protocol token (aToken underlying) and trusted protocol contract (dLEND POOL)\n        IERC20(_aTokenUnderlying).approve(address(POOL), type(uint256).max);\n        if (address(REWARDS_CONTROLLER) != address(0)) {\n            refreshRewardTokens();\n        }\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function refreshRewardTokens() public override {\n        address[] memory rewards = REWARDS_CONTROLLER.getRewardsByAsset(\n            address(_aToken)\n        );\n        for (uint256 i = 0; i < rewards.length; i++) {\n            _registerRewardToken(rewards[i]);\n        }\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function isRegisteredRewardToken(\n        address reward\n    ) public view override returns (bool) {\n        return _startIndex[reward].isRegistered;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function metaDeposit(\n        address depositor,\n        address receiver,\n        uint256 assets,\n        uint16 referralCode,\n        bool depositToAave,\n        uint256 deadline,\n        PermitParams calldata permit,\n        SignatureParams calldata sigParams\n    ) external returns (uint256) {\n        require(depositor != address(0), StaticATokenErrors.INVALID_DEPOSITOR);\n        //solium-disable-next-line\n        require(\n            deadline >= block.timestamp,\n            StaticATokenErrors.INVALID_EXPIRATION\n        );\n        uint256 nonce = nonces[depositor];\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            METADEPOSIT_TYPEHASH,\n                            depositor,\n                            receiver,\n                            assets,\n                            referralCode,\n                            depositToAave,\n                            nonce,\n                            deadline,\n                            permit\n                        )\n                    )\n                )\n            );\n            nonces[depositor] = nonce + 1;\n            require(\n                depositor ==\n                    ECDSA.recover(\n                        digest,\n                        sigParams.v,\n                        sigParams.r,\n                        sigParams.s\n                    ),\n                StaticATokenErrors.INVALID_SIGNATURE\n            );\n        }\n        // assume if deadline 0 no permit was supplied\n        if (permit.deadline != 0) {\n            try\n                IERC20WithPermit(\n                    depositToAave\n                        ? address(_aTokenUnderlying)\n                        : address(_aToken)\n                ).permit(\n                        depositor,\n                        address(this),\n                        permit.value,\n                        permit.deadline,\n                        permit.v,\n                        permit.r,\n                        permit.s\n                    )\n            {} catch {}\n        }\n        (uint256 shares, ) = _deposit(\n            depositor,\n            receiver,\n            0,\n            assets,\n            referralCode,\n            depositToAave\n        );\n        return shares;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function metaWithdraw(\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 assets,\n        bool withdrawFromAave,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256) {\n        require(owner != address(0), StaticATokenErrors.INVALID_OWNER);\n        //solium-disable-next-line\n        require(\n            deadline >= block.timestamp,\n            StaticATokenErrors.INVALID_EXPIRATION\n        );\n        uint256 nonce = nonces[owner];\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            METAWITHDRAWAL_TYPEHASH,\n                            owner,\n                            receiver,\n                            shares,\n                            assets,\n                            withdrawFromAave,\n                            nonce,\n                            deadline\n                        )\n                    )\n                )\n            );\n            nonces[owner] = nonce + 1;\n            require(\n                owner ==\n                    ECDSA.recover(\n                        digest,\n                        sigParams.v,\n                        sigParams.r,\n                        sigParams.s\n                    ),\n                StaticATokenErrors.INVALID_SIGNATURE\n            );\n        }\n        return _withdraw(owner, receiver, shares, assets, withdrawFromAave);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewRedeem(\n        uint256 shares\n    ) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Rounding.UP);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewWithdraw(\n        uint256 assets\n    ) public view virtual returns (uint256) {\n        return _convertToShares(assets, Rounding.UP);\n    }\n\n    ///@inheritdoc IERC4626\n    function previewDeposit(\n        uint256 assets\n    ) public view virtual returns (uint256) {\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function rate() public view returns (uint256) {\n        return POOL.getReserveNormalizedIncome(_aTokenUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function collectAndUpdateRewards(address reward) public returns (uint256) {\n        if (reward == address(0)) {\n            return 0;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(_aToken);\n\n        return\n            REWARDS_CONTROLLER.claimRewards(\n                assets,\n                type(uint256).max,\n                address(this),\n                reward\n            );\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        address[] memory rewards\n    ) external {\n        require(\n            msg.sender == onBehalfOf ||\n                msg.sender == REWARDS_CONTROLLER.getClaimer(onBehalfOf),\n            StaticATokenErrors.INVALID_CLAIMER\n        );\n        _claimRewardsOnBehalf(onBehalfOf, receiver, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewards(address receiver, address[] memory rewards) external {\n        _claimRewardsOnBehalf(msg.sender, receiver, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function claimRewardsToSelf(address[] memory rewards) external {\n        _claimRewardsOnBehalf(msg.sender, msg.sender, rewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getCurrentRewardsIndex(\n        address reward\n    ) public view returns (uint256) {\n        if (address(reward) == address(0)) {\n            return 0;\n        }\n        (, uint256 nextIndex) = REWARDS_CONTROLLER.getAssetIndex(\n            address(_aToken),\n            reward\n        );\n        return nextIndex;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getTotalClaimableRewards(\n        address reward\n    ) external view returns (uint256) {\n        if (reward == address(0)) {\n            return 0;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(_aToken);\n        uint256 freshRewards = REWARDS_CONTROLLER.getUserRewards(\n            assets,\n            address(this),\n            reward\n        );\n        return IERC20(reward).balanceOf(address(this)) + freshRewards;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getClaimableRewards(\n        address user,\n        address reward\n    ) external view returns (uint256) {\n        return\n            _getClaimableRewards(\n                user,\n                reward,\n                balanceOf[user],\n                getCurrentRewardsIndex(reward)\n            );\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getUnclaimedRewards(\n        address user,\n        address reward\n    ) external view returns (uint256) {\n        return _userRewardsData[user][reward].unclaimedRewards;\n    }\n\n    ///@inheritdoc IERC4626\n    function asset() external view returns (address) {\n        return address(_aTokenUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function aToken() external view returns (IERC20) {\n        return _aToken;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function rewardTokens() external view returns (address[] memory) {\n        return _rewardTokens;\n    }\n\n    ///@inheritdoc IERC4626\n    function totalAssets() external view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n\n    ///@inheritdoc IERC4626\n    function convertToShares(uint256 assets) external view returns (uint256) {\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function convertToAssets(uint256 shares) external view returns (uint256) {\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        uint256 assets = maxDeposit(address(0));\n        if (assets == type(uint256).max) return type(uint256).max;\n        return _convertToShares(assets, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        uint256 shares = maxRedeem(owner);\n        return _convertToAssets(shares, Rounding.DOWN);\n    }\n\n    ///@inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        address cachedATokenUnderlying = _aTokenUnderlying;\n        DataTypes.ReserveData memory reserveData = POOL.getReserveData(\n            cachedATokenUnderlying\n        );\n\n        // if paused or inactive users cannot withdraw underlying\n        if (\n            !ReserveConfiguration.getActive(reserveData.configuration) ||\n            ReserveConfiguration.getPaused(reserveData.configuration)\n        ) {\n            return 0;\n        }\n\n        // otherwise users can withdraw up to the available amount\n        uint256 underlyingTokenBalanceInShares = _convertToShares(\n            IERC20(cachedATokenUnderlying).balanceOf(reserveData.aTokenAddress),\n            Rounding.DOWN\n        );\n        uint256 cachedUserBalance = balanceOf[owner];\n        return\n            underlyingTokenBalanceInShares >= cachedUserBalance\n                ? cachedUserBalance\n                : underlyingTokenBalanceInShares;\n    }\n\n    ///@inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        DataTypes.ReserveData memory reserveData = POOL.getReserveData(\n            _aTokenUnderlying\n        );\n\n        // if inactive, paused or frozen users cannot deposit underlying\n        if (\n            !ReserveConfiguration.getActive(reserveData.configuration) ||\n            ReserveConfiguration.getPaused(reserveData.configuration) ||\n            ReserveConfiguration.getFrozen(reserveData.configuration)\n        ) {\n            return 0;\n        }\n\n        uint256 supplyCap = ReserveConfiguration.getSupplyCap(\n            reserveData.configuration\n        ) * (10 ** ReserveConfiguration.getDecimals(reserveData.configuration));\n        // if no supply cap deposit is unlimited\n        if (supplyCap == 0) return type(uint256).max;\n        // return remaining supply cap margin\n        uint256 currentSupply = (IAToken(reserveData.aTokenAddress)\n            .scaledTotalSupply() + reserveData.accruedToTreasury).rayMulRoundUp(\n                _getNormalizedIncome(reserveData)\n            );\n        return currentSupply > supplyCap ? 0 : supplyCap - currentSupply;\n    }\n\n    ///@inheritdoc IERC4626\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external virtual returns (uint256) {\n        (uint256 shares, ) = _deposit(msg.sender, receiver, 0, assets, 0, true);\n        return shares;\n    }\n\n    ///@inheritdoc IERC4626\n    function mint(\n        uint256 shares,\n        address receiver\n    ) external virtual returns (uint256) {\n        (, uint256 assets) = _deposit(msg.sender, receiver, shares, 0, 0, true);\n\n        return assets;\n    }\n\n    ///@inheritdoc IERC4626\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256) {\n        (uint256 shares, ) = _withdraw(owner, receiver, 0, assets, true);\n\n        return shares;\n    }\n\n    ///@inheritdoc IERC4626\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256) {\n        (, uint256 assets) = _withdraw(owner, receiver, shares, 0, true);\n\n        return assets;\n    }\n\n    /// @notice Deposit aTokens and mint static tokens to receiver\n    function depositATokens(\n        uint256 aTokenAmount,\n        address receiver\n    ) external override returns (uint256) {\n        require(aTokenAmount > 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // allow compensation for rebase during tx\n        uint256 userBalance = _aToken.balanceOf(msg.sender);\n        uint256 amount = aTokenAmount > userBalance\n            ? userBalance\n            : aTokenAmount;\n        // determine shares to mint\n        uint256 shares = previewDeposit(amount);\n        require(shares != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // transfer aTokens in\n        _aToken.safeTransferFrom(msg.sender, address(this), amount);\n        // mint static tokens\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, amount, shares);\n        return shares;\n    }\n\n    /// @notice Burn static tokens and return aTokens to receiver\n    function redeemATokens(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        require(shares > 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // determine assets to return\n        uint256 assets = previewRedeem(shares);\n        require(assets != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n        // handle allowance if not owner\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender];\n            if (allowed != type(uint256).max) {\n                allowance[owner][msg.sender] = allowed - shares;\n            }\n        }\n        // burn static tokens\n        _burn(owner, shares);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        // transfer aTokens out\n        _aToken.safeTransfer(receiver, assets);\n        return assets;\n    }\n\n    function _deposit(\n        address depositor,\n        address receiver,\n        uint256 _shares,\n        uint256 _assets,\n        uint16 referralCode,\n        bool depositToAave\n    ) internal returns (uint256, uint256) {\n        require(receiver != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        require(\n            _shares == 0 || _assets == 0,\n            StaticATokenErrors.ONLY_ONE_AMOUNT_FORMAT_ALLOWED\n        );\n\n        uint256 assets = _assets;\n        uint256 shares = _shares;\n        if (shares > 0) {\n            if (depositToAave) {\n                require(\n                    shares <= maxMint(receiver),\n                    \"ERC4626: mint more than max\"\n                );\n            }\n            assets = previewMint(shares);\n        } else {\n            if (depositToAave) {\n                require(\n                    assets <= maxDeposit(receiver),\n                    \"ERC4626: deposit more than max\"\n                );\n            }\n            shares = previewDeposit(assets);\n        }\n        require(shares != 0, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n\n        if (depositToAave) {\n            address cachedATokenUnderlying = _aTokenUnderlying;\n            SafeERC20.safeTransferFrom(\n                IERC20(cachedATokenUnderlying),\n                depositor,\n                address(this),\n                assets\n            );\n            POOL.deposit(\n                cachedATokenUnderlying,\n                assets,\n                address(this),\n                referralCode\n            );\n        } else {\n            _aToken.safeTransferFrom(depositor, address(this), assets);\n        }\n\n        _mint(receiver, shares);\n\n        emit Deposit(depositor, receiver, assets, shares);\n\n        return (shares, assets);\n    }\n\n    function _withdraw(\n        address owner,\n        address receiver,\n        uint256 _shares,\n        uint256 _assets,\n        bool withdrawFromAave\n    ) internal returns (uint256, uint256) {\n        require(receiver != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        require(\n            _shares == 0 || _assets == 0,\n            StaticATokenErrors.ONLY_ONE_AMOUNT_FORMAT_ALLOWED\n        );\n        require(_shares != _assets, StaticATokenErrors.INVALID_ZERO_AMOUNT);\n\n        uint256 assets = _assets;\n        uint256 shares = _shares;\n\n        if (shares > 0) {\n            if (withdrawFromAave) {\n                require(\n                    shares <= maxRedeem(owner),\n                    \"ERC4626: redeem more than max\"\n                );\n            }\n            assets = previewRedeem(shares);\n        } else {\n            if (withdrawFromAave) {\n                require(\n                    assets <= maxWithdraw(owner),\n                    \"ERC4626: withdraw more than max\"\n                );\n            }\n            shares = previewWithdraw(assets);\n        }\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        if (withdrawFromAave) {\n            POOL.withdraw(_aTokenUnderlying, assets, receiver);\n        } else {\n            _aToken.safeTransfer(receiver, assets);\n        }\n\n        return (shares, assets);\n    }\n\n    /**\n     * @notice Updates rewards for senders and receiver in a transfer (not updating rewards for address(0))\n     * @param from The address of the sender of tokens\n     * @param to The address of the receiver of tokens\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal override {\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\n            address rewardToken = address(_rewardTokens[i]);\n            uint256 rewardsIndex = getCurrentRewardsIndex(rewardToken);\n            if (from != address(0)) {\n                _updateUser(from, rewardsIndex, rewardToken);\n            }\n            if (to != address(0) && from != to) {\n                _updateUser(to, rewardsIndex, rewardToken);\n            }\n        }\n    }\n\n    /**\n     * @notice Adding the pending rewards to the unclaimed for specific user and updating user index\n     * @param user The address of the user to update\n     * @param currentRewardsIndex The current rewardIndex\n     * @param rewardToken The address of the reward token\n     */\n    function _updateUser(\n        address user,\n        uint256 currentRewardsIndex,\n        address rewardToken\n    ) internal {\n        uint256 balance = balanceOf[user];\n        if (balance > 0) {\n            _userRewardsData[user][rewardToken]\n                .unclaimedRewards = _getClaimableRewards(\n                user,\n                rewardToken,\n                balance,\n                currentRewardsIndex\n            ).toUint128();\n        }\n        _userRewardsData[user][rewardToken]\n            .rewardsIndexOnLastInteraction = currentRewardsIndex.toUint128();\n    }\n\n    /**\n     * @notice Compute the pending in WAD. Pending is the amount to add (not yet unclaimed) rewards in WAD.\n     * @param balance The balance of the user\n     * @param rewardsIndexOnLastInteraction The index which was on the last interaction of the user\n     * @param currentRewardsIndex The current rewards index in the system\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The amount of pending rewards in WAD\n     */\n    function _getPendingRewards(\n        uint256 balance,\n        uint256 rewardsIndexOnLastInteraction,\n        uint256 currentRewardsIndex,\n        uint256 assetUnit\n    ) internal pure returns (uint256) {\n        if (balance == 0) {\n            return 0;\n        }\n        return\n            (balance * (currentRewardsIndex - rewardsIndexOnLastInteraction)) /\n            assetUnit;\n    }\n\n    /**\n     * @notice Compute the claimable rewards for a user\n     * @param user The address of the user\n     * @param reward The address of the reward\n     * @param balance The balance of the user in WAD\n     * @param currentRewardsIndex The current rewards index\n     * @return The total rewards that can be claimed by the user (if `fresh` flag true, after updating rewards)\n     */\n    function _getClaimableRewards(\n        address user,\n        address reward,\n        uint256 balance,\n        uint256 currentRewardsIndex\n    ) internal view returns (uint256) {\n        RewardIndexCache memory rewardsIndexCache = _startIndex[reward];\n        require(\n            rewardsIndexCache.isRegistered == true,\n            StaticATokenErrors.REWARD_NOT_INITIALIZED\n        );\n        UserRewardsData memory currentUserRewardsData = _userRewardsData[user][\n            reward\n        ];\n        uint256 assetUnit = 10 ** decimals;\n        return\n            currentUserRewardsData.unclaimedRewards +\n            _getPendingRewards(\n                balance,\n                currentUserRewardsData.rewardsIndexOnLastInteraction == 0\n                    ? rewardsIndexCache.lastUpdatedIndex\n                    : currentUserRewardsData.rewardsIndexOnLastInteraction,\n                currentRewardsIndex,\n                assetUnit\n            );\n    }\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @param onBehalfOf The address to claim on behalf of\n     * @param rewards The addresses of the rewards\n     * @param receiver The address to receive the rewards\n     */\n    function _claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        address[] memory rewards\n    ) internal {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            if (address(rewards[i]) == address(0)) {\n                continue;\n            }\n            uint256 currentRewardsIndex = getCurrentRewardsIndex(rewards[i]);\n            uint256 balance = balanceOf[onBehalfOf];\n            uint256 userReward = _getClaimableRewards(\n                onBehalfOf,\n                rewards[i],\n                balance,\n                currentRewardsIndex\n            );\n            uint256 totalRewardTokenBalance = IERC20(rewards[i]).balanceOf(\n                address(this)\n            );\n            uint256 unclaimedReward = 0;\n\n            if (userReward > totalRewardTokenBalance) {\n                totalRewardTokenBalance += collectAndUpdateRewards(\n                    address(rewards[i])\n                );\n            }\n\n            if (userReward > totalRewardTokenBalance) {\n                unclaimedReward = userReward - totalRewardTokenBalance;\n                userReward = totalRewardTokenBalance;\n            }\n            if (userReward > 0) {\n                _userRewardsData[onBehalfOf][rewards[i]]\n                    .unclaimedRewards = unclaimedReward.toUint128();\n                _userRewardsData[onBehalfOf][rewards[i]]\n                    .rewardsIndexOnLastInteraction = currentRewardsIndex\n                    .toUint128();\n                IERC20(rewards[i]).safeTransfer(receiver, userReward);\n            }\n        }\n    }\n\n    function _convertToShares(\n        uint256 assets,\n        Rounding rounding\n    ) internal view returns (uint256) {\n        if (rounding == Rounding.UP) return assets.rayDivRoundUp(rate());\n        return assets.rayDivRoundDown(rate());\n    }\n\n    function _convertToAssets(\n        uint256 shares,\n        Rounding rounding\n    ) internal view returns (uint256) {\n        if (rounding == Rounding.UP) return shares.rayMulRoundUp(rate());\n        return shares.rayMulRoundDown(rate());\n    }\n\n    /**\n     * @notice Initializes a new rewardToken\n     * @param reward The reward token to be registered\n     */\n    function _registerRewardToken(address reward) internal {\n        if (isRegisteredRewardToken(reward)) return;\n        uint256 startIndex = getCurrentRewardsIndex(reward);\n\n        _rewardTokens.push(reward);\n        _startIndex[reward] = RewardIndexCache(true, uint240(startIndex));\n\n        emit RewardTokenRegistered(reward, startIndex);\n    }\n\n    /**\n     * @notice Returns the ongoing normalized income for the reserve.\n     * @dev A value of 1e27 means there is no income. As time passes, the income is accrued\n     * @dev A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n     * @param reserve The reserve object\n     * @return The normalized income, expressed in ray\n     */\n    function _getNormalizedIncome(\n        DataTypes.ReserveData memory reserve\n    ) internal view returns (uint256) {\n        uint40 timestamp = reserve.lastUpdateTimestamp;\n\n        //solium-disable-next-line\n        if (timestamp == block.timestamp) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return reserve.liquidityIndex;\n        } else {\n            return\n                MathUtils\n                    .calculateLinearInterest(\n                        reserve.currentLiquidityRate,\n                        timestamp\n                    )\n                    .rayMul(reserve.liquidityIndex);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}