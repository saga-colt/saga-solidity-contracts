import { expect } from "chai";
import { ethers } from "hardhat";

import {
  COLLATERAL_DECIMALS,
  deployDLoopMockFixture,
  testSetup,
} from "./DLoopCoreMock/fixture";

const parseUnits = (val: string | number, decimals: number): bigint =>
  ethers.parseUnits(val.toString(), decimals);

describe("dLOOP zero-share vulnerability", function () {
  let vault: any;
  let collateralToken: any;
  let deployer: any;
  let victim: any;

  beforeEach(async () => {
    const fixture = await deployDLoopMockFixture();
    await testSetup(fixture);

    ({ dloopMock: vault, collateralToken, deployer } = fixture as any);
    victim = fixture.user1;

    // Mint collateral to deployer for initial seed deposit and approve vault
    await collateralToken.mint(
      deployer.address,
      parseUnits("2000", COLLATERAL_DECIMALS),
    );
    await collateralToken
      .connect(deployer)
      .approve(await vault.getAddress(), ethers.MaxUint256);

    // Seed deposit by deployer
    const seed = parseUnits("1000", COLLATERAL_DECIMALS);
    await vault.connect(deployer).deposit(seed, deployer.address);

    // Redeem everything to reset supply
    const shares = await vault.balanceOf(deployer.address);
    await vault
      .connect(deployer)
      .redeem(shares, deployer.address, deployer.address);

    // At this point vault has debt > collateral (due to withdrawal fee = 0 issues), bring it
    // back into valid leverage range by supplying just enough collateral on behalf of vault.

    const [collBaseRaw, debtBaseRaw] =
      await vault.getTotalCollateralAndDebtOfUserInBase(
        await vault.getAddress(),
      );

    const collBase = BigInt(collBaseRaw);
    const debtBase = BigInt(debtBaseRaw);

    if (collBase < debtBase) {
      // Calculate collateral required so that leverage equals target 3x (30000 bps)
      const targetBps = 30000n;
      const numerator = debtBase * targetBps;
      const denominator = targetBps - 10000n;
      const desiredCollBase = (numerator + denominator - 1n) / denominator; // ceil division
      const deficitBase =
        desiredCollBase > collBase ? desiredCollBase - collBase : 0n;
      const deficitTokens = await vault.convertFromBaseCurrencyToToken(
        deficitBase,
        await collateralToken.getAddress(),
      );

      // Mint required collateral tokens to the vault address
      await collateralToken.mint(await vault.getAddress(), deficitTokens);

      // Supply them to the mock pool on behalf of the vault via test-only wrapper
      await vault.testSupplyToPoolImplementation(
        await collateralToken.getAddress(),
        deficitTokens,
        await vault.getAddress(),
      );
    }

    // Now vault has healthy leverage but totalSupply == 0. Leave 1 wei collateral sitting in
    // vault wallet (not supplied) to act as residual dust value in totalAssets() thanks to +1 in formula.
    const residualDustTokens = 1n;
    await collateralToken.mint(await vault.getAddress(), residualDustTokens);
  });

  it("reverts on deposit smaller than dust", async function () {
    const dust = await vault.totalAssets();
    expect(dust).to.be.gt(0n);

    const victimDeposit = dust - 1n;

    await collateralToken.mint(victim.address, victimDeposit);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), victimDeposit);

    await expect(
      vault.connect(victim).deposit(victimDeposit, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("reverts on deposit equal to dust", async function () {
    const dust = await vault.totalAssets();
    await collateralToken.mint(victim.address, dust);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), dust);
    await expect(
      vault.connect(victim).deposit(dust, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("accepts deposit above dust", async function () {
    const dust = await vault.totalAssets();
    const victimDeposit = dust + 1n;

    await collateralToken.mint(victim.address, victimDeposit);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), victimDeposit);

    const expectedShares = await vault.previewDeposit(victimDeposit);
    expect(expectedShares).to.be.gt(0n);
    await vault.connect(victim).deposit(victimDeposit, victim.address);

    expect(await vault.balanceOf(victim.address)).to.equal(expectedShares);
  });

  it("reverts on zero-asset deposit", async function () {
    await expect(
      vault.connect(victim).deposit(0n, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });
});
