import { expect } from "chai";
import { ethers } from "hardhat";
import {
  DPoolUSDCFixture,
  addLiquidityToCurvePool,
  depositLPToVault,
  redeemFromVault,
  approveToken,
  fundUserWithTokens,
  getVaultTotalAssets,
} from "./fixture";

const parseUnits = (val: string | number, decimals: number) =>
  ethers.parseUnits(val.toString(), decimals);

describe("dPOOL zero-share vulnerability", function () {
  const fixture = DPoolUSDCFixture;

  let vault: any;
  let curvePool: any;
  let baseAssetToken: any;
  let otherAssetToken: any;
  let feeManager: any;
  let victim: any;
  let lpDecimals = 18;
  let lpToken: any;

  beforeEach(async () => {
    const f = await fixture();
    ({
      vault,
      curvePool,
      baseAssetToken,
      otherAssetToken,
      admin: feeManager,
    } = f);
    victim = f.user1;

    // Skip setting withdrawal fee (requires role). We'll create dust by direct donation.

    // Provide liquidity to acquire LP tokens for feeManager
    const amt0 = parseUnits("1000", f.baseAssetInfo.decimals);
    const amt1 = parseUnits("1000", f.otherAssetInfo.decimals);
    await fundUserWithTokens(baseAssetToken, feeManager, amt0, f.deployer);
    await fundUserWithTokens(otherAssetToken, feeManager, amt1, f.deployer);

    await approveToken(baseAssetToken, feeManager, curvePool.target, amt0);
    await approveToken(otherAssetToken, feeManager, curvePool.target, amt1);

    await addLiquidityToCurvePool(curvePool, feeManager, amt0, amt1);

    const lpBalance = await curvePool.balanceOf(feeManager.address);

    // Approve vault and deposit
    const lpTokenAddress = await vault.asset();
    lpToken = await ethers.getContractAt(
      "@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20",
      lpTokenAddress
    );

    await approveToken(
      lpToken as unknown as any,
      feeManager,
      await vault.getAddress(),
      lpBalance
    );

    await depositLPToVault(vault, feeManager, lpBalance);

    // Redeem everything to create dust
    const shares = await vault.balanceOf(feeManager.address);
    await redeemFromVault(vault, feeManager, shares);

    // Donate a small amount of LP tokens to vault to create dust
    const dustLP = 1n;
    await (lpToken as any)
      .connect(feeManager)
      .transfer(await vault.getAddress(), dustLP);
  });

  it("reverts on deposit smaller than dust", async function () {
    const dust = await getVaultTotalAssets(vault);
    expect(dust).to.be.gt(0n);

    const victimDeposit = dust > 1n ? dust - 1n : 0n;
    if (victimDeposit === 0n) {
      // not applicable, skip
      this.skip();
    }

    // Fund victim with LP tokens (mint directly for simplicity)
    await (lpToken as any)
      .connect(feeManager)
      .transfer(victim.address, victimDeposit);
    await approveToken(
      lpToken as unknown as any,
      victim,
      await vault.getAddress(),
      victimDeposit
    );

    await expect(
      vault.connect(victim).deposit(victimDeposit, victim.address)
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("reverts on deposit equal to dust", async function () {
    const dust = await getVaultTotalAssets(vault);
    const victimDeposit = dust;
    await (lpToken as any)
      .connect(feeManager)
      .transfer(victim.address, victimDeposit);
    await approveToken(
      lpToken as unknown as any,
      victim,
      await vault.getAddress(),
      victimDeposit
    );

    await expect(
      vault.connect(victim).deposit(victimDeposit, victim.address)
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("accepts deposit above dust", async function () {
    const dust = await getVaultTotalAssets(vault);
    const victimDeposit = dust + 1n;
    await (lpToken as any)
      .connect(feeManager)
      .transfer(victim.address, victimDeposit);
    await approveToken(
      lpToken as unknown as any,
      victim,
      await vault.getAddress(),
      victimDeposit
    );

    const expectedShares = await vault.previewDeposit(victimDeposit);
    expect(expectedShares).to.be.gt(0n);
    await vault.connect(victim).deposit(victimDeposit, victim.address);

    expect(await vault.balanceOf(victim.address)).to.equal(expectedShares);
  });

  it("reverts on zero-asset deposit", async function () {
    const dust = await getVaultTotalAssets(vault);
    await expect(
      vault.connect(victim).deposit(0n, victim.address)
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });
});
