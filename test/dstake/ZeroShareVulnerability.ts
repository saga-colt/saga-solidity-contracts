/**
 * @title Zero-share vulnerability regression tests (GitHub issue #286)
 *
 * Context
 * -------
 * OpenZeppelin ERC4626 v5.x computes the number of `shares` to mint as:
 *   shares = assets * (totalSupply + 10**offset) / (totalAssets + 1)
 * rounded *down*.
 *
 * After the *last* user withdraws, `totalSupply()` becomes 0 but a withdrawal
 * fee (up to 1 % of TVL) remains as **dust** inside the vault, so
 *   totalSupply == 0  &&  totalAssets > 0.
 * For any deposit `assets < dust`, the formula returns `shares = 0`.
 *
 * Prior to the fix, `ERC4626Upgradeable.deposit()` did *not* check that
 * `shares > 0`, so the vault would happily transfer the depositor’s assets
 * and mint **zero shares**, causing an irreversible loss of funds.
 *
 * Fix
 * ----
 * In `DStakeToken._deposit()` we now revert with custom error `ZeroShares()`
 * whenever the pre-computed `shares` is zero.  This fully mitigates the
 * attack because:
 *   • A genuinely empty vault (totalAssets == 0) will still mint
 *     shares == assets > 0 for the first depositor.
 *   • Any state where totalAssets > 0 but totalSupply == 0 necessarily
 *     triggers a revert until someone deposits ≥ dust, which un-bricks the
 *     vault and restores a normal exchange rate.
 *
 * What these tests cover
 * ---------------------
 * 1. Reproduce dust scenario and assert that deposits < dust revert.
 * 2. Assert that deposit equal to dust also reverts (edge equality case).
 * 3. Assert that deposit > dust succeeds and mints > 0 shares.
 * 4. Assert that zero-asset deposit reverts.
 * 5. Confirm preview helpers (`previewDeposit`, `previewMint`) behave as
 *    expected and never return 0 for valid, non-reverting amounts.
 */
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { expect } from "chai";
import { ethers, getNamedAccounts } from "hardhat";

import { createDStakeFixture, SDUSD_CONFIG } from "./fixture";

const parseUnits = (val: string | number, decimals: number | bigint) =>
  ethers.parseUnits(val.toString(), decimals);

describe("Zero-share vulnerability", function () {
  // Use the sdUSD instance for the test
  const fixture = createDStakeFixture(SDUSD_CONFIG);

  let deployer: SignerWithAddress;
  let feeManager: SignerWithAddress;
  let victim: SignerWithAddress;

  let dStableDecimals: bigint;
  let DStakeToken: any;
  let dStableToken: any;
  let stable: any;

  beforeEach(async () => {
    const named = await getNamedAccounts();
    deployer = await ethers.getSigner(named.deployer);
    feeManager = await ethers.getSigner(named.user1 || named.deployer);
    victim = await ethers.getSigner(named.user2 || named.deployer);

    const out = await fixture();
    DStakeToken = out.DStakeToken;
    dStableToken = out.dStableToken;
    dStableDecimals = await dStableToken.decimals();

    stable = await ethers.getContractAt(
      "ERC20StablecoinUpgradeable",
      await dStableToken.getAddress(),
      deployer,
    );

    // Ensure deployer can mint for test funding
    const minterRole = await stable.MINTER_ROLE();
    await stable.grantRole(minterRole, deployer.address);
  });

  it("reaches dust state and mints 0 shares for small deposit", async function () {
    // 1. Enable 1% withdrawal fee via fee manager
    await DStakeToken.connect(feeManager).setWithdrawalFee(100); // 1 %

    // 2. Seed deposit (1000 dStable) by feeManager
    const seed = parseUnits("1000", dStableDecimals);
    await stable.mint(feeManager.address, seed);
    await dStableToken.connect(feeManager).approve(DStakeToken, seed);
    await DStakeToken.connect(feeManager).deposit(seed, feeManager.address);

    // Retrieve shares minted
    const initialShares = await DStakeToken.balanceOf(feeManager.address);

    // 3. Withdraw everything (redeem)
    await DStakeToken.connect(feeManager).redeem(
      initialShares,
      feeManager.address,
      feeManager.address,
    );

    // Ensure dangerous state
    expect(await DStakeToken.totalSupply()).to.equal(0n);
    const dust = await DStakeToken.totalAssets();
    expect(dust).to.be.gt(0n);

    // 4. Victim deposit smaller than dust
    const victimDeposit = dust - 1n; // strictly smaller
    // Fund victim
    await stable.mint(victim.address, victimDeposit);
    await dStableToken.connect(victim).approve(DStakeToken, victimDeposit);

    // previewDeposit should be 0
    expect(await DStakeToken.previewDeposit(victimDeposit)).to.equal(0n);

    // Deposit should revert due to ZERO_SHARES guard
    await expect(
      DStakeToken.connect(victim).deposit(victimDeposit, victim.address),
    ).to.be.revertedWithCustomError(DStakeToken, "ZeroShares");

    // previewMint for 1 share should return non-zero assets (no vulnerability)
    expect(await DStakeToken.previewMint(1n)).to.be.gt(0n);
  });

  it("reverts on zero asset deposit", async function () {
    await expect(
      DStakeToken.connect(victim).deposit(0n, victim.address),
    ).to.be.revertedWithCustomError(DStakeToken, "ZeroShares");
  });

  it("reverts when depositing amount equal to residual dust", async function () {
    // 1. Enable 1% withdrawal fee via fee manager and seed deposit as before
    await DStakeToken.connect(feeManager).setWithdrawalFee(100); // 1 %

    const seed = parseUnits("1000", dStableDecimals);
    await stable.mint(feeManager.address, seed);
    await dStableToken.connect(feeManager).approve(DStakeToken, seed);
    await DStakeToken.connect(feeManager).deposit(seed, feeManager.address);

    // Withdraw all to create dust
    const sharesSeed = await DStakeToken.balanceOf(feeManager.address);
    await DStakeToken.connect(feeManager).redeem(
      sharesSeed,
      feeManager.address,
      feeManager.address,
    );

    const dust = await DStakeToken.totalAssets();
    expect(dust).to.be.gt(0n);

    // Victim deposits exactly dust (should revert)
    await stable.mint(victim.address, dust);
    await dStableToken.connect(victim).approve(DStakeToken, dust);

    await expect(
      DStakeToken.connect(victim).deposit(dust, victim.address),
    ).to.be.revertedWithCustomError(DStakeToken, "ZeroShares");
  });

  it("accepts deposit greater than dust and mints shares", async function () {
    await DStakeToken.connect(feeManager).setWithdrawalFee(100); // 1 %

    const seed = parseUnits("1000", dStableDecimals);
    await stable.mint(feeManager.address, seed);
    await dStableToken.connect(feeManager).approve(DStakeToken, seed);
    await DStakeToken.connect(feeManager).deposit(seed, feeManager.address);

    // Withdraw to create dust
    const sharesSeed = await DStakeToken.balanceOf(feeManager.address);
    await DStakeToken.connect(feeManager).redeem(
      sharesSeed,
      feeManager.address,
      feeManager.address,
    );

    const dust = await DStakeToken.totalAssets();
    const victimDeposit = dust + 1n;

    await stable.mint(victim.address, victimDeposit);
    await dStableToken.connect(victim).approve(DStakeToken, victimDeposit);

    // previewDeposit should now be > 0
    const expectedShares = await DStakeToken.previewDeposit(victimDeposit);
    expect(expectedShares).to.be.gt(0n);

    // Deposit should succeed and mint expected shares
    const tx = await DStakeToken.connect(victim).deposit(
      victimDeposit,
      victim.address,
    );
    await tx.wait();

    expect(await DStakeToken.balanceOf(victim.address)).to.equal(
      expectedShares,
    );
  });
});
